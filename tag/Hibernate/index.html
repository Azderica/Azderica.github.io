<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Hello, world! - Azderica</title><meta name="gridsome:hash" content="314c4422387ef2cae421ff768d6b6746d38a40d1"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="부족하지만 꿈많은 웹 개발자의 발전 기록입니다."><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.d0be325ebfe2762f973f3e0685345394.png"><link rel="preload" href="/assets/css/0.styles.7a8bb02e.css" as="style"><link rel="preload" href="/assets/js/app.c516415e.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--tag-vue.01058a00.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.e05d67c3.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.d32f3f8d.js"><link rel="prefetch" href="/assets/js/page--src--templates--post-vue.5a18a2eb.js"><link rel="stylesheet" href="/assets/css/0.styles.7a8bb02e.css"><script data-vue-tag="ssr" type="text/javascript" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
    <link rel="icon" type="image/png" href="favicon.png" />
    <link rel="shortcut icon" type="image/png" href="favicon.png" />
    <meta
      name="google-site-verification"
      content="MqpGCz7XVg4s3AWfrGHCt6AlXPacpV9iGvSFVD0ATHw"
    />
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      ;(function() {
        window.__onThemeChange = function() {}
        function setTheme(newTheme) {
          window.__theme = newTheme
          preferredTheme = newTheme
          document.body.setAttribute('data-theme', newTheme)
          window.__onThemeChange(newTheme)
        }

        var preferredTheme
        try {
          preferredTheme = localStorage.getItem('theme')
        } catch (err) {}

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme)
          try {
            localStorage.setItem('theme', newTheme)
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)')
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        })

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'))
      })()
    </script>

    <div id="app" data-server-rendered="true"><header class="header"><div class="header__left"><a href="/" class="logo active"><span class="logo__text">
    ← Azderica
  </span></a></div><div class="header__right"><button role="button" aria-label="Toggle dark/light" class="toggle-theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></header><main class="main"><h1 class="tag-title text-center space-bottom">
    # Hibernate
  </h1><div class="posts"><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[DB] ORM에 대해 정리하기</h2><p class="post-card__description">ORM에 대해 정리합니다. </p><div class="post-meta post-card__meta">
   Posted 3. April 2021.
   <strong>5 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/00-db-orm/" class="post-card__link">Link</a></div></div><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[Java] JPA에 대해 정리하기</h2><p class="post-card__description">JPA에 대해 정리합니다. </p><div class="post-meta post-card__meta">
   Posted 22. March 2021.
   <strong>5 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/00-java-jpa/" class="post-card__link">Link</a></div></div></div></main><footer class="footer"><span class="footer__copyright">Copyright © 2022.
    </span><span class="footer__links">Powered by <a href="//gridsome.org"> Gridsome </a></span></footer></div> <script>window.__INITIAL_STATE__={"data":{"tag":{"title":"Hibernate","belongsTo":{"edges":[{"node":{"title":"[DB] ORM에 대해 정리하기","path":"\u002F00-db-orm\u002F","date":"3. April 2021","timeToRead":5,"description":"ORM에 대해 정리합니다. ","content":"\u003Ch1 id=\"orm에-대해\"\u003E\u003Ca href=\"#orm%EC%97%90-%EB%8C%80%ED%95%B4\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EORM에 대해\u003C\u002Fh1\u003E\n\u003Cp\u003E지난 게시글에서는 jpa에 대해서 정리하면서 ORM에 대한 개념을 언급했는데 오늘은 ORM에 대한 상세 내용을 정리합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fazderica.github.io\u002F00-java-jpa\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EJPA 정리글\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"영속성persistence\"\u003E\u003Ca href=\"#%EC%98%81%EC%86%8D%EC%84%B1persistence\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E영속성(Persistence)\u003C\u002Fh2\u003E\n\u003Cp\u003E먼저 ORM에 들어가기전에 영속성에 대한 개념을 정리합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E영속성은 다음을 의미합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터 특성\u003C\u002Fli\u003E\n\u003Cli\u003E영속성이 없는 데이터는 단지 메모리에서만 존재하므로, 프로그램 종료 시 모두 잃어버립니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003EObject Persistence(영구적인 객체)\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E메모리 상의 데이터를 File이나 DB를 활용해서 영속성을 부여합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E자바에서 데이터를 저장하는 방법은 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EJDBC\u003C\u002Fli\u003E\n\u003Cli\u003ESpring JDBC\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003EPersistence Framework\u003C\u002Fstrong\u003E(Hibernate, Mybatis...)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EPersistence Framework\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003EPersistence Layer\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E데이터베이스에서 데이터를 읽어(Read) 객체화하거나, 데이터 베이스에 데이터를 저장(Create), 수정(Update), 삭제(Delete)하는 역할\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003EPersistence Framework\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EJDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와연동되는 시스템을 빠르게 개발할 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E일반적으로 SQL Mapper와 ORM으로 나눠집니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Ccode class=\"language-text\"\u003ESQL Mapper\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ESQL &#x3C;-\u003E SQL Mapper &#x3C;-\u003E Object 필드\u003C\u002Fli\u003E\n\u003Cli\u003ESQL 문장으로 직접 데이터베이스 데이터를 다룬다.\u003C\u002Fli\u003E\n\u003Cli\u003ESQL을 직접 작성합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003EMybatis, JdbcTemplates(Spring)\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Ccode class=\"language-text\"\u003EORM\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EDatabase data &#x3C;-\u003E ORM &#x3C;-\u003E Object 필드\u003C\u002Fli\u003E\n\u003Cli\u003E객체를 통해서 간접적으로 데이터베이스 데이터를 다룹니다.\u003C\u002Fli\u003E\n\u003Cli\u003E객체와 관계형 데이터베이스의 데이터를 자동으로 맵핑시켜줍니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003EJPA, Hibernate\u003C\u002Fstrong\u003E 등이 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"orm의-정의\"\u003E\u003Ca href=\"#orm%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EORM의 정의\u003C\u002Fh2\u003E\n\u003Cp\u003EORM(Object-relational mapping)은 \u003Cstrong\u003E객체(클래스)와 관계(RDB, Relational Database)와의 설정\u003C\u002Fstrong\u003E을 의미합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E객체 지향 프로그래밍은 클래스를 사용하고 관계형 데이터 베이스는 테이블을 사용합니다. 여기서 객체 모델과 관계형 모델간에 불일치가 발생하게 되는데, ORM은 이러한 \u003Cstrong\u003E불일치를 객체간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결\u003C\u002Fstrong\u003E합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F111995242-0ca00d80-8b5c-11eb-9662-7f60f1dfc0c7.png\" alt=\"ORM\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E해당 그림처럼, Object와 DB 데이터 사이에서 매핑을 합니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"orm의-장단점\"\u003E\u003Ca href=\"#orm%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EORM의 장단점\u003C\u002Fh2\u003E\n\u003Ch3 id=\"orm-장점\"\u003E\u003Ca href=\"#orm-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EORM 장점\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E객체 지향적 코드를 사용함으로서 직관적이보 비지니스 로직에 집중할 수 있도록 도와줍니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ECRUD를 위한 SQL문을 작성할 필요는 없습니다. (쿼리 작성은 필요)\u003C\u002Fli\u003E\n\u003Cli\u003E각 객체(Model) 별로 코드를 작성하므로 가독성이 높아집니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E재사용 및 유지 보수의 편리성이 증가합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EORM은 독립적으로 작성이 되어 있고 해당 객체들은 재사용이 가능합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EDBMS에 대한 종속성이 줄어듭니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E대부분의 ORM은 DB에 비종속적입니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"orm-단점\"\u003E\u003Ca href=\"#orm-%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EORM 단점\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E완벽한 ORM만으로는 구현하기가 어렵습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E사용하기는 편하지만 설계는 신중해야합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E프로젝트의 복잡성이 높아질 경우, 난이도가 높아집니다.\u003C\u002Fli\u003E\n\u003Cli\u003E잘못 구현하는 경우 속도 저하 및 심한 경우, 일관성이 무너질 수도 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E프로시저가 많은 시스템에서는 ORM의 객체 지향적인 장점을 활용하기가 어렵습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"orm의-종류\"\u003E\u003Ca href=\"#orm%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EORM의 종류\u003C\u002Fh2\u003E\n\u003Cp\u003E앞서 이야기한 것외에도 다양한 ORM이 존재합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EFlask : SQLAlchemy\u003C\u002Fli\u003E\n\u003Cli\u003EDjango : 내장 ORM\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003ENode.js : Sequalize\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003EJava : Hybernate, JPA\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EGraphQL : Prisma\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E해당 ORM에 대해서는 직접 사용해보면서 차이를 느껴보고 개념을 이해하는 것을 추천합니다. (개인적으로 사용해본 것은 Sequalize와 Hybernate, JPA이지만, 실무에서는 따로 환경이 안나와서 써보지 못했습니다...)\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"마무리\"\u003E\u003Ca href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E마무리.\u003C\u002Fh2\u003E\n\u003Cp\u003E핵심적인 내용은 정리르 했으나, 개인적으로 알고 싶은 내용인 queryDsl과 Jooq에 대해서는 따로 정리를 하지 못했습니다. 해당 글은 좀 더 개념을 잡아 정리하겠습니다.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvelog.io\u002F@alskt0419\u002FORM%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C...-iek4f0o3fg\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EORM이란?\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fchangrea.io\u002Fjpa\u002Form\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EORM\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvelog.io\u002F@alskt0419\u002FORM%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C...-iek4f0o3fg\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EORM에 대해서\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgmlwjd9405.github.io\u002F2019\u002F02\u002F01\u002Form.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EDB, ORM이란\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}},{"node":{"title":"[Java] JPA에 대해 정리하기","path":"\u002F00-java-jpa\u002F","date":"22. March 2021","timeToRead":5,"description":"JPA에 대해 정리합니다. ","content":"\u003Ch1 id=\"jpa\"\u003E\u003Ca href=\"#jpa\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EJPA\u003C\u002Fh1\u003E\n\u003Cp\u003E오늘은 앞으로 공부할 QueryDsl, Jooq 등의 개념을 공부하기 위해서 앞서 가장 기본적인 내용을 정리합니다.\u003C\u002Fp\u003E\n\u003Ch2 id=\"jpa-개념\"\u003E\u003Ca href=\"#jpa-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EJPA 개념\u003C\u002Fh2\u003E\n\u003Cp\u003EJPA는 \u003Cstrong\u003EJava Persistence API\u003C\u002Fstrong\u003E 의 약자로서, RDBMS와 OOP 객체 사이의 불일치에서 오는 패러다임을 해결하기 위해서 만들어졌습니다. 이러한 JPA는 ORM(Object-Relational Mapping) 기술입니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"orm\"\u003E\u003Ca href=\"#orm\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EORM?\u003C\u002Fh3\u003E\n\u003Cp\u003EORM이란 Object Relational Mapping, 객체-관계 매핑의 줄임말입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E좀 더 풀어 설명하자면 OOP의 객체 구현 클래스와 RDBMS에서 사용하는 테이블을 자동으로 매핑하는 것을 의미합니다. 이 때, 클래스와 테이블은 서로 기존부터 호환 가능성을 두고 만들어진 것이 아니므로 불일치가 발생하는데 이를 ORM을 통해서 객체 간의 관계를 바탕으로 SQL문을 자동으로 생성하여 불일치를 해결합니다. 이 방법을 통해서 SQL문을 짤 필요없이 객체를 통해 간접적으로 데이터베이스를 조작할 수 있습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이를 이미지로 나타내면 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F111995242-0ca00d80-8b5c-11eb-9662-7f60f1dfc0c7.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E좀 더 자세한 ORM은 아래 글을 참조해주세요.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fazderica.github.io\u002F00-db-orm\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EORM\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"그래서-jpa를-좀-더-설명하자면\"\u003E\u003Ca href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-jpa%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%84%A4%EB%AA%85%ED%95%98%EC%9E%90%EB%A9%B4\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E그래서 JPA를 좀 더 설명하자면.\u003C\u002Fh3\u003E\n\u003Cp\u003E앞서 이야기 나온 ORM 기술을 구현하기 위해 나온 프레임워크가 Hibernate이고, 그 외에도 다른 프레임워크(CoCobase, TopLink) 등이 등장했습니다. 이러한 ORM 구현 프레임워크에 대한 \u003Cstrong\u003E표준화\u003C\u002Fstrong\u003E가 필요하게 되었는데 이가 바로 JPA입니다.\u003C\u002Fp\u003E\n\u003Cp\u003EJPA는 어플리케이션과 DBMS 사이의 인터페이스 역할을 해주기 때문에. 개발자는 JPA 인터페이스에 맞춰우 구현되어 있는 기능을 사용하면 됩니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이를 잘 표현한 이미지는 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F111996259-2b52d400-8b5d-11eb-8fdb-1f6a91096d4c.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E다음과 같이, 개발자는 SQL를 직접 사용할 필요없이 사용할 수 있습니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"jpa-동작-과정\"\u003E\u003Ca href=\"#jpa-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EJPA 동작 과정\u003C\u002Fh2\u003E\n\u003Cp\u003EJPA는 다음과 같이 동작합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F112302631-a394d300-8cde-11eb-8c1e-3693ae32a978.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EJPA는 애플리케이션과 JDBC 사이에서 동작합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E개발자가 JPA 사용시, JPA 내부에서 JDBC API를 사용하여 SQL을 호출하고 DB와 통신합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"jpa를-사용해야하는-이유\"\u003E\u003Ca href=\"#jpa%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EJPA를 사용해야하는 이유?\u003C\u002Fh2\u003E\n\u003Ch3 id=\"1-sql-중심-개발---객체-중심-개발\"\u003E\u003Ca href=\"#1-sql-%EC%A4%91%EC%8B%AC-%EA%B0%9C%EB%B0%9C---%EA%B0%9D%EC%B2%B4-%EC%A4%91%EC%8B%AC-%EA%B0%9C%EB%B0%9C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. SQL 중심 개발 -\u003E 객체 중심 개발\u003C\u002Fh3\u003E\n\u003Cp\u003ESQL 중심의 개발 문제를 해결합니다.\u003C\u002Fp\u003E\n\u003Cp\u003ESQL 중심의 개발 문제는 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E지루한 코드가 반복됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E객체 지향과 RDB 간의 패러다임이 불일치됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E객체 지향은 상속 관계를 지원합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E모델링 과정에서의 문제를 해결합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E객체 그래프 탐색에서의 문제를 해결합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ESQL 중심 개발은 객체 그래프를 탐색할 수 없습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"2-생산성\"\u003E\u003Ca href=\"#2-%EC%83%9D%EC%82%B0%EC%84%B1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2. 생산성\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EJPA을 사용함으로서 \u003Ccode class=\"language-text\"\u003Ejava.collection\u003C\u002Fcode\u003E처럼 편하게 사용가능합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E간단한 CRUD를 제공합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003Ejpa.persist\u003C\u002Fcode\u003E, \u003Ccode class=\"language-text\"\u003Efind\u003C\u002Fcode\u003E, \u003Ccode class=\"language-text\"\u003Eset~\u003C\u002Fcode\u003E, \u003Ccode class=\"language-text\"\u003Ejpa.remove\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E수정이 간단합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"3-유지보수\"\u003E\u003Ca href=\"#3-%EC%9C%A0%EC%A7%80%EB%B3%B4%EC%88%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. 유지보수\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E기존처럼 모든 SQL을 수정할 필요가 없습니다.\u003C\u002Fli\u003E\n\u003Cli\u003EJPA에서는 필드만 추가하고, SQL은 JPA가 처리합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"4-패러다임-불일치의-해결\"\u003E\u003Ca href=\"#4-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84-%EB%B6%88%EC%9D%BC%EC%B9%98%EC%9D%98-%ED%95%B4%EA%B2%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E4. 패러다임 불일치의 해결\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E상속, 연관관계, 객체 그래프 탐색, 비교와 같은 패러다임의 불일치 문제를 해결해줍니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"5-성능적-이슈\"\u003E\u003Ca href=\"#5-%EC%84%B1%EB%8A%A5%EC%A0%81-%EC%9D%B4%EC%8A%88\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E5. 성능적 이슈\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EJPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기능을 제공합니다.\u003C\u002Fli\u003E\n\u003Cli\u003EEx. 동일 데이터 find로 2번 접근하는 경우, 재사용을 통해서 사용합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"6-데이터-접근-추상화와-벤더-독립성\"\u003E\u003Ca href=\"#6-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%91%EA%B7%BC-%EC%B6%94%EC%83%81%ED%99%94%EC%99%80-%EB%B2%A4%EB%8D%94-%EB%8F%85%EB%A6%BD%EC%84%B1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E6. 데이터 접근 추상화와 벤더 독립성\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E애플리케이션은 처음 선택한 데이터베이스 기술에 종속되고 다른 데이터베이스로 변경하기 어렵습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"jpa-사용-방법\"\u003E\u003Ca href=\"#jpa-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EJPA 사용 방법\u003C\u002Fh2\u003E\n\u003Cp\u003E다음과 같은 메소드 들이 있습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Ccode class=\"language-text\"\u003Eflush()\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EPersistence Context의 변경 내용을 데이터베이스에 반영합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E일반적으로는 직접 사용하지는 않고, 자바 애플리케이션에서 커밋 명령이 들어왔을 때 자동으로 실행됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Ccode class=\"language-text\"\u003Edetach()\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E특정 Entity를 준영속 상태(영속 컨텍스트의 관리를 받지않음)로 바꿉니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Ccode class=\"language-text\"\u003Eclear()\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EPersistence Context를 초기화합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Ccode class=\"language-text\"\u003Eclose()\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EPersistence Context를 종료합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Ccode class=\"language-text\"\u003Emerge()\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E준영속 상태의 엔티티 특징\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Ccode class=\"language-text\"\u003Efind()\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E식별자 값을 통해 Entity를 찾습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Ccode class=\"language-text\"\u003Epersist()\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E생성도니 Entity를 Persistence Context와 DB에 저장합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Ccode class=\"language-text\"\u003Eremove()\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E식별자 값을 통해 Entity를 삭제합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Chr\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fspring.io\u002Fprojects\u002Fspring-data-jpa\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ESpring Data JPA Doc\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Ftinkerbellbass.tistory.com\u002F24\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EJPA 기본 개념\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdoublesprogramming.tistory.com\u002F257\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EJPA 기본 개념 2\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fblog.woniper.net\u002F255\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EJPA란 무엇인가\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fokminseok.blogspot.com\u002F2019\u002F09\u002Fjpa.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EJPA 코드 없이 적는 기본 개념\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgeonlee.tistory.com\u002F207\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EORM의 장단점\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgmlwjd9405.github.io\u002F2019\u002F08\u002F04\u002Fwhat-is-jpa.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EJPA란\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}}]}}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.c516415e.js" defer></script><script src="/assets/js/page--src--templates--tag-vue.01058a00.js" defer></script>
  </body>
</html>
