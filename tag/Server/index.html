<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Hello, world! - Azderica</title><meta name="gridsome:hash" content="78233c70288de5cc80ede0d03ef7918cb4b6eee5"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="부족하지만 꿈많은 웹 개발자의 발전 기록입니다."><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.d0be325ebfe2762f973f3e0685345394.png"><link rel="preload" href="/assets/css/0.styles.00c517b5.css" as="style"><link rel="preload" href="/assets/js/app.bdd1e6a6.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--tag-vue.762abdba.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.b6200640.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.a32bdba5.js"><link rel="prefetch" href="/assets/js/page--src--templates--post-vue.f3f1159d.js"><link rel="stylesheet" href="/assets/css/0.styles.00c517b5.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <meta name="google-site-verification" content="MqpGCz7XVg4s3AWfrGHCt6AlXPacpV9iGvSFVD0ATHw" />
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      (function() {
        window.__onThemeChange = function() {};
        function setTheme(newTheme) {
          window.__theme = newTheme;
          preferredTheme = newTheme;
          document.body.setAttribute('data-theme', newTheme);
          window.__onThemeChange(newTheme);
        }

        var preferredTheme;
        try {
          preferredTheme = localStorage.getItem('theme');
        } catch (err) { }

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme);
          try {
            localStorage.setItem('theme', newTheme);
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)');
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        });

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'));
      })();
    </script>

    <div id="app" data-server-rendered="true"><header class="header"><div class="header__left"><a href="/" class="logo active"><span class="logo__text">
    ← Azderica
  </span></a></div><div class="header__right"><button role="button" aria-label="Toggle dark/light" class="toggle-theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></header><main class="main"><h1 class="tag-title text-center space-bottom">
    # Server
  </h1><div class="posts"><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[Architeture] 서버리스 아키텍처에 대한 기초 지식</h2><p class="post-card__description"> 서버리스와 서버 아키텍처에 대한 기본 내용을 정리한 글입니다. </p><div class="post-meta post-card__meta">
   Posted 25. November 2020.
   <strong>12 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/00-architecture-serverless/" class="post-card__link">Link</a></div></div><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[Elastic Search] Elastic Search란?</h2><p class="post-card__description"> 엘라스틱서치에 대한 기본 내용을 정리한 글입니다. </p><div class="post-meta post-card__meta">
   Posted 16. November 2020.
   <strong>9 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/00-elasticsearch/" class="post-card__link">Link</a></div></div></div></main><footer class="footer"><span class="footer__copyright">Copyright © 2020. </span><span class="footer__links">Powered by <a href="//gridsome.org"> Gridsome </a></span></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"tag":{"title":"Server","belongsTo":{"edges":[{"node":{"title":"[Architeture] 서버리스 아키텍처에 대한 기초 지식","path":"\u002F00-architecture-serverless\u002F","date":"25. November 2020","timeToRead":12,"description":" 서버리스와 서버 아키텍처에 대한 기본 내용을 정리한 글입니다. ","content":"\u003Ch1 id=\"서버리스-아키텍처에-대하여\"\u003E\u003Ca href=\"#%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E서버리스 아키텍처에 대하여\u003C\u002Fh1\u003E\n\u003Cp\u003E회사에서 개발과 관련해서 이야기를 하는데, CaaS, FaaS, BaaS 등에 대한 이야기를 듣게 되었다. 생각해보니 이름만 들어보고 한 번도 제대로 알아본적이 없어서 이번기회에 정리합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E서버리스(Serverless)란 말 그대로 서버가 없다는 의미는 아닙니다. 다만, 특정 작업을 수행하기 위해서 컴퓨터 혹은 가상머신에 서버를 설정할 필요없이 다른 서비스(BaaS, FaaS) 등에 의존해서 작업을 처리합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F100229273-5474a680-2f67-11eb-8a3a-467c9f409a72.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E들어가기에 앞서서 간단한 발전 과정은 다음과 같습니다.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"기존-애플리케이션\"\u003E\u003Ca href=\"#%EA%B8%B0%EC%A1%B4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E기존 애플리케이션\u003C\u002Fh2\u003E\n\u003Ch3 id=\"1-자체-설계\"\u003E\u003Ca href=\"#1-%EC%9E%90%EC%B2%B4-%EC%84%A4%EA%B3%84\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. 자체 설계\u003C\u002Fh3\u003E\n\u003Cp\u003E시스템에서 필요한 모든 인프라를 직접 관리합니다. 기존의 \u003Cstrong\u003E전산실\u003C\u002Fstrong\u003E로 이해하면 됩니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E필요한 모든 인프라를 직접 관리. 예를 들어 기업 전산실에서 서버 및 하드웨어, 네트워크, 운영체제 등을 갖추어 모두 직접 처리해야합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E시스템이 커질 수록 유지할 관리자가 필요하고, 이에 따른 비용이 발생합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"2-iaasinfrastructure-as-a-service\"\u003E\u003Ca href=\"#2-iaasinfrastructure-as-a-service\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2. IaaS(Infrastructure as a Service)\u003C\u002Fh3\u003E\n\u003Cp\u003EAWS, Azure 등의 서비스에서 제공하는 서비스입니다. 서버자원, 네트워크, 전력 등의 인프라를 직접 구축할 필요없이 이러한 \u003Cstrong\u003E인프라를 가상화\u003C\u002Fstrong\u003E하여 관리하기 쉽게 해주는 서비스를 제공합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E사용자는 해당 서비스를 통해서 관리자패널에서 인프라를 구성하면 됩니다. 사용자는 가상머신을 만들고 네트워크를 설정하고, 하드웨어를 설정하고, 운영체제를 설치해서 애플리케이션을 구동합니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"3-paasplatform-as-a-service\"\u003E\u003Ca href=\"#3-paasplatform-as-a-service\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. PaaS(Platform as a Service)\u003C\u002Fh3\u003E\n\u003Cp\u003EIaaS에서 좀 더 추상화된 모델입니다. 네트워크, OS, 런타임을 제공합니다. 사용자는 애플리케이션만 배포하면 바로 구동할 수 있습니다. 또한 Auto Scaling 및 Load Balacing도 손쉽게 적용가능합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E예시로는 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAWS Elastic Beanstalk, Azure App Servies 등등\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"servless\"\u003E\u003Ca href=\"#servless\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EServless\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E서버리스는 애플리케이션 개발자가 서버를 프로비저닝하거나 애플리케이션의 확장을 관리할 필요가 없습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E프로비저닝(Provisioning) : 사용자의 요구에 맞게 시스템을 할당하고 배치, 배포한 이후 필요시에 시스템을 즉시 사용할 수 있는 상태로 미리 준비해놓는 것입니다.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cul\u003E\n\u003Cli\u003E서버가 없다는 뜻은 아니며, 작업을 처리하는 서버는 있지만 서버를 관리할 필요가 없습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E대표적으로 \u003Cstrong\u003EBaaS\u003C\u002Fstrong\u003E 와 \u003Cstrong\u003EFaaS\u003C\u002Fstrong\u003E로 나눠집니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"1-baasbackend-as-a-service\"\u003E\u003Ca href=\"#1-baasbackend-as-a-service\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. BaaS(Backend as a Service)\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F100353200-82beb880-3031-11eb-89d9-5a361d5f88c4.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E애플리케이션에서 일반 사용자가 보는 영역은 프론트엔드, 관리자가 보는 영역은 백엔드로 불립니다. \u003Cstrong\u003E이때 BaaS는 백엔드인 관리자 영역을 모듈화하여 서비스\u003C\u002Fstrong\u003E로 제공합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E백엔드 개발(데이터 저장, 다른 기기로 접근, 파일 공유 등)이 필요한 경우, 개발자가 이러한 모든 서비스를 구축하기 어려워서, BaaS를 통해서 개발 시간을 단축합니다.\u003C\u002Fli\u003E\n\u003Cli\u003EIaaS, PaaS가 서버 인프라를 대체하는 정도였다면, \u003Cstrong\u003EBaaS와 FaaS는 서버 운영까지 맡기는 서비스\u003C\u002Fstrong\u003E입니다.\u003C\u002Fli\u003E\n\u003Cli\u003E대표적인 서비스로는 \u003Cstrong\u003EFirebase\u003C\u002Fstrong\u003E가 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E장점\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E개발 시간의 단축\u003C\u002Fli\u003E\n\u003Cli\u003E서버 확장의 불필요함\u003C\u002Fli\u003E\n\u003Cli\u003E백엔드에 대한 지식이 부족하더라도 빠른 속도로 개발이 가능\u003C\u002Fli\u003E\n\u003Cli\u003E토이 프로젝트, 소규모 프로젝트에서는 백엔드로 유용하게 사용가능\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E단점\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E클라이언트 위주의 코드\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E백엔드 로직이 클라이언트 쪽에 구현됨 (보안 등의 큰 이슈)\u003C\u002Fli\u003E\n\u003Cli\u003EFirebase SDK를 통해 서버쪽에서 개발할 수 있지만, 이보다는 직접 구현이 좋습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E데이터단의 로직이 변경되면 클라이언트 코드 수정이 이루어집니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E가격\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EFirebase의 경우 초반에는 무료이지만, 앱의 규모가 커지면 비싸집니다.\u003C\u002Fli\u003E\n\u003Cli\u003E서비스 규모가 늘어날 수록 직접 구현의 장점이 가능합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E복잡한 쿼리가 불가능함\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EFirebase는 데이터 베이스가 하나의 큰 Json 형식으로 구조화 되어 있습니다. \u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"2-faasfunction-as-a-service\"\u003E\u003Ca href=\"#2-faasfunction-as-a-service\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2. FaaS(Function as a Service)\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F100354291-468c5780-3033-11eb-8d18-e6b0ba4fdf20.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E코드, \u003Cstrong\u003E함수\u003C\u002Fstrong\u003E를 서비스로 제공합니다. 애플리케이션 개발에서 함수를 실행하기 위해 서버를 올리고 런타임을  구성하고 코드를 배포해서 실행해야 하는 일련의 과정을 없애고 원하는 로직을 함수로 등록만 해놓으면 특정 이벤트시 함수가 실행되고 종료됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E서버가 계속 대기하면서 사용자의 요청하는 것이 아니라, 이벤트가 발생했을 때만 함수가 실행되기 때문에 함수가 실행되는 시간 및 호출된 횟수만큼만 비용을 지불합니다.\u003C\u002Fli\u003E\n\u003Cli\u003EPaaS의 경우는 전체 애플리케이션을 배포하여 서버에서 애플리케이션이 계속 돌아가지만, FaaS는 애플리케이션을 더 작게 쪼갠 함수를 배포하며, 특정 이벤트가 발생했을 때만 실행되고 종료됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E주로 서비스 사이의 간단한 작업을 처리하는 용도로 쓰이며, BaaS와 결합해서 사용하기 좋습니다. 대표적인 예시로는 AWS Lambda, 구글의 Knative, Nuclio 등이 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E장점\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E비용\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E특정 작업을 하기위해 서버를 준비하고 켜놓는 것이 아니라면, 필요시만 호출되기 때문에 많은 비용을 절감할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E인프라 관리\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E네트워크, 장비 등에 대해 신경쓸 필요가 없습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E인프라 보안\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E리눅스 업데이트, 취약점 보안 패치 등에 큰 신경을 쓰지 않다도 됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E확장성\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E확장성에서 굉장히 유연합니다. (AutoScaling 등의 필요없습니다. 그저 호출만 될뿐...)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E단점\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E제한\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E함수에서 사용할 수 있는 자원의 제한이 존재합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E웹소켓과 같이 계속 켜놓는 것은 사용하기 힘듭니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E제공사에 대한 강한 의존\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E로컬 데이터 사용 불가능\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E함수들은 무상태이기 때문에 이 데이터를 로컬 스토리지에 쓸수없습니다. (물론, AWS는 S3, Azure는 Storage를 사용 가능합니다.)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"3-정리\"\u003E\u003Ca href=\"#3-%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. 정리\u003C\u002Fh3\u003E\n\u003Cp\u003EServerless의 특징은 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003ECold Start\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E클라우드 업체는 자원을 효율적으로 관리하기 위해 일정 기간 행위가 없는 사용자에게는 컴퓨팅 파워를 제공하지않습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E비활성 함수가 갑자기 호출되면 서버가 준비되는 지연 시간이 발생하여 애플리케이션 성능에 영향을 줄 수도 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EStateless\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E함수가 없는 경우에는 모든 리소스 종류가 존재하지 않습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E세션을 보존해야하는 경우에는 DB에 저장하는 것이 좋습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E일시적 컨테이너\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E특정 이벤트가 발생하는 일정 기간 동안에만 컨테이너에 배포되고, 그 이후는 자원이 없습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E큰 요구사항이 필요한 경우에는 적합하지 않습니다.\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E언어지원\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAWS Lambda: Node.js, Python, Java, C#, Go\u003C\u002Fli\u003E\n\u003Cli\u003EMS Azure: C#, Javascript, F#, Python, Batch, PHP, PowerShell\u003C\u002Fli\u003E\n\u003Cli\u003EGoogle Function: Node.js, Python, Javascript\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003ENoSQL\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E함수는 제한된 데이터베이스 색인(Index)을 구성하기 때문에 서버리스 아키텍처에서 관계형 데이터베이스를 사용하면 동시 연결 수 제한으로 확장성과 성능 문제가 발생합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E따라서 RDBMS 보다는 \u003Cstrong\u003ENoSQL\u003C\u002Fstrong\u003E이 적합합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E그러나. 현재는 Stateless, 일시적 컨테이너에 따른 특징으로 인해 \u003Cstrong\u003E큰 프로젝트에는 적합하지 않습니다.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"그-외\"\u003E\u003Ca href=\"#%EA%B7%B8-%EC%99%B8\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E그 외.\u003C\u002Fh2\u003E\n\u003Ch3 id=\"1-caascontainer-as-as-service\"\u003E\u003Ca href=\"#1-caascontainer-as-as-service\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. CaaS(Container as as Service)\u003C\u002Fh3\u003E\n\u003Cp\u003E컨테이너 기반 추상화를 통해 사용자가 애플리케이션을 배포하고 관리하도록 지원하는 클라우드 서비스 컴퓨팅 모델입니다. 제공없체는 컨테이너가 배포 및 관리되는 프레임워크 또는 오케스트레이션 플랫폼을 제공합니다.\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E오케스트레이션(orchestration)이란?\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EContainer orchestration이란 컨테이너의 배포, 관리, 확장 및 네트워킹을 자동화합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E클라우드 서비스의 범위에서 CaaS는 IaaS의 하위집합으로 간주되며 I\u003Cstrong\u003EaaS와 서비스 플랫폼인 PaaS 사이\u003C\u002Fstrong\u003E에 존재한다고 이해하면 됩니다.\u003C\u002Fp\u003E\n\u003Cp\u003E컨테이너를 사용하므로 다음과 같은 특징을 가집니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E이식성 : private, public 등의 다양한 환경에서 배포가능\u003C\u002Fli\u003E\n\u003Cli\u003E확장성 : 컨테이너의 수를 늘려서 확장할 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E효율성 : 컨테이너는 별도의 운영체제가 필요없으므로 가상 머신(VM)보다 리소스가 적게 필요합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E보안강화 : 컨테이너는 격리되어 있으므로 다른 컨테이너에 영향을 주지 않습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E속도 : 운영 체제에 구애받지 않기 때문에 시작과 종료시간이 짧습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E이와 같은 환경에서는 \u003Cstrong\u003E쿠버네티스\u003C\u002Fstrong\u003E를 사용하는 것이 좋습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E쿠버네티스에 대한 간단한 정리는 아래의 링크를 보시면 좋을 듯합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E: \u003Ca href=\"https:\u002F\u002Fazderica.github.io\u002Fbackend\u002F2020\u002F11\u002F10\u002Fbackend-kubernetes-study\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E쿠버네티스란?\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"정리\"\u003E\u003Ca href=\"#%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E정리.\u003C\u002Fh2\u003E\n\u003Cp\u003E간단하게 서버리스 아키텍처에 대해 정리하였습니다. 흔히 듣던, IaaS, BaaS, PaaS, FaaS에 대해 간단하게 정리해보았고, 최근에 들었던 CaaS에 대해서도 간단하게 조사했습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이후 부족한 내용이나 보완되어야하는 내용이 있다면 편하게 이야기주세요.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvelopert.com\u002F3543\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fvelopert.com\u002F3543\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fstonesteel1023.github.io\u002FTIL181109\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fstonesteel1023.github.io\u002FTIL181109\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fm.blog.naver.com\u002FPostView.nhn?blogId=shakey7&#x26;logNo=221739057486&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fm.blog.naver.com\u002FPostView.nhn?blogId=shakey7&#x26;logNo=221739057486&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.redhat.com\u002Fko\u002Ftopics\u002Fcloud-computing\u002Fwhat-is-caas\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fwww.redhat.com\u002Fko\u002Ftopics\u002Fcloud-computing\u002Fwhat-is-caas\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}},{"node":{"title":"[Elastic Search] Elastic Search란?","path":"\u002F00-elasticsearch\u002F","date":"16. November 2020","timeToRead":9,"description":" 엘라스틱서치에 대한 기본 내용을 정리한 글입니다. ","content":"\u003Ch1 id=\"elasticsearch\"\u003E\u003Ca href=\"#elasticsearch\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EElasticsearch.\u003C\u002Fh1\u003E\n\u003Cp\u003E오늘은 Elasticsearch에 대한 기본적인 내용을 정리합니다.\u003C\u002Fp\u003E\n\u003Ch2 id=\"elasticsearch란\"\u003E\u003Ca href=\"#elasticsearch%EB%9E%80\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EElasticsearch란?\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cstrong\u003EElasticsearch는 Apache Lucene(아파치 루씬)을 기반으로 한 Java 오픈소스 분산 검색 엔진입니다.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EElasticsearch는 방대한 양의 데이터를 거의 실시간(NRT, Near Real Time)으로 저장, 검색, 분석할 수 있습니다. 이러한 Elasticsearch는 검색을 위해 단독으로 쓰이기도 하며, \u003Cstrong\u003EELK\u003C\u002Fstrong\u003E 스택으로 사용되기도 합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E먼저 Elasticsearch에 본격적으로 들어가기 앞서서, ELK란 (Elasticsearch, Logstatsh, Kibnana)을 의미합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E간단하게 ELK 스택을 설명하면 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F99964448-9e7a5280-2dd6-11eb-9bdc-1ae7cf9f2498.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003ELogstash\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E다양한 소스(DB, csv파일 등)의 로그나 트랜잭션 데이터를 수집, 집계, 파싱하여 Elasticsearch로 전달합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EElasticsearch\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ELogstash로 받은 데이터를 검색 및 집계하여 필요한 관심 정보를 받습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EKibana\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EElasticsearch의 검색 결과를 통해 데이터를 시각화하고 모니터링합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"elasticsearch-용어-정의\"\u003E\u003Ca href=\"#elasticsearch-%EC%9A%A9%EC%96%B4-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EElasticsearch 용어 정의\u003C\u002Fh2\u003E\n\u003Ch3 id=\"논리적-구조\"\u003E\u003Ca href=\"#%EB%85%BC%EB%A6%AC%EC%A0%81-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E논리적 구조\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F99964489-b05bf580-2dd6-11eb-9962-78eae078e84b.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Ch4 id=\"도큐먼트document\"\u003E\u003Ca href=\"#%EB%8F%84%ED%81%90%EB%A8%BC%ED%8A%B8document\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E도큐먼트(Document)\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003EElasticsearch 데이터 최소 단위(RDBMS의 Row와 비슷)하고, JSON 오브젝트 중 하나입니다.\u003C\u002Fli\u003E\n\u003Cli\u003E하나의 Document는 다양한 필드로 구성되어 있으며, Document 내부에 Document가 들어갈 수도 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"타입type\"\u003E\u003Ca href=\"#%ED%83%80%EC%9E%85type\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E타입(Type)\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E여러개의 Document가 모여서 한 개의 Type을 이룹니다.(RDBMS의 테이블과 비슷)\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003EElasticsearch 7.0부터 사라졌습니다.\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"필드field\"\u003E\u003Ca href=\"#%ED%95%84%EB%93%9Cfield\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E필드(Field)\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003EDocument에 들어가는 데이터 타입(RDBMS의 column)와 비슷합니다. \u003C\u002Fli\u003E\n\u003Cli\u003EElasticsearch의 필드는 RDBMS보다 동적입니다. 즉. 하나의 데이터 타임만 가질 수 있는 RDBMS와 달리, 하나의 필드가 여러개의 타입을 가질 수 있습니다.  \u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"매핑mapping\"\u003E\u003Ca href=\"#%EB%A7%A4%ED%95%91mapping\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E매핑(Mapping)\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E매핑(Mapping)은 필드와 필드의 속성을 정의합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E매핑 정보에 여러가지 데이터 타입 지정이 가능하지만 필드명 자체는 중복이 불가능합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"인덱스index\"\u003E\u003Ca href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4index\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E인덱스(Index)\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E여러개의 Type이 모여 한 개의 Index를 이룹니다.(RDBMS의 Database와 비슷)\u003C\u002Fli\u003E\n\u003Cli\u003EElasticsearch 6.1 부터는 \u003Cstrong\u003E하나의 Index\u003C\u002Fstrong\u003E는 \u003Cstrong\u003E하나의 Type\u003C\u002Fstrong\u003E만 가집니다.(Database + Table과 비슷)\u003C\u002Fli\u003E\n\u003Cli\u003EElasticsearch를 클러스터(분산환경)을 구성하는 경우, Index는 여러 노드에 분산 저장 및 관리가 됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E기본 설정은 5개의 Primary Shard와 1개의 Replica Shard로 생성됩니다. 옵션 값으로 변경 가능합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"물리적-구조\"\u003E\u003Ca href=\"#%EB%AC%BC%EB%A6%AC%EC%A0%81-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E물리적 구조\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F99964072-15fbb200-2dd6-11eb-9485-1887247ebdb4.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Ch4 id=\"노드node\"\u003E\u003Ca href=\"#%EB%85%B8%EB%93%9Cnode\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E노드(Node)\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E노드는 Elasticsearch 클러스터에 포함된 \u003Cstrong\u003E단일 서버\u003C\u002Fstrong\u003E로서 데이터를 저장하고 클러스터의 색인화 및 검색 기능에 참여합니다. 노드는 클러스터처럼 이름으로 식별됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E일반적으로 노드의 종류는 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E마스터 노드(Master node)\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E클러스터 관리 노드\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E노드 추가\u002F제거, 인덱스 생성\u002F삭제 등 클러스터의 전반적 관리를 담당합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E여러개의 마스터 노드를 설정하면 하나의 마스터 노드로 작동됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003Eelasticsearch.yml\u003C\u002Fcode\u003E 에서 \u003Ccode class=\"language-text\"\u003Enode.master:true\u003C\u002Fcode\u003E로 설정합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E데이터 노드(Data node)\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E데이터(Document)가 저장되는 노드\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E물리적인 공간인 샤드가 배치되는 노드\u003C\u002Fli\u003E\n\u003Cli\u003E색인\u002F검색\u002F통계 등 데이터 작업 수행(리소스가 소모가 심해 모니터링이 필요합니다.)\u003C\u002Fli\u003E\n\u003Cli\u003E마스터와는 분리할 필요가 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003Eelasticsearch.yml\u003C\u002Fcode\u003E의 \u003Ccode class=\"language-text\"\u003Enode.data : true\u003C\u002Fcode\u003E로 설정합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E코디네이팅 노드(Coordinating Node)\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E사용자의 요청을 받고 Round Robin 방식으로 분산시켜주는 노드\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E클러스터에 관련된 것은 마스터노드로, 데이터와 관련된 것은 데이터 노드로 넘깁니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003Eelasticsearch.yml\u003C\u002Fcode\u003E 내부의 노드 종류 관련 옵션을 전부 \u003Ccode class=\"language-text\"\u003Efalse\u003C\u002Fcode\u003E로 설정합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E인제스트 노드(Ingest node) : \u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E문서 전처리 작업을 수행\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E인덱스 생성 전 문서의 형식을 변경할 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003Eelasticsearch.yml\u003C\u002Fcode\u003E의 \u003Ccode class=\"language-text\"\u003Enode.ingest:true\u003C\u002Fcode\u003E로 설정합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"샤드shard\"\u003E\u003Ca href=\"#%EC%83%A4%EB%93%9Cshard\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E샤드(Shard)\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E인덱스 내부에는 색인된 데이터\u003C\u002Fstrong\u003E들이 존재하며, 이 데이터들은 하나로 뭉쳐서 존재하지 않으며 물리적인 공간에 여러개의 부분들로 나눠 존재하는데 이 부분을 샤드라고 합니다.\u003C\u002Fli\u003E\n\u003Cli\u003EElasticsearch는 인덱스를 여러 샤드로 나누어 저장하기 때문에, 콘텐츠 볼륨의 수평 분할\u002F확장이 가능하고 병렬화를 통해 성능 및 처리량을 늘릴 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E샤드는 프라이머리와 레플리카로 구분됩니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003EPrmiary Shard\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E데이터의 원본\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E엘러스틱서치에서 데이터 업데이트 요청을 날리면 반드시 Primary Shard로 요청이 가고, 해당 내용은 Replica로 복제됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E검색 성능 향샹을 위해 클러스터의 샤드 갯수를 조절합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EReplica Shard\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003EPrimary Shard의 복제품\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E기존 원본 데이터가 무너졌을 때, 그 대신 쓰면서 장애 극복 역할은 수행\u003C\u002Fli\u003E\n\u003Cli\u003E기본적으로 Primary Shard와 동일한 노드에 배정되지 않습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"세그먼트segment\"\u003E\u003Ca href=\"#%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8segment\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E세그먼트(Segment)\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E세그먼트는 Elasticsearch에서 문서의 빠른 검색을 위해 설계된 자료구조\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E각 샤드는 다수의 세그먼트로 구성되어 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003EElasticsearch에서 데이터(Document)를 저장하면, 엘라스틱서치는 이것을 메모리에 모아두고 새로운 세그먼트를 디스크에 기록하여 검색을 refresh합니다. 이를 통해 새로운 검색 가능한 세그먼트가 만들어집니다.\u003C\u002Fli\u003E\n\u003Cli\u003E샤드에서 검색 시, 각 세그먼트에서 검색하여 결과를 조합한 후 최종 결과를 해당 샤드의 결과로 리턴합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E세그먼트는 불변의 성질을 가지고 있어서 데이터가 업데이트되면, 삭제되었다는 마크만 하고 새로운 데이터를 가르킵니다. 삭제되었다고 마크된 데이터는 디스크에 남아있다가, 이후에 성능에 영향을 미치지 않는 선에서 삭제됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"elasticsearch의-특징\"\u003E\u003Ca href=\"#elasticsearch%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EElasticsearch의 특징\u003C\u002Fh2\u003E\n\u003Ch3 id=\"분산-확장성-병렬처리\"\u003E\u003Ca href=\"#%EB%B6%84%EC%82%B0-%ED%99%95%EC%9E%A5%EC%84%B1-%EB%B3%91%EB%A0%AC%EC%B2%98%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E분산, 확장성, 병렬처리\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EElasticsearch는 규모가 수평적으로 늘어나도록 설계하기 때문에, 더 많은 용량이 필요하면 그저 노드를 추가해서 클러스터가 인식할 수 있게 하여 추가적인 하드웨어로 이용할 수 있도록 하면 됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E따라서 확장성 등에서 큰 이점을 가집니다. (같은 클러스터 내이고 초기설정이 그대로라면 노드끼리 연결되지만, 다른 클러스터에 있다면 설정을 해줘야합니다.)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"고가용성\"\u003E\u003Ca href=\"#%EA%B3%A0%EA%B0%80%EC%9A%A9%EC%84%B1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E고가용성\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E동작중에 죽은 노드를 감지하고 삭제하며 사용자의 데이터가 안전하고 접근가능하도록 유지합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E동작 중에 일부 노드에 문제가 생기더라도 문제없이 서비스를 제공합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"멀티-태넌시\"\u003E\u003Ca href=\"#%EB%A9%80%ED%8B%B0-%ED%83%9C%EB%84%8C%EC%8B%9C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E멀티 태넌시\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E클러스터는 여러개의 인덱스를 관리할 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E클러스터는 독립된 하나의 쿼리 또는 그룹 쿼리로 여러 인덱스의 데이터를 검색할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"전문full-text-검색\"\u003E\u003Ca href=\"#%EC%A0%84%EB%AC%B8full-text-%EA%B2%80%EC%83%89\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E전문(Full text) 검색\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EElasticsearch는 강력한 전문 검색을 지원합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"문서-중심\"\u003E\u003Ca href=\"#%EB%AC%B8%EC%84%9C-%EC%A4%91%EC%8B%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E문서 중심\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EElasticsearch는 복잡한 요소들을 구조화된 JSON 문서 형식으로 지원합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E모든 필드는 기본적으로 인덱싱되며, 모든 인덱스들은 단일 쿼리로 빠르게 사용할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"schema-free\"\u003E\u003Ca href=\"#schema-free\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESchema free\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EJSON 문서 구조를 통해서 데이터를 인덱싱하고 검색할 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E사용자의 데이터가 어떻게 인덱싱 될 것인지를 커스터마이징할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"restful-api\"\u003E\u003Ca href=\"#restful-api\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERestful api\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003EHTTP를 통한 JSON형식의 간단한 RESTful API를 제공하여 여러 다른 API도 제공합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Eex) Java, JS, Groovy, PHP, Perl, Python, Ruby 등등\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"마무리\"\u003E\u003Ca href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E마무리.\u003C\u002Fh2\u003E\n\u003Cp\u003E간단하게 내용적으로 Elasticsearch에 대해 정리했습니다. 다음에는 Elasticsearch를 직접 구현해보고, 또한 Kibana와 Logstatsh 등 ELK 스택에 대한 내용을 보충하여 정리하였습니다.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Ftwofootdog.tistory.com\u002F53\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Ftwofootdog.tistory.com\u002F53\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.elastic.co\u002Fkr\u002Fwhat-is\u002Felasticsearch\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fwww.elastic.co\u002Fkr\u002Fwhat-is\u002Felasticsearch\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvictorydntmd.tistory.com\u002F308\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fvictorydntmd.tistory.com\u002F308\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fblog.naver.com\u002Farchinitus\u002F80205377502\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fblog.naver.com\u002Farchinitus\u002F80205377502\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvelog.io\u002F@lsmin0703\u002FElasticSearch-1-%EA%B0%9C%EB%85%90\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fvelog.io\u002F@lsmin0703\u002FElasticSearch-1-%EA%B0%9C%EB%85%90\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvictorydntmd.tistory.com\u002F308\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fvictorydntmd.tistory.com\u002F308\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}}]}}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.bdd1e6a6.js" defer></script><script src="/assets/js/page--src--templates--tag-vue.762abdba.js" defer></script>
  </body>
</html>