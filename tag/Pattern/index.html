<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Hello, world! - Azderica</title><meta name="gridsome:hash" content="285ff1728489f5941cbff8d9d80ca9ef32b474be"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="부족하지만 꿈많은 웹 개발자의 발전 기록입니다."><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.d0be325ebfe2762f973f3e0685345394.png"><link rel="preload" href="/assets/css/0.styles.6978a34f.css" as="style"><link rel="preload" href="/assets/js/app.0b2f08f3.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--tag-vue.762abdba.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.b6200640.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.2e7dccb5.js"><link rel="prefetch" href="/assets/js/page--src--templates--post-vue.b162c3b2.js"><link rel="stylesheet" href="/assets/css/0.styles.6978a34f.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <script data-ad-client="ca-pub-1759762070891290" async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="google-site-verification" content="MqpGCz7XVg4s3AWfrGHCt6AlXPacpV9iGvSFVD0ATHw" />
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      (function() {
        window.__onThemeChange = function() {};
        function setTheme(newTheme) {
          window.__theme = newTheme;
          preferredTheme = newTheme;
          document.body.setAttribute('data-theme', newTheme);
          window.__onThemeChange(newTheme);
        }

        var preferredTheme;
        try {
          preferredTheme = localStorage.getItem('theme');
        } catch (err) { }

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme);
          try {
            localStorage.setItem('theme', newTheme);
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)');
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        });

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'));
      })();
    </script>

    <div id="app" data-server-rendered="true"><header class="header"><div class="header__left"><a href="/" class="logo active"><span class="logo__text">
    ← Azderica
  </span></a></div><div class="header__right"><button role="button" aria-label="Toggle dark/light" class="toggle-theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></header><main class="main"><h1 class="tag-title text-center space-bottom">
    # Pattern
  </h1><div class="posts"><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[DesignPattern] 사이드카 패턴이란</h2><p class="post-card__description">사이드카 패턴에 대해 정리합니다.</p><div class="post-meta post-card__meta">
   Posted 21. February 2021.
   <strong>4 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/00-design-pattern-sidecar/" class="post-card__link">Link</a></div></div><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[Architecture] SOA 패턴이란</h2><p class="post-card__description"> SOA 패턴에 대해 정리합니다.</p><div class="post-meta post-card__meta">
   Posted 1. January 2021.
   <strong>6 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/01-architecture-soa/" class="post-card__link">Link</a></div></div><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[Architecture] MSA : CQRS 패턴이란</h2><p class="post-card__description"> CQRS 패턴에 대해 정리합니다.</p><div class="post-meta post-card__meta">
   Posted 23. December 2020.
   <strong>7 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/02-architecture-msa/" class="post-card__link">Link</a></div></div><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[Architecture] MSA : SAGA 패턴이란</h2><p class="post-card__description"> SAGA 패턴에 대해 정리합니다.</p><div class="post-meta post-card__meta">
   Posted 22. December 2020.
   <strong>7 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/01-architecture-msa/" class="post-card__link">Link</a></div></div></div></main><footer class="footer"><span class="footer__copyright">Copyright © 2021.
    </span><span class="footer__links">Powered by <a href="//gridsome.org"> Gridsome </a></span></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"tag":{"title":"Pattern","belongsTo":{"edges":[{"node":{"title":"[DesignPattern] 사이드카 패턴이란","path":"\u002F00-design-pattern-sidecar\u002F","date":"21. February 2021","timeToRead":4,"description":"사이드카 패턴에 대해 정리합니다.","content":"\u003Ch1 id=\"sidecar-pattern\"\u003E\u003Ca href=\"#sidecar-pattern\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESidecar Pattern\u003C\u002Fh1\u003E\n\u003Ch2 id=\"sidecar-pattern이란\"\u003E\u003Ca href=\"#sidecar-pattern%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESidecar Pattern이란\u003C\u002Fh2\u003E\n\u003Cp\u003E사이드카 패컨은 \u003Cstrong\u003E어플리케이션 컨테이너와 독립적으로 동작하는 별도의 컨테이너를 붙이는 패턴\u003C\u002Fstrong\u003E입니다. 어플리케이션 컨테이너의 변경이나 수정없이 독립적으로 동작하는 컨테이너를 붙였다 뗐다할 수 있습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F108616441-bb173c80-7450-11eb-9cde-4820ad6f2117.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E이 패턴은 오토바이에 연결된 사이드카와 유사하기 때문에 사이드카라고 이야기를 합니다. 사이드카 패넡은 상위 애플리케이션에 대해 지원 기능을 제공합니다. 또한 사이드카는 상위 애플리케이션과 동일한 수명 주기를 공유하므로 상위 애플리케이션과 함께 만들어지고 사용 중지됩니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F108616806-4f36d300-7454-11eb-8d58-ceadd4f438ac.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E일반적으로 사이드카 패턴은 다음과 같이 구성됩니다. 사이드카 서비스는 어플리케이션의 일부일 필요는 없으며 애플리케이션에 연결되어 있습니다. 사이드카는 기본 어플리케이션을 사용해서 배포되는 프로세스 또는 서비스를 지원합니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"장단점\"\u003E\u003Ca href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E장단점\u003C\u002Fh2\u003E\n\u003Ch3 id=\"장점\"\u003E\u003Ca href=\"#%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E장점\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E상호 의존성을 줄일 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E사이드카 장애 시 애플리케이션이 영향을 받지않습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E사이드카 적용\u002F변경\u002F제거 등의 경우에 애플리케이션은 수정이 필요가 없습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E애플리케이션과 사이드카를 다른 언어로 만들 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E대부분 같은 스토리지를 공유할 수 있기 때문에 공유에 대한 고민이 적습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"단점\"\u003E\u003Ca href=\"#%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E단점\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E어플리케이션이 너무 작은 경우, 배보다 배꼽이 커질 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E프로세스간 통신이 너무 많고 최적화해야한다면ㅋ 어플리케이션에서 함께 처리하는 것이 좋습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"예시\"\u003E\u003Ca href=\"#%EC%98%88%EC%8B%9C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E예시\u003C\u002Fh2\u003E\n\u003Cp\u003E다음의 경우에 사용할 수 있습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EInfra API, 인프라 개발 팀은 인프라에 액세스할 언어별 클라이언트 라이브러리 대신 각 애플리케이션과 함께 배포되는 서비스를 만듭니다. 서비스는 사이드카로 로드되고 로깅, 환경 데이터, 저장소, 검색, 상태 검사 등의 서비스를 비롯한 인프라 서비스에 대한 공통 계층을 제공합니다. 또한 사이드카는 상위 어플리케이션의 호스트 환경 및 프로세스를 모니터링하고 중앙 집중식 서비스에 정보를 기록합니다.\u003C\u002Fli\u003E\n\u003Cli\u003ENGINX\u002FHAProxy 관리합니다. 환경 상태를 모니터링한 다음 NGINX 구성 파일을 업데이트하고 상태 변경이 필요한 경우 프로세스를 재활용하는 사이드카 서비스를 사용해서 NGINX를 배포합니다.\u003C\u002Fli\u003E\n\u003Cli\u003EOffload Proxy, 서비스에 대한 사용중인 정적 파일 콘텐츠를 처리하도록 NGINX 프록시를 node.js 서비스 인스턴스 앞에 배치합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.microsoft.com\u002Fko-kr\u002Fazure\u002Farchitecture\u002Fpatterns\u002Fsidecar\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fdocs.microsoft.com\u002Fko-kr\u002Fazure\u002Farchitecture\u002Fpatterns\u002Fsidecar\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fblog.leocat.kr\u002Fnotes\u002F2019\u002F02\u002F16\u002Fcloud-sidecar-pattern\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fblog.leocat.kr\u002Fnotes\u002F2019\u002F02\u002F16\u002Fcloud-sidecar-pattern\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fblog.davemdavis.net\u002F2018\u002F03\u002F13\u002Fthe-sidecar-pattern\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fblog.davemdavis.net\u002F2018\u002F03\u002F13\u002Fthe-sidecar-pattern\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}},{"node":{"title":"[Architecture] SOA 패턴이란","path":"\u002F01-architecture-soa\u002F","date":"1. January 2021","timeToRead":6,"description":" SOA 패턴에 대해 정리합니다.","content":"\u003Ch1 id=\"soa-패턴을-알아보자\"\u003E\u003Ca href=\"#soa-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESOA 패턴을 알아보자.\u003C\u002Fh1\u003E\n\u003Cp\u003E대용량의 분산 시스템에서 SOA라는 개념에 대해 많이 듣습니다. 서버사이드의 근간이 되는 SOA(Service Oriented Architecture)에 대해 알아보겠습니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"soa이란\"\u003E\u003Ca href=\"#soa%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESOA이란?\u003C\u002Fh2\u003E\n\u003Cp\u003ESOA란 Service Oriented Architecture의 약자로서, 이를 해석하면 서비스 지향 아키텍쳐를 의미합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E기존의 애플리케이션의 기능들을 \u003Cstrong\u003E비지니스적인 의미를 가지는 기능 단위\u003C\u002Fstrong\u003E로 묶어서 표준화된 호출 인터페이스를 통해 서비스로 구현하고, 이 서비스들을 기업의 업무에 따라 어플리케이션을 구성하는 소프트웨어 개발 아키텍처를 의미합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F103477346-5f8de280-4e01-11eb-9500-25672abe187f.png\" alt=\"SoaModel\"\u003E\n: \u003Ca href=\"https:\u002F\u002Fsongii00.github.io\u002F2019\u002F11\u002F17\u002F2019-11-17-CleanArchitecture%20Item%2027\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fsongii00.github.io\u002F2019\u002F11\u002F17\u002F2019-11-17-CleanArchitecture%20Item%2027\u002F\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"왜-soa가-주목-받나요\"\u003E\u003Ca href=\"#%EC%99%9C-soa%EA%B0%80-%EC%A3%BC%EB%AA%A9-%EB%B0%9B%EB%82%98%EC%9A%94\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E왜 SOA가 주목 받나요?\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E웹 서비스의 등장으로 인해 다양한 기술적 복합도를 낮출 수 있게되어, 기술적인 대안이 등장하였습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E점점 확장되는 독립된 업무 시스템으로 인해 통합에 대한 필요가 생겼습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E기업의 비지니스 속도가 빨라져서 민첩한 대응이 필요해졌습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"soa의-기본적인-개념\"\u003E\u003Ca href=\"#soa%EC%9D%98-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESOA의 기본적인 개념\u003C\u002Fh2\u003E\n\u003Ch3 id=\"서비스란\"\u003E\u003Ca href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4%EB%9E%80\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E서비스란?\u003C\u002Fh3\u003E\n\u003Cp\u003E서비스란 플랫폼에 종속되지 않는 표준 인터페이스를 통해 비지니스적인 의미를 가지는 기능들을 모아놓은 \u003Cstrong\u003E소프트웨어 컴포넌트\u003C\u002Fstrong\u003E를 의미합니다.\u003C\u002Fp\u003E\n\u003Cp\u003Eex. 임직원 정보 서비스, 계좌이체 서비스, 상품 주문 서비스\u003C\u002Fp\u003E\n\u003Cp\u003E일반적으로 SOA에서 정의하는 서비스는 \u003Cstrong\u003E비지니스 서비스\u003C\u002Fstrong\u003E를 의미합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E그 외의 서비스로는 Intermediary 서비스나 Process Centrix 서비스, Application 서비스, Public Enterprise 서비스 등이 있습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F103477324-1e95ce00-4e01-11eb-8332-46a5dd17f6fb.png\" alt=\"ServiceImage\"\u003E\n: \u003Ca href=\"https:\u002F\u002Fwww.slideshare.net\u002FByungwook\u002Fsoa-61487404\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fwww.slideshare.net\u002FByungwook\u002Fsoa-61487404\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"soa의-단계적-발전-구조\"\u003E\u003Ca href=\"#soa%EC%9D%98-%EB%8B%A8%EA%B3%84%EC%A0%81-%EB%B0%9C%EC%A0%84-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESOA의 단계적 발전 구조.\u003C\u002Fh2\u003E\n\u003Cp\u003ESOA는 시스템의 규모와 업무적 요구 사항에 따라 3단계 순서로 발전됩니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"fundamental-soa\"\u003E\u003Ca href=\"#fundamental-soa\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EFundamental SOA\u003C\u002Fh3\u003E\n\u003Cp\u003E기존 시스템들을 서비스화하여, 각 시스템들을 통합하는 단계입니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E서비스화와 통합이 중점 전체를 한 시스템화합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E서비스에 대한 조합은, Front End에서 담당합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E비지니스 서비스와 Application서비스로만 구성됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F103477424-230eb680-4e02-11eb-96d1-3d5efa11bd40.png\" alt=\"FundamentalSOA\"\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"networked-soa\"\u003E\u003Ca href=\"#networked-soa\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ENetworked SOA\u003C\u002Fh3\u003E\n\u003Cp\u003EFundamental SOA의 문제점\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E시스템의 크기가 증가됨에 따라 서비스와 Front-End 사이에 연결이 복잡해집니다.\u003C\u002Fli\u003E\n\u003Cli\u003E시스템의 유연성이 떨어집니다.\u003C\u002Fli\u003E\n\u003Cli\u003E관리 및 중앙 통제가 어렵습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E이러한 단점을 해결하기 위해 Networked SOA는 아래의 특징을 가지고 있습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ESOA 시스템의 가운데 서비스 허브를 둬서 서비스의 중앙 통제력 및 유연성을 강화합니다.\u003C\u002Fli\u003E\n\u003Cli\u003EIntermediary 서비스가 ESB(라우팅, 변환, 로깅, 서비스 통제 등)에 위치합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F103477468-8d275b80-4e02-11eb-9fc0-d2a37057ac5b.png\" alt=\"NetworkedSOA\"\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"process-oriented-soa\"\u003E\u003Ca href=\"#process-oriented-soa\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EProcess Oriented SOA\u003C\u002Fh3\u003E\n\u003Cp\u003E기존에 Networked SOA에서 발전한 단계입니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E비지니스 플로우(Business Flow)가 있을 경우에만 적용됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E서비스의 조합을 통한 업무의 구현을 BPM을 이용합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E업무 변화에 민첩하게 반응합니다,. (Agile 가능)\u003C\u002Fli\u003E\n\u003Cli\u003E기술조직과 비지니스 조직간의 의사 소통이 원할합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"다른-아키텍처와-비교\"\u003E\u003Ca href=\"#%EB%8B%A4%EB%A5%B8-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%99%80-%EB%B9%84%EA%B5%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E다른 아키텍처와 비교\u003C\u002Fh2\u003E\n\u003Ch3 id=\"monolithic-보다-나은점\"\u003E\u003Ca href=\"#monolithic-%EB%B3%B4%EB%8B%A4-%EB%82%98%EC%9D%80%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMonolithic 보다 나은점\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E출시 일정 단축 및 유연성이 향상됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E신규 시장에서 레거시 인프라를 활용가능합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E더 효율적인 애자일 개발 방식으로 비용을 아낄 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E손쉽게 유지관리합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E확정성을 가지고 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E안정성이 강화됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E편리한 이용이 가능합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"msa와-비교\"\u003E\u003Ca href=\"#msa%EC%99%80-%EB%B9%84%EA%B5%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMSA와 비교\u003C\u002Fh3\u003E\n\u003Cp\u003EMSA와 SOA는 유사한 개념 때문에 혼동하기 쉽습니다. 다만 둘의 \u003Cstrong\u003E근본적인 차이점은 범위\u003C\u002Fstrong\u003E입니다. \u003Cstrong\u003ESOA는 전사적인 아키텍처 접근 방식이며, MSA는 어플리케이션 개발 팀 내의 구현 전략\u003C\u002Fstrong\u003E입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E또한 각각의 구성 요소와 통신하는 방법에서 차이가 있습니다. \u003Cstrong\u003ESOA는 ESB를 사용\u003C\u002Fstrong\u003E하는 반면에 \u003Cstrong\u003E마이크로서비스끼리는 언어의 제약이 없는 API\u003C\u002Fstrong\u003E를 통해 stateless 방식으로 통신합니다. 마이크로서비스의 API에는 언어의 제약이 없기 때문에 개발팀에서 사용하고 싶은 툴을 선택할 수 있습니다. 따라서, 마이크로서비스의 내결합성과 유연성이 더 유연합니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"마무리\"\u003E\u003Ca href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E마무리.\u003C\u002Fh2\u003E\n\u003Cp\u003E오늘은 간단하게 SOA개념에 대해 정리해보았습니다. MSA와 혼란스러운 부분이 있었으나 큰 차이를 이해할 수 있었습니다. 해당 게시글의 잘못된 부분을 알려주시면 감사합니다.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fsarc.io\u002Findex.php\u002Fmiscellaneous\u002F742-soa-service-oriented-architecture\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fsarc.io\u002Findex.php\u002Fmiscellaneous\u002F742-soa-service-oriented-architecture\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.slideshare.net\u002FByungwook\u002Fsoa-61487404\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fwww.slideshare.net\u002FByungwook\u002Fsoa-61487404\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.redhat.com\u002Fko\u002Ftopics\u002Fcloud-native-apps\u002Fwhat-is-service-oriented-architecture\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fwww.redhat.com\u002Fko\u002Ftopics\u002Fcloud-native-apps\u002Fwhat-is-service-oriented-architecture\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}},{"node":{"title":"[Architecture] MSA : CQRS 패턴이란","path":"\u002F02-architecture-msa\u002F","date":"23. December 2020","timeToRead":7,"description":" CQRS 패턴에 대해 정리합니다.","content":"\u003Ch1 id=\"msa--cqrs-패턴의-정의과-종류\"\u003E\u003Ca href=\"#msa--cqrs-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A0%95%EC%9D%98%EA%B3%BC-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMSA : CQRS 패턴의 정의과 종류\u003C\u002Fh1\u003E\n\u003Cp\u003E지난 시간에는 MSA와 MSA 패턴 중, SAGA 패턴에 대해 알아보았습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"Azderica.github.io\u002F00-architecture-msa\u002F\"\u003EMSA 개념 잡기\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"Azderica.github.io\u002F01-architecture-msa\u002F\"\u003EMSA : SAGA 패턴\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"cqrs-패턴이란\"\u003E\u003Ca href=\"#cqrs-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECQRS 패턴이란.\u003C\u002Fh2\u003E\n\u003Cp\u003ECQRS 패턴이란 Command and Query Responsibility Segregation의 약자입니다. 이를 해석하면 \u003Cstrong\u003E명령과 쿼리의 역할을 구분\u003C\u002Fstrong\u003E한다는 것입니다. 즉, Command (\u003Cstrong\u003EC\u003C\u002Fstrong\u003Ereate, Insert, \u003Cstrong\u003EU\u003C\u002Fstrong\u003Epdate, \u003Cstrong\u003ED\u003C\u002Fstrong\u003Eelete)와 쿼리(Select - \u003Cstrong\u003ER\u003C\u002Fstrong\u003Eead)의 책임을 분리하는 의미를 가집니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"cqrs가-왜-필요한가요\"\u003E\u003Ca href=\"#cqrs%EA%B0%80-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80%EC%9A%94\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECQRS가 왜 필요한가요?\u003C\u002Fh2\u003E\n\u003Cp\u003E전통적인 CRUD 아키텍처 기반에서 Application을 개발 및 운영하다가 보면, 자연스럽게 \u003Cstrong\u003EDomain Model의 복잡도가 증가하고 그에 따라 유지보수의 비용이 증가하고 Domain model은 설계의 방향과 다르게 변질\u003C\u002Fstrong\u003E됩니다. 특히 요즘처럼 고급화된 UX, 어려워진 Business, 자주 변하는 요구사항에서 이러한 Model을 설계하는 것은 어려워졌습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이러한 흐름에서 확인해보니, 대부분의 정책이나 제약은 데이터 변경(C, U, D)에서 처리되고, 데이터 조회(R) 작업은 단순 데이터 조회인데, 동일 Domain Model로 처리하면 필요하지 않은 Domain 속성들로 인해 \u003Cstrong\u003E복잡도가 증가\u003C\u002Fstrong\u003E합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E따라서 이 문제를 해결하기위해서 \u003Cstrong\u003E명령을 처리하는 책임\u003C\u002Fstrong\u003E과 \u003Cstrong\u003E조회를 처리하는 책임\u003C\u002Fstrong\u003E을 \u003Cstrong\u003E분리\u003C\u002Fstrong\u003E하는 해법을 찾았고 이 방법이 CQRS입니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"cqrs의-종류\"\u003E\u003Ca href=\"#cqrs%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECQRS의 종류\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E전통적인 CRUD 시스템.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F103001594-b0cfe380-4570-11eb-8166-ab5f026e534a.png\" alt=\"original-crud\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E기존의 전통적인 CRUD 시스템은 다음 그림과 같은 계층 구조를 지니고 있습니다. 이에 CQRS 패턴을 적용하기 위한 방법으로 크게 최소 \u003Cstrong\u003E3가지 방법\u003C\u002Fstrong\u003E이 있습니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"1-simple-cqrs-architecture\"\u003E\u003Ca href=\"#1-simple-cqrs-architecture\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. Simple CQRS architecture\u003C\u002Fh3\u003E\n\u003Cp\u003E이는 단일 Data Store에 Command Query Model을 분리된 계층으로 나누는 방식입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F103002233-df9a8980-4571-11eb-9156-a6d3675bc07b.png\" alt=\"Simple CQRS architecture\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E해당 그림처럼 Database(RDBMS)는 분리하지 않고 \u003Cstrong\u003E기존 구조를 유지하고 Model Layer 부분과 Command와 Query Model로 분리\u003C\u002Fstrong\u003E하는 수준으로 간단하게 적용할 수 있습니다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"장점\"\u003E\u003Ca href=\"#%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E장점.\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E훨씬 단순하게 구현 및 적용할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"단점\"\u003E\u003Ca href=\"#%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E단점.\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E동일한 Database 사용에 따른 성능상 문제점은 개선하지 못합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"2-cqrs-with-separated-persistance-mechanisms\"\u003E\u003Ca href=\"#2-cqrs-with-separated-persistance-mechanisms\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2. CQRS with separated persistance mechanisms\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F103002567-79facd00-4572-11eb-8d8a-723176ff0e35.png\" alt=\"CQRS with separated persistance mechanisms\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E해당 방법은 Command용 Database와 Query용 Database를 분리하고 별도의 Broker를 통해서 이 둘간의 Data를 동기화 처리하는 방식입니다. 이 경우에는 데이터를 조회하려는 서비스들은 서비스에 맞는 저장소를 선택할 수 있기 때문에 polyglot 구조로 구성할 수도 있습니다. 이 경우에는 각각의 Model에 맞게 저장소(RDBMS, NOSQL, Cache)를 튜닝해서 사용할 수 있습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003Epolyglot\u003C\u002Fstrong\u003E 이란? 다수의 Database를 혼용하여 사용하는 것입니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"장점-1\"\u003E\u003Ca href=\"#%EC%9E%A5%EC%A0%90-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E장점\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003ESimple CQRS 에서 거론되는 Database 사용에 발생하는 성능 관점의 문제를 해결할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"단점-1\"\u003E\u003Ca href=\"#%EB%8B%A8%EC%A0%90-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E단점\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E동기화 처리를 위한 Broker의 가용성과 신뢰도가 보장이 되어야합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"3-eventsouring-model\"\u003E\u003Ca href=\"#3-eventsouring-model\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. EventSouring Model\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F103003262-ceeb1300-4573-11eb-8591-f4ceb1a7312e.png\" alt=\"EventSouring Model\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E해당 방법은 이벤트 소싱(Event Sourcing)을 적용한 구조입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E이벤트 소싱\u003C\u002Fstrong\u003E이란 \u003Cstrong\u003EApplication 내의 모든 Activity를 이벤트로 전환해서 이벤트 스트림(Event Stream)을 별도의 Database에 저장하는 방식\u003C\u002Fstrong\u003E을 의미합니다. EvensSourcing Model이란 이벤트 스트림을 저장하는 Database에는 오직 데이터 추가만 가능하고 계속적으로 쌓이는 데이터를 구체화시키는 시점에서 그때까지 구축된 데이터를 바탕으로 조회 대상 데이터를 작성하는 방법을 의미합니다. 즉, Application 내의 상태 변경을 이력으로 관리하는 패턴의 발전된 형태로 이해하면 됩니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이벤트 소싱의 이벤트 스트림은 오직 추가만 가능하고, 필요로 하는 시점에 구체화 단계를 가지게 되고 이 처리과정이 CQRS의 모델 분리 관점에서 잘 맞기 때문에 주로 선택한다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003ECQRS 패턴에 이벤트 소싱은 필수가 아니지만 이벤트 소싱에는 CQRS가 필요합니다.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"cqrs의-이점\"\u003E\u003Ca href=\"#cqrs%EC%9D%98-%EC%9D%B4%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECQRS의 이점.\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E독립적인 크기 조정\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ECQRS를 통해 읽기 및 쓰기의 워크로드를 독립적으로 확장할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E최적화된 데이터 스키마\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E읽기 쪽에서는 쿼리에 최적화된 슼니마를 사용하고 쓰기에서는 업데이트에 최적화된 스키마를 사용할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E보안\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E올바른 도메인 엔터티만 데이터에 쓰기를 수행할 수 있는지 쉽게 확인 가능합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E유연한 모델 생성\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E대부분의 복잡한 비즈니스 논리는 쓰기 모델로 이동시키고 읽기모델은 상대적으로 간단하게 정리하여 유지가능하고 유연한 모델을 만들 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E단순한 쿼리\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E읽기 데이터베이스에서 구체화된 뷰를 저장하여 쿼리 시 복잡한 조인을 방지할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"마무리\"\u003E\u003Ca href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E마무리.\u003C\u002Fh2\u003E\n\u003Cp\u003E이전의 게시글과 오늘 게시글을 통해서 \u003Cstrong\u003ECQRS 패턴은 Database의 성능을 올리기 위해서 적용된 패턴\u003C\u002Fstrong\u003E이고 \u003Cstrong\u003ESAGA 패턴은 MSA환경에서의 데이터 일관성을 유지하기 위해 제안된 방법\u003C\u002Fstrong\u003E으로 이해하였습니다.\u003C\u002Fp\u003E\n\u003Cp\u003EMSA에 대해 좀 더 공부해야하는 부분이나, 추가적으로 공부를 해야하는 부분이 있다면 다시 정리해보겠습니다. 회사 업무에서는 MSA 구조를 사용하는 일은 아직 없지만, 혹시라도 이후에 적용하게 되었을 때를 대비학는 의미 + 개인적인 호기심으로 글을 정리했습니다.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.popit.kr\u002Fcqrs-eventsourcing\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fwww.popit.kr\u002Fcqrs-eventsourcing\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.microsoft.com\u002Fko-kr\u002Fazure\u002Farchitecture\u002Fpatterns\u002Fcqrs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fdocs.microsoft.com\u002Fko-kr\u002Fazure\u002Farchitecture\u002Fpatterns\u002Fcqrs\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fengineering-skcc.github.io\u002Fmicroservice%20outer%20achitecture\u002Finner-architecture-cqrs\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fengineering-skcc.github.io\u002Fmicroservice%20outer%20achitecture\u002Finner-architecture-cqrs\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fcode-masterjung.tistory.com\u002F80\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fcode-masterjung.tistory.com\u002F80\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}},{"node":{"title":"[Architecture] MSA : SAGA 패턴이란","path":"\u002F01-architecture-msa\u002F","date":"22. December 2020","timeToRead":7,"description":" SAGA 패턴에 대해 정리합니다.","content":"\u003Ch1 id=\"msa--saga-패턴의-정의과-종류\"\u003E\u003Ca href=\"#msa--saga-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A0%95%EC%9D%98%EA%B3%BC-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMSA : SAGA 패턴의 정의과 종류\u003C\u002Fh1\u003E\n\u003Cp\u003E이전에 MSA 개념에 대해 잡아보았습니다. 오늘은 MSA를 듣다보면 꼭 듣게 되는 SAGA 패턴에 대해 공부해보겠습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002FAzderica.github.io\u002F00-architecture-msa\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EMSA 개념 잡기\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"들어가기-앞서서\"\u003E\u003Ca href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%95%9E%EC%84%9C%EC%84%9C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E들어가기 앞서서.\u003C\u002Fh2\u003E\n\u003Cp\u003E기존의 Monolithic와 MSA 아키텍처에 대해서는 이전 게시글에서 정리했습니다. 오늘은 좀 더 MSA에 대해 이야기할려고 합니다. MSA 아키텍처를 구성하기 어려운 이유 중 하나는 \u003Cstrong\u003E트랜적션\u003C\u002Fstrong\u003E 의 문제입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E기존의 Monolithic 환경에서는 DBMS가 기본적으로 제공해주는 트랜잭선 기능을 통해서 데이터 commit이나 rollback을 통해서 일관성있게 관리하였습니다. 그러나 Applcation 과 DB가 분산되면서 해당 트랜잭션 처리를 단일 DBMS에서 제공하는 기능으로는 해결할 수 없습니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"대안--two-phase-commit\"\u003E\u003Ca href=\"#%EB%8C%80%EC%95%88--two-phase-commit\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E대안 : Two-Phase Commit?\u003C\u002Fh3\u003E\n\u003Cp\u003E여러 서비스 간에 데이터 일관성을 유지하기 위해서 전통적인 방법인 Two-Phase commit 과 같은 방법을 사용했습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102893652-4f8f0e00-44a5-11eb-9f1a-f4d3508e6c97.png\" alt=\"two-phase commit\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E다만 이 방법은 하나의 서비스가 장애가 있는 경우나 각각의 서비스에 동시에 Rocking이 걸리게 되면 성능의 문제가 발생하기 때문에 비효율적입니다. 더나아가 각각의 서비스가 다른 instance에 있기 때문에 이를 통제하는데 어려움이 있습니다.\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E트랜잭션이란?\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E트랜잭션이란 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위를 의미합니다. 트랜잭션은 4가지의 특성(원자성, 일관성, 독립성, 지속성)을 지켜야합니다. 이에 대해 상세하게 다루기에는 주제에 너무 벗어난 주제이기 때문에 다른 게시글로 정리하겠습니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"saga-패턴의-정의\"\u003E\u003Ca href=\"#saga-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESAGA 패턴의 정의\u003C\u002Fh2\u003E\n\u003Cp\u003E위의 문제를 해결하기 위해서 SAGA 패턴이 등장했습니다.\u003C\u002Fp\u003E\n\u003Cp\u003ESAGA 패턴이란 \u003Cstrong\u003E마이크로서비스들끼리 이벤트를 주고 받아 특정 마이크로서비스에서의 작업이 실패하면 이전까지의 작업이 완료된 마이크서비스들에게 보상 (complemetary) 이벤트를 소싱함으로써 분산 환경에서 원자성(atomicity)을 보장\u003C\u002Fstrong\u003E하는 패턴입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이를 그림으로 표현하면 다음과 같습니다. SAGA 패턴의 이벤트 성공 시는 다음과 같이 동작합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102894284-33d83780-44a6-11eb-9cb0-1c526edd5642.png\" alt=\"saga-pattern-success\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ESAGA 패턴의 이벤트 실패 시는 다음과 같이 실패 이벤트를 주어 처리합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102894291-35a1fb00-44a6-11eb-93bf-2371f322c99c.png\" alt=\"saga-pattern-fail\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E해당 SAGA 패턴의 핵심은 \u003Cstrong\u003E트랜잭션의 관리주체가 DBMS에 있는 것이 아닌 Application\u003C\u002Fstrong\u003E에 있습니다. Application이 분산되어 있을때는 각 Applicatin은 하위에 존재하는 DB는 local 트랜잭션만 담당합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E즉, 각각의 Application의 트랜잭션 요청의 실패로 인한 Rollback 처리(보상 트랜잭션)은 Application에서 구현합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이러한 과정을 통해서 순차적으로 트랜잭션이 처리되며, 마지막 트랜잭션이 끝났을 때 데이터가 완전히 영속되었음을 확인하고 종료합니다. 이 방법을 통해서 최종 일관성(Eventually Consistency)를 달성할 수 있습니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"saga-패턴의-종류\"\u003E\u003Ca href=\"#saga-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESAGA 패턴의 종류\u003C\u002Fh2\u003E\n\u003Cp\u003E일반적으로 SAGA 패턴은 크게 2가지로 나누어집니다. 하나는 \u003Cstrong\u003EChoreography based SAGA pattern\u003C\u002Fstrong\u003E이고 다른 하나는 \u003Cstrong\u003EOrchestration based SAGA pattern\u003C\u002Fstrong\u003E입니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"choreography-based-saga-pattern\"\u003E\u003Ca href=\"#choreography-based-saga-pattern\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EChoreography based SAGA pattern\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102895303-ccbb8280-44a7-11eb-8b80-8b87630db5f5.png\" alt=\"Choreography-Based Saga Success\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EChoreography-based Saga 패턴은 보유한 서비스 내의 Local 트랜잭션을 관리하며 트랜잭션이 종료하게 되면 완료 Event를 발행합니다. 만약 그 다음 수행해야할 트랜잭션이 있으면 해당 트랜잭션을 수행해야하는 App으로 이벤트를 보내고, 해당 App은 완료 Event를 수신받고 다음 작업을 진행합니다. 이를 순차적으로 수행합니다. 이때 Event는 Kafka와 같은 메시지 큐를 통해서 비동기 방식으로 전달할 수 있습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102895310-cf1ddc80-44a7-11eb-9941-de72656dd3a8.png\" alt=\"Choreography-Based Saga Fail\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EChoreography-base Saga 패턴에서는 각 App별로 트랜잭션을 관리하는 로직이 있습니다. 이를 통해서 중간에 트랜잭션이 실패하면 해당 트랜잭션 취소 처리를 실패한 App에서 보상 Event를 발행해서 Rollback 처리를 시도합니다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"장점\"\u003E\u003Ca href=\"#%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E장점\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E구성하기 편합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"단점\"\u003E\u003Ca href=\"#%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E단점\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E운영자 입장에서 트랜잭션의 현재 상태를 확인하기 어렵습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"orchestration-based-saga-pattern\"\u003E\u003Ca href=\"#orchestration-based-saga-pattern\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EOrchestration based SAGA pattern\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102895290-c927fb80-44a7-11eb-88ee-8f08ec4b2c21.png\" alt=\"Orchestration-Based Saga Success\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EOrchestration-Based Saga 패턴은 트랜잭션 처리를 위해 Saga 인스턴스(Manager)가 별도로 존재합니다. 트랜잭션에 관여하는 모든 App은 Manager에 의해 점진적으로 트랜잭션을 수행하며 결과를 Manager에게 전달하게 되고, 비지니스 로직상 마지막 트랜잭션이 끝나면 Manager를 종료해서 전체 트랜잭션 처리를 종료합니다. 만약 중간에 실패하게 되면 Manager에서 보상 트랜잭션을 발동하여 일관성을 유지합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102895323-d47b2700-44a7-11eb-9bc1-2c46cf517c06.png\" alt=\"Orchestration-Based Saga Fail\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E해당 Orchestration-Based Saga 패턴은 모든 관리를 Manager가 호출하기 때문에 분산트랜잭션의 중앙 집중화가 이루어집니다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"장점-1\"\u003E\u003Ca href=\"#%EC%9E%A5%EC%A0%90-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E장점\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E서비스간의 복잡성이 줄어들어서 구현 및 테스트가 쉬워집니다.\u003C\u002Fli\u003E\n\u003Cli\u003E트랜잭션의 현재 상태를 Manager가 알고 있으므로 롤백을 하기 쉽습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"단점-1\"\u003E\u003Ca href=\"#%EB%8B%A8%EC%A0%90-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E단점\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E관리를 해야하는 Orchestrator 서비스가 추가되어야하기 때문에 인프라 구현이 복잡해집니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"마무리\"\u003E\u003Ca href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E마무리\u003C\u002Fh2\u003E\n\u003Cp\u003EMSA 아키텍처 중 가장 유명한 SAGA 패턴에 대해 알아보았습니다. 다만 항상 SAGA 패턴이 좋다고는 볼 수 없습니다. 비지니스 로직상 트랜잭션 처리가 반드시 필요한 경우에만 사용하는 것이 좋습니다. 그렇지 않으면 여러곳에서 트랜잭션 처리 지옥을 경험할 수 있기 때문에 필요한 곳에서만 사용할 수 있도록 비지니스 로직을 설계하고 사용하는 것이 좋습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E다음 게시글에서는 CQRS 패턴에 대해서 정리해보겠습니다. 감사합니다.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fjjeongil.tistory.com\u002F1100\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fjjeongil.tistory.com\u002F1100\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fcla9.tistory.com\u002F22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fcla9.tistory.com\u002F22\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvelog.io\u002F@dvmflstm\u002FSAGA-pattern%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fvelog.io\u002F@dvmflstm\u002FSAGA-pattern%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fichi.pro\u002Fko\u002Fmaikeulo-seobiseu-akitegcheo-saga-paeteon-ilan-mueos-imyeo-eolmana-jung-yohabnikka-94512583990635\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fichi.pro\u002Fko\u002Fmaikeulo-seobiseu-akitegcheo-saga-paeteon-ilan-mueos-imyeo-eolmana-jung-yohabnikka-94512583990635\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}}]}}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.0b2f08f3.js" defer></script><script src="/assets/js/page--src--templates--tag-vue.762abdba.js" defer></script>
  </body>
</html>