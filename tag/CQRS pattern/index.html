<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Hello, world! - Azderica</title><meta name="gridsome:hash" content="0db5b7b00e6830052e821ce8347a6dcc59b0c652"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="부족하지만 꿈많은 웹 개발자의 발전 기록입니다."><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.d0be325ebfe2762f973f3e0685345394.png"><link rel="preload" href="/assets/css/0.styles.caed6242.css" as="style"><link rel="preload" href="/assets/js/app.4c903e18.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--tag-vue.762abdba.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.b6200640.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.20763e56.js"><link rel="prefetch" href="/assets/js/page--src--templates--post-vue.b162c3b2.js"><link rel="stylesheet" href="/assets/css/0.styles.caed6242.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <script data-ad-client="ca-pub-1759762070891290" async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="google-site-verification" content="MqpGCz7XVg4s3AWfrGHCt6AlXPacpV9iGvSFVD0ATHw" />
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      (function() {
        window.__onThemeChange = function() {};
        function setTheme(newTheme) {
          window.__theme = newTheme;
          preferredTheme = newTheme;
          document.body.setAttribute('data-theme', newTheme);
          window.__onThemeChange(newTheme);
        }

        var preferredTheme;
        try {
          preferredTheme = localStorage.getItem('theme');
        } catch (err) { }

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme);
          try {
            localStorage.setItem('theme', newTheme);
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)');
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        });

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'));
      })();
    </script>

    <div id="app" data-server-rendered="true"><header class="header"><div class="header__left"><a href="/" class="logo active"><span class="logo__text">
    ← Azderica
  </span></a></div><div class="header__right"><button role="button" aria-label="Toggle dark/light" class="toggle-theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></header><main class="main"><h1 class="tag-title text-center space-bottom">
    # CQRS pattern
  </h1><div class="posts"><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[Architecture] MSA : CQRS 패턴이란</h2><p class="post-card__description"> CQRS 패턴에 대해 정리합니다.</p><div class="post-meta post-card__meta">
   Posted 23. December 2020.
   <strong>7 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/02-architecture-msa/" class="post-card__link">Link</a></div></div></div></main><footer class="footer"><span class="footer__copyright">Copyright © 2021.
    </span><span class="footer__links">Powered by <a href="//gridsome.org"> Gridsome </a></span></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"tag":{"title":"CQRS pattern","belongsTo":{"edges":[{"node":{"title":"[Architecture] MSA : CQRS 패턴이란","path":"\u002F02-architecture-msa\u002F","date":"23. December 2020","timeToRead":7,"description":" CQRS 패턴에 대해 정리합니다.","content":"\u003Ch1 id=\"msa--cqrs-패턴의-정의과-종류\"\u003E\u003Ca href=\"#msa--cqrs-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A0%95%EC%9D%98%EA%B3%BC-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMSA : CQRS 패턴의 정의과 종류\u003C\u002Fh1\u003E\n\u003Cp\u003E지난 시간에는 MSA와 MSA 패턴 중, SAGA 패턴에 대해 알아보았습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"Azderica.github.io\u002F00-architecture-msa\u002F\"\u003EMSA 개념 잡기\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"Azderica.github.io\u002F01-architecture-msa\u002F\"\u003EMSA : SAGA 패턴\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"cqrs-패턴이란\"\u003E\u003Ca href=\"#cqrs-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECQRS 패턴이란.\u003C\u002Fh2\u003E\n\u003Cp\u003ECQRS 패턴이란 Command and Query Responsibility Segregation의 약자입니다. 이를 해석하면 \u003Cstrong\u003E명령과 쿼리의 역할을 구분\u003C\u002Fstrong\u003E한다는 것입니다. 즉, Command (\u003Cstrong\u003EC\u003C\u002Fstrong\u003Ereate, Insert, \u003Cstrong\u003EU\u003C\u002Fstrong\u003Epdate, \u003Cstrong\u003ED\u003C\u002Fstrong\u003Eelete)와 쿼리(Select - \u003Cstrong\u003ER\u003C\u002Fstrong\u003Eead)의 책임을 분리하는 의미를 가집니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"cqrs가-왜-필요한가요\"\u003E\u003Ca href=\"#cqrs%EA%B0%80-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80%EC%9A%94\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECQRS가 왜 필요한가요?\u003C\u002Fh2\u003E\n\u003Cp\u003E전통적인 CRUD 아키텍처 기반에서 Application을 개발 및 운영하다가 보면, 자연스럽게 \u003Cstrong\u003EDomain Model의 복잡도가 증가하고 그에 따라 유지보수의 비용이 증가하고 Domain model은 설계의 방향과 다르게 변질\u003C\u002Fstrong\u003E됩니다. 특히 요즘처럼 고급화된 UX, 어려워진 Business, 자주 변하는 요구사항에서 이러한 Model을 설계하는 것은 어려워졌습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이러한 흐름에서 확인해보니, 대부분의 정책이나 제약은 데이터 변경(C, U, D)에서 처리되고, 데이터 조회(R) 작업은 단순 데이터 조회인데, 동일 Domain Model로 처리하면 필요하지 않은 Domain 속성들로 인해 \u003Cstrong\u003E복잡도가 증가\u003C\u002Fstrong\u003E합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E따라서 이 문제를 해결하기위해서 \u003Cstrong\u003E명령을 처리하는 책임\u003C\u002Fstrong\u003E과 \u003Cstrong\u003E조회를 처리하는 책임\u003C\u002Fstrong\u003E을 \u003Cstrong\u003E분리\u003C\u002Fstrong\u003E하는 해법을 찾았고 이 방법이 CQRS입니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"cqrs의-종류\"\u003E\u003Ca href=\"#cqrs%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECQRS의 종류\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E전통적인 CRUD 시스템.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F103001594-b0cfe380-4570-11eb-8166-ab5f026e534a.png\" alt=\"original-crud\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E기존의 전통적인 CRUD 시스템은 다음 그림과 같은 계층 구조를 지니고 있습니다. 이에 CQRS 패턴을 적용하기 위한 방법으로 크게 최소 \u003Cstrong\u003E3가지 방법\u003C\u002Fstrong\u003E이 있습니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"1-simple-cqrs-architecture\"\u003E\u003Ca href=\"#1-simple-cqrs-architecture\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. Simple CQRS architecture\u003C\u002Fh3\u003E\n\u003Cp\u003E이는 단일 Data Store에 Command Query Model을 분리된 계층으로 나누는 방식입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F103002233-df9a8980-4571-11eb-9156-a6d3675bc07b.png\" alt=\"Simple CQRS architecture\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E해당 그림처럼 Database(RDBMS)는 분리하지 않고 \u003Cstrong\u003E기존 구조를 유지하고 Model Layer 부분과 Command와 Query Model로 분리\u003C\u002Fstrong\u003E하는 수준으로 간단하게 적용할 수 있습니다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"장점\"\u003E\u003Ca href=\"#%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E장점.\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E훨씬 단순하게 구현 및 적용할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"단점\"\u003E\u003Ca href=\"#%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E단점.\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E동일한 Database 사용에 따른 성능상 문제점은 개선하지 못합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"2-cqrs-with-separated-persistance-mechanisms\"\u003E\u003Ca href=\"#2-cqrs-with-separated-persistance-mechanisms\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2. CQRS with separated persistance mechanisms\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F103002567-79facd00-4572-11eb-8d8a-723176ff0e35.png\" alt=\"CQRS with separated persistance mechanisms\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E해당 방법은 Command용 Database와 Query용 Database를 분리하고 별도의 Broker를 통해서 이 둘간의 Data를 동기화 처리하는 방식입니다. 이 경우에는 데이터를 조회하려는 서비스들은 서비스에 맞는 저장소를 선택할 수 있기 때문에 polyglot 구조로 구성할 수도 있습니다. 이 경우에는 각각의 Model에 맞게 저장소(RDBMS, NOSQL, Cache)를 튜닝해서 사용할 수 있습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003Epolyglot\u003C\u002Fstrong\u003E 이란? 다수의 Database를 혼용하여 사용하는 것입니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"장점-1\"\u003E\u003Ca href=\"#%EC%9E%A5%EC%A0%90-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E장점\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003ESimple CQRS 에서 거론되는 Database 사용에 발생하는 성능 관점의 문제를 해결할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"단점-1\"\u003E\u003Ca href=\"#%EB%8B%A8%EC%A0%90-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E단점\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E동기화 처리를 위한 Broker의 가용성과 신뢰도가 보장이 되어야합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"3-eventsouring-model\"\u003E\u003Ca href=\"#3-eventsouring-model\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. EventSouring Model\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F103003262-ceeb1300-4573-11eb-8591-f4ceb1a7312e.png\" alt=\"EventSouring Model\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E해당 방법은 이벤트 소싱(Event Sourcing)을 적용한 구조입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E이벤트 소싱\u003C\u002Fstrong\u003E이란 \u003Cstrong\u003EApplication 내의 모든 Activity를 이벤트로 전환해서 이벤트 스트림(Event Stream)을 별도의 Database에 저장하는 방식\u003C\u002Fstrong\u003E을 의미합니다. EvensSourcing Model이란 이벤트 스트림을 저장하는 Database에는 오직 데이터 추가만 가능하고 계속적으로 쌓이는 데이터를 구체화시키는 시점에서 그때까지 구축된 데이터를 바탕으로 조회 대상 데이터를 작성하는 방법을 의미합니다. 즉, Application 내의 상태 변경을 이력으로 관리하는 패턴의 발전된 형태로 이해하면 됩니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이벤트 소싱의 이벤트 스트림은 오직 추가만 가능하고, 필요로 하는 시점에 구체화 단계를 가지게 되고 이 처리과정이 CQRS의 모델 분리 관점에서 잘 맞기 때문에 주로 선택한다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003ECQRS 패턴에 이벤트 소싱은 필수가 아니지만 이벤트 소싱에는 CQRS가 필요합니다.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"cqrs의-이점\"\u003E\u003Ca href=\"#cqrs%EC%9D%98-%EC%9D%B4%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECQRS의 이점.\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E독립적인 크기 조정\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ECQRS를 통해 읽기 및 쓰기의 워크로드를 독립적으로 확장할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E최적화된 데이터 스키마\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E읽기 쪽에서는 쿼리에 최적화된 슼니마를 사용하고 쓰기에서는 업데이트에 최적화된 스키마를 사용할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E보안\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E올바른 도메인 엔터티만 데이터에 쓰기를 수행할 수 있는지 쉽게 확인 가능합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E유연한 모델 생성\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E대부분의 복잡한 비즈니스 논리는 쓰기 모델로 이동시키고 읽기모델은 상대적으로 간단하게 정리하여 유지가능하고 유연한 모델을 만들 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E단순한 쿼리\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E읽기 데이터베이스에서 구체화된 뷰를 저장하여 쿼리 시 복잡한 조인을 방지할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"마무리\"\u003E\u003Ca href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E마무리.\u003C\u002Fh2\u003E\n\u003Cp\u003E이전의 게시글과 오늘 게시글을 통해서 \u003Cstrong\u003ECQRS 패턴은 Database의 성능을 올리기 위해서 적용된 패턴\u003C\u002Fstrong\u003E이고 \u003Cstrong\u003ESAGA 패턴은 MSA환경에서의 데이터 일관성을 유지하기 위해 제안된 방법\u003C\u002Fstrong\u003E으로 이해하였습니다.\u003C\u002Fp\u003E\n\u003Cp\u003EMSA에 대해 좀 더 공부해야하는 부분이나, 추가적으로 공부를 해야하는 부분이 있다면 다시 정리해보겠습니다. 회사 업무에서는 MSA 구조를 사용하는 일은 아직 없지만, 혹시라도 이후에 적용하게 되었을 때를 대비학는 의미 + 개인적인 호기심으로 글을 정리했습니다.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.popit.kr\u002Fcqrs-eventsourcing\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fwww.popit.kr\u002Fcqrs-eventsourcing\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.microsoft.com\u002Fko-kr\u002Fazure\u002Farchitecture\u002Fpatterns\u002Fcqrs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fdocs.microsoft.com\u002Fko-kr\u002Fazure\u002Farchitecture\u002Fpatterns\u002Fcqrs\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fengineering-skcc.github.io\u002Fmicroservice%20outer%20achitecture\u002Finner-architecture-cqrs\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fengineering-skcc.github.io\u002Fmicroservice%20outer%20achitecture\u002Finner-architecture-cqrs\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fcode-masterjung.tistory.com\u002F80\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fcode-masterjung.tistory.com\u002F80\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}}]}}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.4c903e18.js" defer></script><script src="/assets/js/page--src--templates--tag-vue.762abdba.js" defer></script>
  </body>
</html>