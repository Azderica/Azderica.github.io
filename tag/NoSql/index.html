<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Hello, world! - Azderica</title><meta name="gridsome:hash" content="4d08d5d9909bc52ba8ae53ab8b5e8ea790bc2d53"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="부족하지만 꿈많은 웹 개발자의 발전 기록입니다."><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.d0be325ebfe2762f973f3e0685345394.png"><link rel="preload" href="/assets/css/0.styles.7a8bb02e.css" as="style"><link rel="preload" href="/assets/js/app.9dd90fe2.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--tag-vue.75013a66.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.b6200640.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.b963cfa0.js"><link rel="prefetch" href="/assets/js/page--src--templates--post-vue.e34e290d.js"><link rel="stylesheet" href="/assets/css/0.styles.7a8bb02e.css"><script data-vue-tag="ssr" type="text/javascript" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
    <link rel="icon" type="image/png" href="favicon.png" />
    <link rel="shortcut icon" type="image/png" href="favicon.png" />
    <meta
      name="google-site-verification"
      content="MqpGCz7XVg4s3AWfrGHCt6AlXPacpV9iGvSFVD0ATHw"
    />
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      ;(function() {
        window.__onThemeChange = function() {}
        function setTheme(newTheme) {
          window.__theme = newTheme
          preferredTheme = newTheme
          document.body.setAttribute('data-theme', newTheme)
          window.__onThemeChange(newTheme)
        }

        var preferredTheme
        try {
          preferredTheme = localStorage.getItem('theme')
        } catch (err) {}

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme)
          try {
            localStorage.setItem('theme', newTheme)
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)')
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        })

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'))
      })()
    </script>

    <div id="app" data-server-rendered="true"><header class="header"><div class="header__left"><a href="/" class="logo active"><span class="logo__text">
    ← Azderica
  </span></a></div><div class="header__right"><button role="button" aria-label="Toggle dark/light" class="toggle-theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></header><main class="main"><h1 class="tag-title text-center space-bottom">
    # Nosql
  </h1><div class="posts"><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[DB] Redis의 개념과 특징, 아키텍처</h2><p class="post-card__description">Nosql 중 Redis에 대해 좀 더 자세하게 알아봅니다.</p><div class="post-meta post-card__meta">
   Posted 15. September 2021.
   <strong>9 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/01-db-nosql-redis/" class="post-card__link">Link</a></div></div><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[DB] NoSQL 데이터베이스 정리</h2><p class="post-card__description">Nosql에 대해 소개하고 특징에 대해 정리합니다.</p><div class="post-meta post-card__meta">
   Posted 1. April 2021.
   <strong>8 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/00-db-nosql/" class="post-card__link">Link</a></div></div></div></main><footer class="footer"><span class="footer__copyright">Copyright © 2021.
    </span><span class="footer__links">Powered by <a href="//gridsome.org"> Gridsome </a></span></footer></div> <script>window.__INITIAL_STATE__={"data":{"tag":{"title":"Nosql","belongsTo":{"edges":[{"node":{"title":"[DB] Redis의 개념과 특징, 아키텍처","path":"\u002F01-db-nosql-redis\u002F","date":"15. September 2021","timeToRead":9,"description":"Nosql 중 Redis에 대해 좀 더 자세하게 알아봅니다.","content":"\u003Ch1 id=\"redis를-좀-더-자세하게\"\u003E\u003Ca href=\"#redis%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERedis를 좀 더 자세하게.\u003C\u002Fh1\u003E\n\u003Cp\u003E지난번 게시글에서는 \u003Ca href=\"https:\u002F\u002Fazderica.github.io\u002F00-db-nosql\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ENoSQL\u003C\u002Fa\u003E에 대한 기본 개념과 종류에 대해서 정리했습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이번에는 더 나아가서 대표적인 NoSQL이 가지는 아키텍처를 정리합니다. 오늘은 Redis에 대해 좀 더 정리하려고합니다.\u003C\u002Fp\u003E\n\u003Ch2 id=\"redis란\"\u003E\u003Ca href=\"#redis%EB%9E%80\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERedis란.\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E고 성능의 키-값 데이터 구조 스토어입니다.\u003C\u002Fli\u003E\n\u003Cli\u003E여러 자료구조를 지원하며 크게 \u003Ccode class=\"language-text\"\u003EString, Set, Sorted Set, Hash, List\u003C\u002Fcode\u003E 등의 데이터 형식을 지원합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"redis-특징\"\u003E\u003Ca href=\"#redis-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERedis 특징\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E영속성을 지원하는 인메모리 데이터 저장소\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E왜 영속성을 제공하는지는 아래에서 설명합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E읽기 성능 증대를 위한 서버 측 복제를 지원합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E전체 데이터베이스의 초기 복사본을 받는 마스터\u002F슬레이브 복제를 지원합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E마스터에서 쓰기가 수행되면 슬레이브 데이터 세트를 실시간으로 업데이터하기 위해 연결된 모든 슬레이브로 전송됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding)을 지원합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003EString, Set, Sorted Set, Hash, List\u003C\u002Fcode\u003E 과 같은 다양한 데이터형을 지원합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E샤딩(Sharding)\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E파티셔닝과 동일하며, 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미합니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"redis-특징-1\"\u003E\u003Ca href=\"#redis-%ED%8A%B9%EC%A7%95-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERedis 특징\u003C\u002Fh2\u003E\n\u003Ch3 id=\"key-value-store\"\u003E\u003Ca href=\"#key-value-store\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EKey-Value Store\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133774329-00ddf3c0-a24e-40b0-9dd8-460616ea5400.png\" alt=\"Redis-is-map\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ERedis는 거대한 맵(Map) 데이터 저장소입니다.\u003C\u002Fli\u003E\n\u003Cli\u003ERedis는 익히기 쉬우며 직관적입니다. 그러나, 데이터를 레디스 자체 내에서는 처리하기 어렵습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"다양한-데이터-타입\"\u003E\u003Ca href=\"#%EB%8B%A4%EC%96%91%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E다양한 데이터 타입\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003EString, Set, Sorted Set, Hash, List\u003C\u002Fcode\u003E 등의 타입을 지원합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"persistence\"\u003E\u003Ca href=\"#persistence\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EPersistence\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133775761-c7644499-ae6f-4aa8-bd25-8208780c41e0.png\" alt=\"Redis-Persistence\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ERedis는 영속성을 가집니다.\u003C\u002Fli\u003E\n\u003Cli\u003ERedis는 데이터를 disk에 저장할 수 있습니다. 따라서 Redis는 서버가 강제 종료되고 재시작하더라도 disk에 저장해놓은 데이터를 다시 읽어서 데이터가 유실되지 않습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003Eredis의 데이터를 disk에 저장하는 방식은 \u003Cstrong\u003Esnapshot, AOF\u003C\u002Fstrong\u003E 방식이 있습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003ESnapshot\u003C\u002Fcode\u003E : RDB와 비슷하게 어떤 특정 시점의 데이터를 Disk에 담는 방식을 뜻합니다. \u003Cstrong\u003EBlocking\u003C\u002Fstrong\u003E 방식의 \u003Cstrong\u003ESAVE\u003C\u002Fstrong\u003E와 \u003Cstrong\u003ENon-blocking\u003C\u002Fstrong\u003E 방식의 \u003Cstrong\u003E\u003Ca href=\"http:\u002F\u002Fredisgate.kr\u002Fredis\u002Fserver\u002Fbgsave.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EBGSAVE\u003C\u002Fa\u003E\u003C\u002Fstrong\u003E 방식이 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003EAOF\u003C\u002Fcode\u003E : Redis의 모든 write\u002Fupdate 연산 자체를 모두 log 파일에 기록하는 형태입니다. 서버가 재시작 시 write\u002Fupdate를 순차적으로 재실행하고 데이터를 복구합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E가장 좋은 방식은 두 방법을 혼용해서 사용하는 방법으로 주기적으로 snapshot으로 백업을 하고 다음 snapshot까지의 저장을 AOF 방식으로 수행하는 방식입니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"ansi-c로-작성\"\u003E\u003Ca href=\"#ansi-c%EB%A1%9C-%EC%9E%91%EC%84%B1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EANSI C로 작성\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EC언어로 작성되어 Java와 같이 가상머신 위에서 동작하는 언어에서 발생하는 성능 문제에서 자유롭습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"서버측-복제-및-샤딩-지원\"\u003E\u003Ca href=\"#%EC%84%9C%EB%B2%84%EC%B8%A1-%EB%B3%B5%EC%A0%9C-%EB%B0%8F-%EC%83%A4%EB%94%A9-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E서버측 복제 및 샤딩 지원\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E읽기 성능 증대를 위해 서버 측 복제를 지원합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E쓰기 성능 증대를 위해 클라이언트 측 샤딩을 지원합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"redis의-장점\"\u003E\u003Ca href=\"#redis%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERedis의 장점\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E리스트, 배열과 같은 데이터를 처리하는데 유용합니다.\u003C\u002Fli\u003E\n\u003Cli\u003EMessage Queue, Shared Memory, Remote Dictionary(RDBMS의 캐시 솔루션 \u002F read 속도가 매우 빠릅니다.) 용도로 사용됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E메모리를 활용하면서 데이터를 보존합니다.\u003C\u002Fli\u003E\n\u003Cli\u003ERedis Server는 1개의 싱글 쓰레드로 수행되며, 서버 하나에 여러개의 서버를 띄우는 것이 가능합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"redis-아키텍처-구성\"\u003E\u003Ca href=\"#redis-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERedis 아키텍처, 구성\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003EHA(High Availability) : 무중단 서비스 등\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"standalone--no-ha-마스터\"\u003E\u003Ca href=\"#standalone--no-ha-%EB%A7%88%EC%8A%A4%ED%84%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EStandalone : No HA, 마스터\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133778042-cf59f712-752a-4c61-8a1a-b9ac435726a1.png\" alt=\"Redis-Standalone\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E레디스 서버 1대로 구성하며 이를 마스터 노드라고 합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E서버 다운시 AOF 또는 Snapshot 파일을 이용해 재 시작합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"replication--half-ha-마스터-슬레이브\"\u003E\u003Ca href=\"#replication--half-ha-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%AC%EB%A0%88%EC%9D%B4%EB%B8%8C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EReplication : Half HA, 마스터-슬레이브\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133778753-41bfa929-aa5f-48e5-9509-7e4df1379baa.png\" alt=\"Redis-Replication\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E레디스 서버 2대(마스터-슬레이브)로 구성됩니다. 슬레이브는 마스터의 데이터를 실시간으로 전달받아 보관합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E마스터 다운 시 슬레이브 서버를 통해 서비스를 계속할 수 있습니다. 하지만, 이때는 수동으로 슬레이브 서버를 마스터로 변경해야합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E한 마스터에 슬레이브를 여러 대 구성할 수 도 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"이중화--센티널sentinel--ha-무중단-서비스-가능\"\u003E\u003Ca href=\"#%EC%9D%B4%EC%A4%91%ED%99%94--%EC%84%BC%ED%8B%B0%EB%84%90sentinel--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E이중화 + 센티널(Sentinel) : HA, 무중단 서비스 가능\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133779960-5c97207f-75d7-405c-a4ea-730bba593e2d.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E마스터-슬레이브 구성에 \u003Cstrong\u003E센티널\u003C\u002Fstrong\u003E을 추가해서 각 서버를 감시하도록하며, 센티널은 마스터 서버를 감시하고 있다가 다운되면 슬레이브를 마스터로 승격시킵니다.\u003C\u002Fli\u003E\n\u003Cli\u003E다운된 마스터가 다시 시작되면 센티널이 슬레이브로 전환시킵니다.\u003C\u002Fli\u003E\n\u003Cli\u003E레디스 마스터 노드가 모든 데이터를 가지고 있으며 슬레이브는 마스터에 대한 복제본을 유지하고 있으며, 데이터를 분산하지 않습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E일반적으로 레디스 센티널은 레디스 서버마다 하나씩 설치하며, 레디스 서버와 분리된 프로세스이며 다른 포트를 사용합니다. (데이터를 처리하지 않습니다.)\u003C\u002Fli\u003E\n\u003Cli\u003E레디스 센티널은 높은 가용성과 자동 fail over 을 해결하지만 \u003Cstrong\u003E데이터 분산 문제를 해결하지 못합니다.\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fhub.docker.com\u002Fr\u002Ferichsu\u002Fredis-sentinel\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis Sentinel Docker\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"레디스-클러스터cluster--ha-무중단-서비스-가능\"\u003E\u003Ca href=\"#%EB%A0%88%EB%94%94%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0cluster--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E레디스 클러스터(Cluster) : HA, 무중단 서비스 가능\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133781464-16c21b85-1ca2-4e0f-8028-5acf9a37a2f8.png\" alt=\"Redis-Cluster-Type-1\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E머신 하나가 죽었을 시 해결이 됩니다. 다만 두개가 죽으면 해결이 안됩니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133782017-fe094509-ed9a-419c-9739-35a766b4e334.png\" alt=\"Redis-Cluster-Type-2\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E위의 문제를 해결하는 방법입니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E샤딩\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E클라스터는 \u003Cstrong\u003E샤딩\u003C\u002Fstrong\u003E(sharding, 대량의 데이터를 처리하기 위해 여러 개의 데이터베이스에 분할하는 기술) 방법을 제공하는 방법입니다.\u003C\u002Fli\u003E\n\u003Cli\u003E100개의 데이터를 1번 마스터에 33개, 2번 마스터 33개, 3번 마스터에 나머지 34개가 저장되는 방식입니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003EHash 함수\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E데이터를 나누는 방식은 키에 hash 함수를 적용해서 값을 추출하고, 이 값을 각 마스터 서버에 할당합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E클러스터 구성시 해쉬 함수를 통해서 1~33까지를 1번 서버, 34~ 66번까지를 2번 서버, 3번 서버는 또 다르게 할당됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E해시 슬록(16384 슬롯)\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E레디스에서 hash 값의 개수는 16384(0~16383)이고 슬롯(slot)이라고 합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E해시 태그\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E다중 키 작업을 진행하려면 동일 노드에 저장될 모든 키가 필요합니다. 해시 태그는 레디스 클러스터에서 다중키를 사용할 수 있는 유일한 방법입니다.\u003C\u002Fli\u003E\n\u003Cli\u003E해시 함수를 적용해 동일한 해시 슬롯에 여러 개의 키 이름을 저장할 수 있도록 사용됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E레디스 클라이언트\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E클라이언트는 서버와 동일한 hash 함수를 가지고 있으며 마스터 서버에 접속해서 각 서버에 할당된 슬롯 정보를 가지고 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E키가 입력되면 hash 함수를 적용해서 어느 마스터에 저장할지 판단해서 해당 마스터에 저장합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E데이터 서버 + 센티널\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E각 마스터 서버는 데이터의 처리와 센티널의 역할을 같이수행합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E1번 마스터 서버가 다운되면 나머지 살아있는 마스터들 중에서 리더를 선출해서 리더가 1번 마스터의 슬레이브를 마스터로 승격시킵니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E최소 3대\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E마스터 서버는 최소 3대로 구성하고 각각은 슬레이브를 가질 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E마스터를 관리하는 마스터는 없습니다. 이는 또 하나의 장애점입니다.\u003C\u002Fli\u003E\n\u003Cli\u003E레디스가 사용하는 포트는 2개이며 하나는 클라이언트 하나는 노드 간의 통신을 위한 버스로 사용됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fjyejye9201.medium.com\u002F%EB%A0%88%EB%94%94%EC%8A%A4-redis-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-2b7af75fa818\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis란 무엇인가\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.redis.com\u002Flatest\u002Frs\u002Fconcepts\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis Concept\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fredisgate.kr\u002Fredis\u002Fconfiguration\u002Fredis_overview.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis Architecture Overview\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fcla9.tistory.com\u002F101\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis 구조\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fengkimbs.tistory.com\u002F869\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E레디스 소개 및 아키텍처, 주의할 점\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fcoding-start.tistory.com\u002F128\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis - Cluster &#x26; Sentinel\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fredis.io\u002Fcommands\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis Command\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fredis.com\u002Fredis-enterprise\u002Ftechnology\u002Fredis-enterprise-cluster-architecture\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis Enterprise Cluster Architecture\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}},{"node":{"title":"[DB] NoSQL 데이터베이스 정리","path":"\u002F00-db-nosql\u002F","date":"1. April 2021","timeToRead":8,"description":"Nosql에 대해 소개하고 특징에 대해 정리합니다.","content":"\u003Ch1 id=\"nosql\"\u003E\u003Ca href=\"#nosql\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ENoSQL\u003C\u002Fh1\u003E\n\u003Cp\u003E해당 게시글은 NoSQL에 대한 내용을 간략하게 정리하고, 여러가지 NoSQL Database를 특징별로 정리합니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"rdb와의-차이\"\u003E\u003Ca href=\"#rdb%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERDB와의 차이\u003C\u002Fh2\u003E\n\u003Cp\u003E대부분 RDB와 NoSQL의 차이를 인지하고 있는데 이를 표로 간략하게 정리하면 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003E-\u003C\u002Fth\u003E\n\u003Cth\u003ERDB\u003C\u002Fth\u003E\n\u003Cth\u003ENoSQL\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E데이터모델\u003C\u002Ftd\u003E\n\u003Ctd\u003E고정 행과 열이 있는 테이블\u003C\u002Ftd\u003E\n\u003Ctd\u003Edocument-Json, key value, ...\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E예시\u003C\u002Ftd\u003E\n\u003Ctd\u003EOracle, MySQL, MSSQL, PostgreSQL\u003C\u002Ftd\u003E\n\u003Ctd\u003EMongoDB, Redis, Hbase, Neo4j\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E목적\u003C\u002Ftd\u003E\n\u003Ctd\u003E범용\u003C\u002Ftd\u003E\n\u003Ctd\u003E범용, 대량의 데이터 추출, 관계 분석, 탐색 등\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E스키마\u003C\u002Ftd\u003E\n\u003Ctd\u003E엄격\u003C\u002Ftd\u003E\n\u003Ctd\u003E유연\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E확장성\u003C\u002Ftd\u003E\n\u003Ctd\u003E수직\u003C\u002Ftd\u003E\n\u003Ctd\u003E수형성\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EACID 트랜잭션\u003C\u002Ftd\u003E\n\u003Ctd\u003E지원\u003C\u002Ftd\u003E\n\u003Ctd\u003E대부분 지원하지 않음\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EORM\u003C\u002Ftd\u003E\n\u003Ctd\u003EORM 필요\u003C\u002Ftd\u003E\n\u003Ctd\u003E대부분 ORM이 필요없음\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"nosql의-장단점\"\u003E\u003Ca href=\"#nosql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ENoSQL의 장단점\u003C\u002Fh2\u003E\n\u003Ch3 id=\"nosql의-장점\"\u003E\u003Ca href=\"#nosql%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ENoSQL의 장점\u003C\u002Fh3\u003E\n\u003Cp\u003ENoSQL은 다음의 장점을 가집니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E유연한 데이터 모델\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E유연한 스키마를 가지므로, 요구 사항이 변경되었을 때 데이터베이스를 쉽게 변경할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E수평적 확장\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E일반적으로 RDB의 경우에는 용량 초과시 \u003Cstrong\u003E수직적 확장\u003C\u002Fstrong\u003E(크고 비싼 서버)가 필요하지만, NoSQL의 경우는 수평적 확장이 가능합니다. (제한은 존재함)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E빠른 쿼리\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E일반적으로 RDB의 경우, 여러 테이블을 Join해서 쿼리를 사용하지만, NoSQL의 경우는 쿼리에 최적화되어 저장합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E개발자에 친화적\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ENoSQL은 데이터 구조를 일반적인 프로그래밍 언어의 데이터 구조에 매핑합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E적은 코드를 작성하면서, 개발 시간을 단축하고 버그를 줄일 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"nosql의-단점\"\u003E\u003Ca href=\"#nosql%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ENoSQL의 단점\u003C\u002Fh3\u003E\n\u003Cp\u003ENoSQL에서 이야기되는 가장 큰 단점으로는 ACID 트랜잭션을 지원하지 않는 것입니다. 물론 적절한 스키마 디자인을 제공하면 단일 레코드의 원자화는 가능합니다.\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EACID\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cul\u003E\n\u003Cli\u003EA : atomicity, 원자성\u003C\u002Fli\u003E\n\u003Cli\u003EC : consistency, 일관성\u003C\u002Fli\u003E\n\u003Cli\u003EI : isolation, 고립성\u003C\u002Fli\u003E\n\u003Cli\u003ED : durability, 지속성\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"nosql-데이터베이스-별-특징\"\u003E\u003Ca href=\"#nosql-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%B3%84-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ENoSQL 데이터베이스 별 특징\u003C\u002Fh2\u003E\n\u003Cp\u003ENoSQL 데이터베이스의 특성을 크게 다음과 같이 4가지로 나눌 수 있습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EKey-Value Database\u003C\u002Fli\u003E\n\u003Cli\u003EDocument Database\u003C\u002Fli\u003E\n\u003Cli\u003EColumn Family Database\u003C\u002Fli\u003E\n\u003Cli\u003EGraph Database\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"key-value-database\"\u003E\u003Ca href=\"#key-value-database\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EKey-Value Database\u003C\u002Fh3\u003E\n\u003Cp\u003EKey와 Value로 이루어졌으며, \u003Cstrong\u003E저장과 조회\u003C\u002Fstrong\u003E이란 원칙에 가장 충실합니다.\u003C\u002Fp\u003E\n\u003Cp\u003EKey-Value Database는 다음의 특징을 가집니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EKey 값은 unique한 고유값으로 유지되어야합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E테이블간 join을 고려하지 않으므로 RDB의 외부키 등이 필요없습니다.\u003C\u002Fli\u003E\n\u003Cli\u003EValue에 모든 데이터 타입을 허용하며 이에 따라 검증 로직을 잘 구성하는 것이 중요합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EKey-Value Database는 다음과 같은 종류들이 있습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003ERedis\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003EAWS DynamoDB\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EOracle Berkely\u003C\u002Fli\u003E\n\u003Cli\u003ERiak\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EKey-Value Database는 일반적으로 아래의 경우에서 많이 사용합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E성능 향상을 위해 데이터베이스 데이터 캐싱\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E웰 어플리케이션에서 일시적인 속성 추적\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E모바일 애플리케이션용 사용자 데이터 정보와 구성 정보 저장\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E다만 개인정보 등은 NoSQL에 저장하는 것은 지양해야함.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E이미지나 오디오 파일 같은 대용량 객체 저장\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E일반적으로 NAS를 사용하기는 함.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"document-database\"\u003E\u003Ca href=\"#document-database\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EDocument Database\u003C\u002Fh3\u003E\n\u003Cp\u003EKey-Value Database와 마찬가지로 데이터 저장시에는 Key-Value Type을 사용하지만, 가장 큰 차이는 \u003Cstrong\u003EDocument 타입으로 저장\u003C\u002Fstrong\u003E됩니다. (Ex. JSON, XML)\u003C\u002Fp\u003E\n\u003Cp\u003EDocument Database는 다음의 특징을 가집니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E값을 문서(semi-structured entity)로 저장합니다. (일반적으로 JSON, XML)\u003C\u002Fli\u003E\n\u003Cli\u003E값을 저장하기 전에 schema를 별도로 정의하지 않으며, document가 schema가 됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E각 문서별로 다른 필드를 가질 수 있기 때문에 개발자는 입력시 \u003Cstrong\u003E컬럼과 필드에 대한 관리\u003C\u002Fstrong\u003E를 제대로 해야합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E필도 속성에 대한 관리가 필요합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EDocument Database는 다음과 같은 종류가 있습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003EMongoDB\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003ECouchDB\u003C\u002Fli\u003E\n\u003Cli\u003ECouchbase\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EDocument Database는 일반적으로 아래의 경우에서 많이 사용합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E대용량 데이터를 읽고 쓰는 웹사이트 백엔드 지원\u003C\u002Fli\u003E\n\u003Cli\u003E제품처럼 다양한 속성이 있는 데이터 관리\u003C\u002Fli\u003E\n\u003Cli\u003E다양한 유형의 메타데이터 추적\u003C\u002Fli\u003E\n\u003Cli\u003EJson 데이터 구조를 사용하는 어플리케이션\u003C\u002Fli\u003E\n\u003Cli\u003E비정규화된 중첩 구조의 데이터를 사용하는 애플리케이션\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003ECouchDB와 Couchbase의 차이.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cul\u003E\n\u003Cli\u003ECouchbase는 JSON용 SQL과 같은 쿼리 언어 N1QL이 있으나, CouchDB는 없습니다.\u003C\u002Fli\u003E\n\u003Cli\u003ECouchbase는 기업용이 있으나, CouchDB는 오픈소스만 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003ECouchbase는 pessimistic lock이 있으나, CouchDB는 MVCC 개념을 사용하므로 없습니다.\u003C\u002Fli\u003E\n\u003Cli\u003ECouchbase의 topology는 분산되어 있으나, CouchDB는 master-master 복제 개념입니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"column-family-database\"\u003E\u003Ca href=\"#column-family-database\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EColumn Family Database\u003C\u002Fh3\u003E\n\u003Cp\u003EColumn Family Database는 대용량 데이터, 읽기와 쓰기 성능, 고가용성을 위해 설계되었습니다. (Ex. 구글의 Big Table, 페이스북의 Cassandra)\u003C\u002Fp\u003E\n\u003Cp\u003EColumn Family Database는 다음의 특징을 가집니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003ERDB와 같이 Column과 Row를 사용해서 스키마를 정의합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E컬럼 수가 많으면 관련된 컬럼들을 컬렉션으로 묶을 수 있습니다. (이를 \u003Cstrong\u003EColumn Family\u003C\u002Fstrong\u003E라고 합니다.)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003EDocument Database와 같이 미리 정의된 스키마를 사용하지 않으므로 원하는 시점에 컬럼을 추가가능합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E테이블간 조인을 지원하지 않습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E즉, 다음과 같은 모습으로 구성되어 있습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F113298137-76779e80-9336-11eb-9ed1-cb287417ad04.png\" alt=\"Hbase Column Families\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EColumn Family Database는 다음과 같은 종류가 있습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003EHbase\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003ECassandra\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EGCP(Google Cloud Platform) BigTable\u003C\u002Fli\u003E\n\u003Cli\u003EMS Azure Cosmos DB\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EColumn Family Database는 일반적으로 아래의 경우에서 많이 사용합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E데이터베이스에 쓰기 작업이 많은 애플리케이션\u003C\u002Fli\u003E\n\u003Cli\u003E지리적으로 여러 데이터 센터에 분산되어 있는 애플리케이션\u003C\u002Fli\u003E\n\u003Cli\u003E복제본 데이터가 단기적으로 불일치해도 큰 문제가 없는 애플리케이션\u003C\u002Fli\u003E\n\u003Cli\u003E동적 필드를 처리하는 애플리케이션\u003C\u002Fli\u003E\n\u003Cli\u003E수백만 테라바이트 정도의 대용량 데이터를 처리할 수 있는 애플리케이션\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E다음은 Column Family Database의 성능 표입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F113298465-d40beb00-9336-11eb-8c64-8752cb98d1eb.png\" alt=\"Column Family Database Trend Chart\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E일반적으로 Hbase와 Cassandra가 많이 쓰입니다. 다만, Hbase는 성능이 높으나 시스켐 복잡도와 Learning Curve의 문제로 인해 Cassandra가 더 보편적으로 선호됩니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"graph-database\"\u003E\u003Ca href=\"#graph-database\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EGraph Database\u003C\u002Fh3\u003E\n\u003Cp\u003EGraph Database는 Graph 이론을 활용한 것이며, Node(노드)들과 Relationship(관계)로 구성된 개념입니다. 노드는 Key-Value 값을 가지고 있고 노드는 하나 이상의 레이블을 구성할 수 있습니다.\u003C\u002Fp\u003E\n\u003Cp\u003EGraph Database는 다음의 특징을 가집니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E간단하고 직관적인 데이터 모델을 가집니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F113299571-fb16ec80-9337-11eb-9b17-b42ce16c51d0.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EGraph Database는 다음과 같은 종류가 있습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003ENeo4j\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003ETitan\u003C\u002Fli\u003E\n\u003Cli\u003EAllegroGraph\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EGraph Database는 일반적으로 아래의 경우에서 많이 사용합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E지식 그래프나 소셜 그래프\u003C\u002Fli\u003E\n\u003Cli\u003E자격 증명 그래프\u003C\u002Fli\u003E\n\u003Cli\u003E사기 탐지 및 추천 엔진\u003C\u002Fli\u003E\n\u003Cli\u003E생명 과학 분야\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fjaemunbro.medium.com\u002Fnosql-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B9%EC%84%B1-%EB%B9%84%EA%B5%90-c9abe1b2838c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ENoSQL 데이터베이스별 특징\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvelog.io\u002F@hanblueblue\u002F%EB%B2%88%EC%97%AD-NoSQL-vs-Relational-Databases\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ENoSQL vs Relational Database\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvelog.io\u002F@hanblueblue\u002F%EB%B2%88%EC%97%AD-NoSQL-vs-Relational-Databases\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EDB, RDBMS VS NoSQL\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fblogs.perficient.com\u002F2017\u002F07\u002F18\u002Fto-know-more-about-nosql-counchdb-vs-couchbase\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ECouchbase VS CouchDB\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fcouplewith.tistory.com\u002Fentry\u002FGraph-DB-%EC%99%80-RDBMS-%ED%8A%B8%EB%9E%9C%EB%93%9C-3%EB%B6%80-%EA%B7%B8%EB%9E%98%ED%94%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%A2%85%EB%A5%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EGraphDB\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}}]}}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.9dd90fe2.js" defer></script><script src="/assets/js/page--src--templates--tag-vue.75013a66.js" defer></script>
  </body>
</html>
