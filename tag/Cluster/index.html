<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Hello, world! - Azderica</title><meta name="gridsome:hash" content="c7c6273426a1f1c25b484e341518249aeec696cd"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="부족하지만 꿈많은 웹 개발자의 발전 기록입니다."><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.d0be325ebfe2762f973f3e0685345394.png"><link rel="preload" href="/assets/css/0.styles.7a8bb02e.css" as="style"><link rel="preload" href="/assets/js/app.bcecea3f.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--tag-vue.de8981a7.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.b6200640.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.55636363.js"><link rel="prefetch" href="/assets/js/page--src--templates--post-vue.8171b5bf.js"><link rel="stylesheet" href="/assets/css/0.styles.7a8bb02e.css"><script data-vue-tag="ssr" type="text/javascript" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
    <link rel="icon" type="image/png" href="favicon.png" />
    <link rel="shortcut icon" type="image/png" href="favicon.png" />
    <meta
      name="google-site-verification"
      content="MqpGCz7XVg4s3AWfrGHCt6AlXPacpV9iGvSFVD0ATHw"
    />
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      ;(function() {
        window.__onThemeChange = function() {}
        function setTheme(newTheme) {
          window.__theme = newTheme
          preferredTheme = newTheme
          document.body.setAttribute('data-theme', newTheme)
          window.__onThemeChange(newTheme)
        }

        var preferredTheme
        try {
          preferredTheme = localStorage.getItem('theme')
        } catch (err) {}

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme)
          try {
            localStorage.setItem('theme', newTheme)
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)')
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        })

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'))
      })()
    </script>

    <div id="app" data-server-rendered="true"><header class="header"><div class="header__left"><a href="/" class="logo active"><span class="logo__text">
    ← Azderica
  </span></a></div><div class="header__right"><button role="button" aria-label="Toggle dark/light" class="toggle-theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></header><main class="main"><h1 class="tag-title text-center space-bottom">
    # Cluster
  </h1><div class="posts"><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[DB] Couchbase의 개념과 특징, 아키텍처</h2><p class="post-card__description">Nosql 중 Couchbase에 대해 좀 더 자세하게 알아봅니다.</p><div class="post-meta post-card__meta">
   Posted 20. September 2021.
   <strong>11 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/02-db-nosql-couchbase/" class="post-card__link">Link</a></div></div><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[DB] Redis의 개념과 특징, 아키텍처</h2><p class="post-card__description">NoSQL 중 Redis에 대해 좀 더 자세하게 알아봅니다.</p><div class="post-meta post-card__meta">
   Posted 17. September 2021.
   <strong>9 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/01-db-nosql-redis/" class="post-card__link">Link</a></div></div></div></main><footer class="footer"><span class="footer__copyright">Copyright © 2021.
    </span><span class="footer__links">Powered by <a href="//gridsome.org"> Gridsome </a></span></footer></div> <script>window.__INITIAL_STATE__={"data":{"tag":{"title":"Cluster","belongsTo":{"edges":[{"node":{"title":"[DB] Couchbase의 개념과 특징, 아키텍처","path":"\u002F02-db-nosql-couchbase\u002F","date":"20. September 2021","timeToRead":11,"description":"Nosql 중 Couchbase에 대해 좀 더 자세하게 알아봅니다.","content":"\u003Ch1 id=\"couchbase를-좀-더-자세하게\"\u003E\u003Ca href=\"#couchbase%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECouchbase를 좀 더 자세하게\u003C\u002Fh1\u003E\n\u003Cp\u003E지난 게시글은 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fazderica.github.io\u002F00-db-nosql\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ENoSQL\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fazderica.github.io\u002F01-db-nosql-redis\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E오늘은 Couchbase 개념입니다.\u003C\u002Fp\u003E\n\u003Ch2 id=\"couchbase-개념\"\u003E\u003Ca href=\"#couchbase-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECouchbase 개념\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E카우치 베이스는 Document 기반의 Key-Value 스토어입니다.\u003C\u002Fli\u003E\n\u003Cli\u003E하나의 유니크(Unique)한 키에 값을 저장하는 방식이며, 저장되는 값은 JSON 도큐먼트가 저장됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E키(key)는 최대 \u003Cstrong\u003E250 바이트\u003C\u002Fstrong\u003E, 밸류(Value)는 카우치베이스 버킷은 20BMB, Memcached 방식의 버킷의 경우 1MB까지 저장이 됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E저장할 때, 키와 값 뿐만 아니라 메타데이터도 같이 저장되며 메타 데이터는 \u003Ccode class=\"language-text\"\u003ECAS, TTL, Flag\u003C\u002Fcode\u003E 값 3가지가 저장됩니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003ECAS\u003C\u002Fcode\u003E : 데이터에 대한 일종의 타임 스탬프와 같은 개념으로, 여러 클라이언트가 같이 데이터를 접근했을 때 일관성(Consistent) 문제를 해결해줍니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003ETTL\u003C\u002Fcode\u003E : \u003Ccode class=\"language-text\"\u003ETime To Live\u003C\u002Fcode\u003E, 데이터의 유효 시간을 정의합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003EFLAG\u003C\u002Fcode\u003E : 카우치베이스 클라이언트에서 사용하는 메타데이터입니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E이러한 메타데이터는 하나의 메타데이터(CAS, TTL, Flag)는 60바이트의 메모리를 차지하며, 카우치베이스 서버는 모든 키와 메타데이터를 유지하기 위해 용량을 설계할때, RAM의 사이즈를 결정합니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"버킷bucket\"\u003E\u003Ca href=\"#%EB%B2%84%ED%82%B7bucket\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E버킷(Bucket)\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E일종의 RDBMS의 데이터베이스 같은 공간이며 JSON document 들은 이 버킷에 저장됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E각각의 버킷은 고유의 속성 값을 가지고 있습니다. 버킷별로 사용할 수 있는 메모리 양, 옵션으로 버킷별로 접근할 수 있는 TCP 포트, 접근 비밀번호, 버킷에 들어가는 데이터에 대한 복제본의 수 등을 정할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"뷰view\"\u003E\u003Ca href=\"#%EB%B7%B0view\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E뷰(View)\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E카우치 베이스의 강력한 능력이며, 이 뷰를 통해서 \u003Ccode class=\"language-text\"\u003EIndexing, grouping, sorting\u003C\u002Fcode\u003E 등이 가능합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E뷰는 데이터베이스 뷰와 유사한 개념을 가지며 카우치베이스의 뷰는 incremental view라는 컨셉을 가집니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E다음의 예시를 보면 뷰의 기능의 동작을 예상할 수 있습니다. Json document 안에 주민번호있고, 80년생 이하만 저장하는 뷰를 만든다고 가정하면 데이터가 버킷에 저장될 때마다 생성된 뷰에 같이 저장됩니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133991552-ccead205-7fc2-4ed3-bc6a-7832eee5e241.png\" alt=\"couchbase-view-sample\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E이와 같은 결과로 데이터를 저장하거나 업데이트시 뷰 코드가 매번 수행되고, 뷰코드에 저장된 알고리즘에 따라 뷰에 데이터를 업데이트합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이를 더 자세하게 보면 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133992279-e17df7a9-9369-459f-9b27-9a840b9edb14.png\" alt=\"Map &#x26; Reduce\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fbcho.tistory.com\u002F928?category=534534\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E출처 및 뷰에 대한 상세 개념\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode class=\"language-text\"\u003EMap Function(Map &amp; Reduce)\u003C\u002Fcode\u003E 함수를 통해서 View를 만듭니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E맵함수는 두 개의 인자를 전달받으며 index(id, key, value)를 만들고 리듀스를 통해서 grouping이나 여러 처리를 할 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E즉, \u003Cstrong\u003E뷰에는 각 버킷내의 개별 데이터를 반환하는 맵함수와 변환된 개별 데이터를 그룹별로 모아서 처리할 수 있는 리듀스 함수를 가집니다.\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"couchbase-특징\"\u003E\u003Ca href=\"#couchbase-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECouchbase 특징\u003C\u002Fh2\u003E\n\u003Ch3 id=\"memcached-기반의-level-2-캐쉬를-내장하여-빠릅니다\"\u003E\u003Ca href=\"#memcached-%EA%B8%B0%EB%B0%98%EC%9D%98-level-2-%EC%BA%90%EC%89%AC%EB%A5%BC-%EB%82%B4%EC%9E%A5%ED%95%98%EC%97%AC-%EB%B9%A0%EB%A6%85%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMemcached 기반의 Level 2 캐쉬를 내장하여 빠릅니다.\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003Ememcached를 자체적으로 Level 2 캐쉬로 사용합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E자체적으로 메모리 캐쉬 기능을 가지고 있기 때문에 성능이 빠릅니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E(다만, 키의 유연성이나 클러스터에서 단점을 가집니다.)\u003C\u002Fp\u003E\n\u003Ch3 id=\"모바일-디바이스와-sync\"\u003E\u003Ca href=\"#%EB%AA%A8%EB%B0%94%EC%9D%BC-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4%EC%99%80-sync\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E모바일 디바이스와 Sync\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E카우치디비 계열 DB들은 모바일 디바이스에 탑재할 수 있으며, 서버에 설치된 카우치베이스 계열과 Sync가 됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"데이터-센터간-복제-기간\"\u003E\u003Ca href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%84%BC%ED%84%B0%EA%B0%84-%EB%B3%B5%EC%A0%9C-%EA%B8%B0%EA%B0%84\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E데이터 센터간 복제 기간\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EXDCR(Cross Data Center Replication)의 기능을 이용해서 물리적으로 떨어진 데이터 센터간에 복제가 가능합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fazderica.github.io\u002F00-db-couchbase-xdcr\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EXDCR의 상세 내용\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"indexing-grouping-ordering-join-가능\"\u003E\u003Ca href=\"#indexing-grouping-ordering-join-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EIndexing, Grouping, Ordering, Join 가능\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E대부분의 NoSQL은 Key\u002FValue Store 형식으로, 개별 필드에 대한 Indexing이나 필드별로 group by를 통한 sum,count 등의 기능, 특정 필드별로의 Sorting이 불가능합니다.\u003C\u002Fli\u003E\n\u003Cli\u003EIndexing을 지원하는 경우도 있기는 하지만, 내부적으로 성능상 문제가 있는 경우가 많으나 카우치베이스는 그러한 문제가 없습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"확장이-쉬움\"\u003E\u003Ca href=\"#%ED%99%95%EC%9E%A5%EC%9D%B4-%EC%89%AC%EC%9B%80\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E확장이 쉬움\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E분산 구조의 NoSQL의 경우 노드확장이 어렵거나 장애처리가 어려운 경우가 많으나 카우치베이스는 손쉽게 확장을 하고 장애 처리를 합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E이러한 장점은 운영에서 큰 이점이 됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"built-in-관리-도구-제공\"\u003E\u003Ca href=\"#built-in-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC-%EC%A0%9C%EA%B3%B5\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EBuilt in 관리 도구 제공\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E카우치베이스는 웹 기반의 GUI 관리 도구를 기본으로 제공합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003ECouchbase Web Console\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133992009-871775fb-ac8f-4453-ad35-5ba7ba349d31.png\" alt=\"couchbase-web-console\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fsoccerda.tistory.com\u002F124\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E출처\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"memcached-프로토콜-지원\"\u003E\u003Ca href=\"#memcached-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMemcached 프로토콜 지원\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E캐쉬 솔루션으로 유명한 Memcached 르포토콜을 지원하기 때문에 Memcached 인프라를 사용할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"스키마가-없는-유연한-저장-구조scheme-less\"\u003E\u003Ca href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88%EA%B0%80-%EC%97%86%EB%8A%94-%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%A0%80%EC%9E%A5-%EA%B5%AC%EC%A1%B0scheme-less\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E스키마가 없는 유연한 저장 구조(Scheme-less)\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E스키마가 없으므로 하나의 테이블에 컬럼 형식이 다른 데이터를 넣을 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E하나의 데이터 버킷에 데이타 구조가 다른 JSON 문서들을 넣을 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E데이터 타입이 다름에도 불구하고 공통되는 필드에 대해 Indexing, grouping 등을 제공할 수 있으며 JSON 도큐먼트에 country 라는 앨리먼트가 있는 도큐먼트등을 대상으로 grouping등을 할수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"couchbase-architecture\"\u003E\u003Ca href=\"#couchbase-architecture\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECouchbase Architecture\u003C\u002Fh2\u003E\n\u003Cp\u003ECouchbase Server는 모든 노드에 설치된 단일 패키지로 구성됩니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"노드와-클러스터node--cluster\"\u003E\u003Ca href=\"#%EB%85%B8%EB%93%9C%EC%99%80-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0node--cluster\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E노드와 클러스터(Node &#x26; Cluster)\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E노드는 물리적인 서버에서 기동하는 하나의 카우치베이스 인스턴스\u003C\u002Fli\u003E\n\u003Cli\u003E카우치베이스는 여러 개의 노드로 이루어진 클러스터로 구성됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"클라이언트-sdkclient-sdk\"\u003E\u003Ca href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-sdkclient-sdk\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E클라이언트 SDK(Client SDK)\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E프로그래밍 언어별로 카우치베이스에 접근하기 위한 API(SDK)를 제공합니다.\u003C\u002Fli\u003E\n\u003Cli\u003ESDK를 사용해서 선택한 언어(Java, node.js, .NET 등)으로 애플리케이션을 작성할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"vbucket\"\u003E\u003Ca href=\"#vbucket\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EvBucket\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E카우치베이스는 실제 데이터와 물리서버간의 맵핑을 \u003Ccode class=\"language-text\"\u003EvBucket\u003C\u002Fcode\u003E을 통해 관리합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E카우치베이스는 키-밸류 스토어이며, 각 키가 어디있는지는 vBucket이라는 단위로 관리하고, 키에 대한 해쉬값을 계산한 후에 각 해쉬값에 따라서 저장되는 vBucket을 맵핑한다음 각 vBucket을 노드에 맵핑합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003ERebalancing\u003C\u002Fstrong\u003E : 노드가 추가되거나 삭제되었을 때, 물리적으로 데이터가 다른 노드로 다시 분산배치되고 새롭게 배치된 데이터에 따라 vBucket이 노드간에 데이터 맵핑 정보도 업데이트됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133996020-9ffb4d3d-9091-4e47-bb22-fdcf93baf961.png\" alt=\"vBucket\"\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"노드의-구조\"\u003E\u003Ca href=\"#%EB%85%B8%EB%93%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E노드의 구조\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133996334-1d0c59e5-c7d7-48d9-a8a8-ea87bc0fed64.png\" alt=\"couchbase-node-detail\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ECouchbase의 노드는 Data Manage과 Cluster Manager로 나눠집니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"data-manager\"\u003E\u003Ca href=\"#data-manager\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EData Manager\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E직접 데이터에 접근하는 부분이며, set\u002Fget 메서드를 통한 데이터 저장이나 뷰에 대한 쿼리를 수행할 때 접근합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003EMulti Thread Persistence Engine\u003C\u002Fcode\u003E : 디스크에 데이터를 저장하거나 읽을 때 사용하는 컴포넌트입니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"cluster-manager\"\u003E\u003Ca href=\"#cluster-manager\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECluster Manager\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E노드에 대한 상태와 클러스터에 대한 상태, 설정 등을 관리하는 부분이며 \u003Ccode class=\"language-text\"\u003EErlang\u002FOTP\u003C\u002Fcode\u003E로 구성되어 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E카우치베이스 클라이언트 SDK는 8091포트의 REST API를 통해서 vBucket 정보를 가져옵니다.\u003C\u002Fli\u003E\n\u003Cli\u003E다수의 포트 등을 사용합니다. (사용전에 열어야하는 포트들이 있습니다.)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"데이터-쓰기와-복제\"\u003E\u003Ca href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%93%B0%EA%B8%B0%EC%99%80-%EB%B3%B5%EC%A0%9C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E데이터 쓰기와 복제\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133997054-0f325983-d6b6-4a10-b1e7-634de4a7e50b.png\" alt=\"couchbase-data-read\u002Fwrite\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E클라이언트에서 Client SDK를 통해서 쓰기 요청을 하면, Client SDK는 해쉬 알고리즘에 따라 데이터의 키 값에 맵핑되는 vBucket을 찾아내고 그 해당하는 노드를 찾아 쓰기 요청을 합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E쓰기 요청은 해당 노드의 Listener로 전달되고, 이 Listener는 들어온 데이터를 로컬의 캐쉬에 쓰고 클러스터의 다른 노드로 복제 요청을 보냅니다. 그리고 데이터는 노드의 디스크에 저장됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"couchbase-cluster\"\u003E\u003Ca href=\"#couchbase-cluster\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECouchbase Cluster\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003ECouchbase 클러스터는 각각 독립 노드에서 실행되는 하나 이상의 Couchbase Server 인스턴스로 구성됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003ECouchbase Server를 실행하는 각 노드, 클러스터에 여러 노드가 있는 경우 Couchbase 클러스터 관리자는 각 노드에서 실행됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E클러스터의 전체 또는 일부 노드에서 실행되도록 서비스를 구성할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"유혀성\"\u003E\u003Ca href=\"#%EC%9C%A0%ED%98%80%EC%84%B1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E유혀성\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E데이터는 Couchbase Server에 의해 클러스터 전체에 자동으로 배포됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003ECouchbase Server는 노드 추가 및 제거, 노드 장애를 자동으로 처리합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"couchbase-vs-mongodb\"\u003E\u003Ca href=\"#couchbase-vs-mongodb\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECouchbase VS MongoDB\u003C\u002Fh2\u003E\n\u003Cp\u003E공통점은 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EDocument 기반의 NoSQL입니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E그러나 차이점이 있습니다.\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003E이름\u003C\u002Fth\u003E\n\u003Cth\u003ECouchbase\u003C\u002Fth\u003E\n\u003Cth\u003EMongoDB\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E설명\u003C\u002Ftd\u003E\n\u003Ctd\u003EMemcached 호환 인터페이스를 사용하여 CouchDB에서 파생된 JSON 기반 문서 저장소\u003C\u002Ftd\u003E\n\u003Ctd\u003E완전 관리형 클라우드 서비스와 자체 관리형, 인프라에 배포할 수 있는 가장 인기있는 문서 저장소 입니다.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E기본 데이터베이스 모델\u003C\u002Ftd\u003E\n\u003Ctd\u003E문서 저장소\u003C\u002Ftd\u003E\n\u003Ctd\u003E문서 저장소\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E보조 데이터베이스 모델\u003C\u002Ftd\u003E\n\u003Ctd\u003E키-값 저장 공간 DBMS\u003C\u002Ftd\u003E\n\u003Ctd\u003E공간 DBMS\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E스키마\u003C\u002Ftd\u003E\n\u003Ctd\u003EX\u003C\u002Ftd\u003E\n\u003Ctd\u003EX\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E파티셔닝\u003C\u002Ftd\u003E\n\u003Ctd\u003E샤딩\u003C\u002Ftd\u003E\n\u003Ctd\u003E샤딩\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\n\u003Cp\u003E좀 더 자세한 차이를 알기 위해서는 다음 링크를 참고합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fdb-engines.com\u002Fen\u002Fsystem\u002FCouchbase%3BMongoDB\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ECouchbase VS MongoDB\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fbcho.tistory.com\u002F924\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ecouchbase 소개\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fbcho.tistory.com\u002F925\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ecouchbase 개념\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fbcho.tistory.com\u002F928\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ecouchbase view\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fbcho.tistory.com\u002F934\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ecouchbase architecture\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.couchbase.com\u002Fserver\u002F5.0\u002Farchitecture\u002Farchitecture-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ecouchbase architecture detail\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.couchbase.com\u002Fserver\u002Fcurrent\u002Flearn\u002Fclusters-and-availability\u002Fclusters-and-availability.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ecouchbase cluster\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdzone.com\u002Farticles\u002Fintroduction-to-couchbase-for-mongodb-developers-a-1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ecouchbase vs mongodb\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fzepinos.tistory.com\u002F60?category=797689\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E왜 Couchbase을 선택하게 되었는가 - 1\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fzepinos.tistory.com\u002F61\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E왜 Couchbase을 선택하게 되었는가 - 2\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.couchbase.com\u002Fcouchbase-manual-2.5\u002Fcb-admin\u002F#faqs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ECouchbase Docs\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}},{"node":{"title":"[DB] Redis의 개념과 특징, 아키텍처","path":"\u002F01-db-nosql-redis\u002F","date":"17. September 2021","timeToRead":9,"description":"NoSQL 중 Redis에 대해 좀 더 자세하게 알아봅니다.","content":"\u003Ch1 id=\"redis를-좀-더-자세하게\"\u003E\u003Ca href=\"#redis%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERedis를 좀 더 자세하게.\u003C\u002Fh1\u003E\n\u003Cp\u003E지난번 게시글에서는 \u003Ca href=\"https:\u002F\u002Fazderica.github.io\u002F00-db-nosql\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ENoSQL\u003C\u002Fa\u003E에 대한 기본 개념과 종류에 대해서 정리했습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이번에는 더 나아가서 대표적인 NoSQL이 가지는 아키텍처를 정리합니다. 오늘은 Redis에 대해 좀 더 정리하려고합니다.\u003C\u002Fp\u003E\n\u003Ch2 id=\"redis란\"\u003E\u003Ca href=\"#redis%EB%9E%80\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERedis란.\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E고 성능의 키-값 데이터 구조 스토어입니다.\u003C\u002Fli\u003E\n\u003Cli\u003E여러 자료구조를 지원하며 크게 \u003Ccode class=\"language-text\"\u003EString, Set, Sorted Set, Hash, List\u003C\u002Fcode\u003E 등의 데이터 형식을 지원합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"redis-특징\"\u003E\u003Ca href=\"#redis-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERedis 특징\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E영속성을 지원하는 인메모리 데이터 저장소\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E왜 영속성을 제공하는지는 아래에서 설명합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E읽기 성능 증대를 위한 서버 측 복제를 지원합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E전체 데이터베이스의 초기 복사본을 받는 마스터\u002F슬레이브 복제를 지원합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E마스터에서 쓰기가 수행되면 슬레이브 데이터 세트를 실시간으로 업데이터하기 위해 연결된 모든 슬레이브로 전송됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding)을 지원합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003EString, Set, Sorted Set, Hash, List\u003C\u002Fcode\u003E 과 같은 다양한 데이터형을 지원합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E샤딩(Sharding)\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E파티셔닝과 동일하며, 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미합니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"redis-특징-1\"\u003E\u003Ca href=\"#redis-%ED%8A%B9%EC%A7%95-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERedis 특징\u003C\u002Fh2\u003E\n\u003Ch3 id=\"key-value-store\"\u003E\u003Ca href=\"#key-value-store\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EKey-Value Store\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133774329-00ddf3c0-a24e-40b0-9dd8-460616ea5400.png\" alt=\"Redis-is-map\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ERedis는 거대한 맵(Map) 데이터 저장소입니다.\u003C\u002Fli\u003E\n\u003Cli\u003ERedis는 익히기 쉬우며 직관적입니다. 그러나, 데이터를 레디스 자체 내에서는 처리하기 어렵습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"다양한-데이터-타입\"\u003E\u003Ca href=\"#%EB%8B%A4%EC%96%91%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E다양한 데이터 타입\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003EString, Set, Sorted Set, Hash, List\u003C\u002Fcode\u003E 등의 타입을 지원합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"persistence\"\u003E\u003Ca href=\"#persistence\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EPersistence\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133775761-c7644499-ae6f-4aa8-bd25-8208780c41e0.png\" alt=\"Redis-Persistence\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ERedis는 영속성을 가집니다.\u003C\u002Fli\u003E\n\u003Cli\u003ERedis는 데이터를 disk에 저장할 수 있습니다. 따라서 Redis는 서버가 강제 종료되고 재시작하더라도 disk에 저장해놓은 데이터를 다시 읽어서 데이터가 유실되지 않습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003Eredis의 데이터를 disk에 저장하는 방식은 \u003Cstrong\u003Esnapshot, AOF\u003C\u002Fstrong\u003E 방식이 있습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003ESnapshot\u003C\u002Fcode\u003E : RDB와 비슷하게 어떤 특정 시점의 데이터를 Disk에 담는 방식을 뜻합니다. \u003Cstrong\u003EBlocking\u003C\u002Fstrong\u003E 방식의 \u003Cstrong\u003ESAVE\u003C\u002Fstrong\u003E와 \u003Cstrong\u003ENon-blocking\u003C\u002Fstrong\u003E 방식의 \u003Cstrong\u003E\u003Ca href=\"http:\u002F\u002Fredisgate.kr\u002Fredis\u002Fserver\u002Fbgsave.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EBGSAVE\u003C\u002Fa\u003E\u003C\u002Fstrong\u003E 방식이 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode class=\"language-text\"\u003EAOF\u003C\u002Fcode\u003E : Redis의 모든 write\u002Fupdate 연산 자체를 모두 log 파일에 기록하는 형태입니다. 서버가 재시작 시 write\u002Fupdate를 순차적으로 재실행하고 데이터를 복구합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E가장 좋은 방식은 두 방법을 혼용해서 사용하는 방법으로 주기적으로 snapshot으로 백업을 하고 다음 snapshot까지의 저장을 AOF 방식으로 수행하는 방식입니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"ansi-c로-작성\"\u003E\u003Ca href=\"#ansi-c%EB%A1%9C-%EC%9E%91%EC%84%B1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EANSI C로 작성\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EC언어로 작성되어 Java와 같이 가상머신 위에서 동작하는 언어에서 발생하는 성능 문제에서 자유롭습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"서버측-복제-및-샤딩-지원\"\u003E\u003Ca href=\"#%EC%84%9C%EB%B2%84%EC%B8%A1-%EB%B3%B5%EC%A0%9C-%EB%B0%8F-%EC%83%A4%EB%94%A9-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E서버측 복제 및 샤딩 지원\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E읽기 성능 증대를 위해 서버 측 복제를 지원합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E쓰기 성능 증대를 위해 클라이언트 측 샤딩을 지원합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"redis의-장점\"\u003E\u003Ca href=\"#redis%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERedis의 장점\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E리스트, 배열과 같은 데이터를 처리하는데 유용합니다.\u003C\u002Fli\u003E\n\u003Cli\u003EMessage Queue, Shared Memory, Remote Dictionary(RDBMS의 캐시 솔루션 \u002F read 속도가 매우 빠릅니다.) 용도로 사용됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E메모리를 활용하면서 데이터를 보존합니다.\u003C\u002Fli\u003E\n\u003Cli\u003ERedis Server는 1개의 싱글 쓰레드로 수행되며, 서버 하나에 여러개의 서버를 띄우는 것이 가능합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"redis-아키텍처-구성\"\u003E\u003Ca href=\"#redis-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERedis 아키텍처, 구성\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003EHA(High Availability) : 무중단 서비스 등\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"standalone--no-ha-마스터\"\u003E\u003Ca href=\"#standalone--no-ha-%EB%A7%88%EC%8A%A4%ED%84%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EStandalone : No HA, 마스터\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133778042-cf59f712-752a-4c61-8a1a-b9ac435726a1.png\" alt=\"Redis-Standalone\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E레디스 서버 1대로 구성하며 이를 마스터 노드라고 합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E서버 다운시 AOF 또는 Snapshot 파일을 이용해 재 시작합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"replication--half-ha-마스터-슬레이브\"\u003E\u003Ca href=\"#replication--half-ha-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%AC%EB%A0%88%EC%9D%B4%EB%B8%8C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EReplication : Half HA, 마스터-슬레이브\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133778753-41bfa929-aa5f-48e5-9509-7e4df1379baa.png\" alt=\"Redis-Replication\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E레디스 서버 2대(마스터-슬레이브)로 구성됩니다. 슬레이브는 마스터의 데이터를 실시간으로 전달받아 보관합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E마스터 다운 시 슬레이브 서버를 통해 서비스를 계속할 수 있습니다. 하지만, 이때는 수동으로 슬레이브 서버를 마스터로 변경해야합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E한 마스터에 슬레이브를 여러 대 구성할 수 도 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"이중화--센티널sentinel--ha-무중단-서비스-가능\"\u003E\u003Ca href=\"#%EC%9D%B4%EC%A4%91%ED%99%94--%EC%84%BC%ED%8B%B0%EB%84%90sentinel--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E이중화 + 센티널(Sentinel) : HA, 무중단 서비스 가능\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133779960-5c97207f-75d7-405c-a4ea-730bba593e2d.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E마스터-슬레이브 구성에 \u003Cstrong\u003E센티널\u003C\u002Fstrong\u003E을 추가해서 각 서버를 감시하도록하며, 센티널은 마스터 서버를 감시하고 있다가 다운되면 슬레이브를 마스터로 승격시킵니다.\u003C\u002Fli\u003E\n\u003Cli\u003E다운된 마스터가 다시 시작되면 센티널이 슬레이브로 전환시킵니다.\u003C\u002Fli\u003E\n\u003Cli\u003E레디스 마스터 노드가 모든 데이터를 가지고 있으며 슬레이브는 마스터에 대한 복제본을 유지하고 있으며, 데이터를 분산하지 않습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E일반적으로 레디스 센티널은 레디스 서버마다 하나씩 설치하며, 레디스 서버와 분리된 프로세스이며 다른 포트를 사용합니다. (데이터를 처리하지 않습니다.)\u003C\u002Fli\u003E\n\u003Cli\u003E레디스 센티널은 높은 가용성과 자동 fail over 을 해결하지만 \u003Cstrong\u003E데이터 분산 문제를 해결하지 못합니다.\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fhub.docker.com\u002Fr\u002Ferichsu\u002Fredis-sentinel\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis Sentinel Docker\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"레디스-클러스터cluster--ha-무중단-서비스-가능\"\u003E\u003Ca href=\"#%EB%A0%88%EB%94%94%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0cluster--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E레디스 클러스터(Cluster) : HA, 무중단 서비스 가능\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133781464-16c21b85-1ca2-4e0f-8028-5acf9a37a2f8.png\" alt=\"Redis-Cluster-Type-1\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E머신 하나가 죽었을 시 해결이 됩니다. 다만 두개가 죽으면 해결이 안됩니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F133782017-fe094509-ed9a-419c-9739-35a766b4e334.png\" alt=\"Redis-Cluster-Type-2\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E위의 문제를 해결하는 방법입니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E샤딩\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E클라스터는 \u003Cstrong\u003E샤딩\u003C\u002Fstrong\u003E(sharding, 대량의 데이터를 처리하기 위해 여러 개의 데이터베이스에 분할하는 기술) 방법을 제공하는 방법입니다.\u003C\u002Fli\u003E\n\u003Cli\u003E100개의 데이터를 1번 마스터에 33개, 2번 마스터 33개, 3번 마스터에 나머지 34개가 저장되는 방식입니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003EHash 함수\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E데이터를 나누는 방식은 키에 hash 함수를 적용해서 값을 추출하고, 이 값을 각 마스터 서버에 할당합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E클러스터 구성시 해쉬 함수를 통해서 1~33까지를 1번 서버, 34~ 66번까지를 2번 서버, 3번 서버는 또 다르게 할당됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E해시 슬록(16384 슬롯)\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E레디스에서 hash 값의 개수는 16384(0~16383)이고 슬롯(slot)이라고 합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E해시 태그\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E다중 키 작업을 진행하려면 동일 노드에 저장될 모든 키가 필요합니다. 해시 태그는 레디스 클러스터에서 다중키를 사용할 수 있는 유일한 방법입니다.\u003C\u002Fli\u003E\n\u003Cli\u003E해시 함수를 적용해 동일한 해시 슬롯에 여러 개의 키 이름을 저장할 수 있도록 사용됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E레디스 클라이언트\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E클라이언트는 서버와 동일한 hash 함수를 가지고 있으며 마스터 서버에 접속해서 각 서버에 할당된 슬롯 정보를 가지고 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E키가 입력되면 hash 함수를 적용해서 어느 마스터에 저장할지 판단해서 해당 마스터에 저장합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Cstrong\u003E데이터 서버 + 센티널\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E각 마스터 서버는 데이터의 처리와 센티널의 역할을 같이수행합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E1번 마스터 서버가 다운되면 나머지 살아있는 마스터들 중에서 리더를 선출해서 리더가 1번 마스터의 슬레이브를 마스터로 승격시킵니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E최소 3대\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E마스터 서버는 최소 3대로 구성하고 각각은 슬레이브를 가질 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E마스터를 관리하는 마스터는 없습니다. 이는 또 하나의 장애점입니다.\u003C\u002Fli\u003E\n\u003Cli\u003E레디스가 사용하는 포트는 2개이며 하나는 클라이언트 하나는 노드 간의 통신을 위한 버스로 사용됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fjyejye9201.medium.com\u002F%EB%A0%88%EB%94%94%EC%8A%A4-redis-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-2b7af75fa818\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis란 무엇인가\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.redis.com\u002Flatest\u002Frs\u002Fconcepts\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis Concept\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fredisgate.kr\u002Fredis\u002Fconfiguration\u002Fredis_overview.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis Architecture Overview\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fcla9.tistory.com\u002F101\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis 구조\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fengkimbs.tistory.com\u002F869\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E레디스 소개 및 아키텍처, 주의할 점\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fcoding-start.tistory.com\u002F128\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis - Cluster &#x26; Sentinel\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fredis.io\u002Fcommands\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis Command\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fredis.com\u002Fredis-enterprise\u002Ftechnology\u002Fredis-enterprise-cluster-architecture\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERedis Enterprise Cluster Architecture\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}}]}}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.bcecea3f.js" defer></script><script src="/assets/js/page--src--templates--tag-vue.de8981a7.js" defer></script>
  </body>
</html>
