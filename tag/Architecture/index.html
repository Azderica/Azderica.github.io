<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Hello, world! - Azderica</title><meta name="gridsome:hash" content="409256f0cf4ba53e53b5c32326d49aab3f1f64f3"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="부족하지만 꿈많은 웹 개발자의 발전 기록입니다."><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.d0be325ebfe2762f973f3e0685345394.png"><link rel="preload" href="/assets/css/0.styles.00c517b5.css" as="style"><link rel="preload" href="/assets/js/app.5a286e2f.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--tag-vue.762abdba.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.b6200640.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.2e7dccb5.js"><link rel="prefetch" href="/assets/js/page--src--templates--post-vue.f3f1159d.js"><link rel="stylesheet" href="/assets/css/0.styles.00c517b5.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <script data-ad-client="ca-pub-1759762070891290" async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="google-site-verification" content="MqpGCz7XVg4s3AWfrGHCt6AlXPacpV9iGvSFVD0ATHw" />
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      (function() {
        window.__onThemeChange = function() {};
        function setTheme(newTheme) {
          window.__theme = newTheme;
          preferredTheme = newTheme;
          document.body.setAttribute('data-theme', newTheme);
          window.__onThemeChange(newTheme);
        }

        var preferredTheme;
        try {
          preferredTheme = localStorage.getItem('theme');
        } catch (err) { }

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme);
          try {
            localStorage.setItem('theme', newTheme);
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)');
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        });

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'));
      })();
    </script>

    <div id="app" data-server-rendered="true"><header class="header"><div class="header__left"><a href="/" class="logo active"><span class="logo__text">
    ← Azderica
  </span></a></div><div class="header__right"><button role="button" aria-label="Toggle dark/light" class="toggle-theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></header><main class="main"><h1 class="tag-title text-center space-bottom">
    # Architecture
  </h1><div class="posts"><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[Architecture] MSA : SAGA 패턴이란</h2><p class="post-card__description"> SAGA 패턴에 대해 정리합니다.</p><div class="post-meta post-card__meta">
   Posted 22. December 2020.
   <strong>7 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/01-architecture-msa/" class="post-card__link">Link</a></div></div><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[Architecture] MSA 개념 잡기</h2><p class="post-card__description"> 마이크로 서비스 아키텍처에 대한 개념을 정리합니다 </p><div class="post-meta post-card__meta">
   Posted 21. December 2020.
   <strong>4 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/00-architecture-msa/" class="post-card__link">Link</a></div></div><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">[Architeture] 서버리스 아키텍처에 대한 기초 지식</h2><p class="post-card__description"> 서버리스와 서버 아키텍처에 대한 기본 내용을 정리한 글입니다. </p><div class="post-meta post-card__meta">
   Posted 25. November 2020.
   <strong>13 min read.</strong></div><div class="post-tags post-card__tags"></div><a href="/00-architecture-serverless/" class="post-card__link">Link</a></div></div></div></main><footer class="footer"><span class="footer__copyright">Copyright © 2020. </span><span class="footer__links">Powered by <a href="//gridsome.org"> Gridsome </a></span></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"tag":{"title":"Architecture","belongsTo":{"edges":[{"node":{"title":"[Architecture] MSA : SAGA 패턴이란","path":"\u002F01-architecture-msa\u002F","date":"22. December 2020","timeToRead":7,"description":" SAGA 패턴에 대해 정리합니다.","content":"\u003Ch1 id=\"msa--saga-패턴의-정의과-종류\"\u003E\u003Ca href=\"#msa--saga-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A0%95%EC%9D%98%EA%B3%BC-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMSA : SAGA 패턴의 정의과 종류\u003C\u002Fh1\u003E\n\u003Cp\u003E이전에 MSA 개념에 대해 잡아보았습니다. 오늘은 MSA를 듣다보면 꼭 듣게 되는 SAGA 패턴에 대해 공부해보겠습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fazderica.github.io\u002F00-architecture-msa\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EMSA 개념 잡기\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"들어가기-앞서서\"\u003E\u003Ca href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%95%9E%EC%84%9C%EC%84%9C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E들어가기 앞서서.\u003C\u002Fh2\u003E\n\u003Cp\u003E기존의 Monolithic와 MSA 아키텍처에 대해서는 이전 게시글에서 정리했습니다. 오늘은 좀 더 MSA에 대해 이야기할려고 합니다. MSA 아키텍처를 구성하기 어려운 이유 중 하나는 \u003Cstrong\u003E트랜적션\u003C\u002Fstrong\u003E 의 문제입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E기존의 Monolithic 환경에서는 DBMS가 기본적으로 제공해주는 트랜잭선 기능을 통해서 데이터 commit이나 rollback을 통해서 일관성있게 관리하였습니다. 그러나 Applcation 과 DB가 분산되면서 해당 트랜잭션 처리를 단일 DBMS에서 제공하는 기능으로는 해결할 수 없습니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"대안--two-phase-commit\"\u003E\u003Ca href=\"#%EB%8C%80%EC%95%88--two-phase-commit\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E대안 : Two-Phase Commit?\u003C\u002Fh3\u003E\n\u003Cp\u003E여러 서비스 간에 데이터 일관성을 유지하기 위해서 전통적인 방법인 Two-Phase commit 과 같은 방법을 사용했습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102893652-4f8f0e00-44a5-11eb-9f1a-f4d3508e6c97.png\" alt=\"two-phase commit\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E다만 이 방법은 하나의 서비스가 장애가 있는 경우나 각각의 서비스에 동시에 Rocking이 걸리게 되면 성능의 문제가 발생하기 때문에 비효율적입니다. 더나아가 각각의 서비스가 다른 instance에 있기 때문에 이를 통제하는데 어려움이 있습니다.\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E트랜잭션이란?\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E트랜잭션이란 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위를 의미합니다. 트랜잭션은 4가지의 특성(원자성, 일관성, 독립성, 지속성)을 지켜야합니다. 이에 대해 상세하게 다루기에는 주제에 너무 벗어난 주제이기 때문에 다른 게시글로 정리하겠습니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"saga-패턴의-정의\"\u003E\u003Ca href=\"#saga-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESAGA 패턴의 정의\u003C\u002Fh2\u003E\n\u003Cp\u003E위의 문제를 해결하기 위해서 SAGA 패턴이 등장했습니다.\u003C\u002Fp\u003E\n\u003Cp\u003ESAGA 패턴이란 \u003Cstrong\u003E마이크로서비스들끼리 이벤트를 주고 받아 특정 마이크로서비스에서의 작업이 실패하면 이전까지의 작업이 완료된 마이크서비스들에게 보상 (complemetary) 이벤트를 소싱함으로써 분산 환경에서 원자성(atomicity)을 보장\u003C\u002Fstrong\u003E하는 패턴입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이를 그림으로 표현하면 다음과 같습니다. SAGA 패턴의 이벤트 성공 시는 다음과 같이 동작합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102894284-33d83780-44a6-11eb-9cb0-1c526edd5642.png\" alt=\"saga-pattern-success\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ESAGA 패턴의 이벤트 실패 시는 다음과 같이 실패 이벤트를 주어 처리합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102894291-35a1fb00-44a6-11eb-93bf-2371f322c99c.png\" alt=\"saga-pattern-fail\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E해당 SAGA 패턴의 핵심은 \u003Cstrong\u003E트랜잭션의 관리주체가 DBMS에 있는 것이 아닌 Application\u003C\u002Fstrong\u003E에 있습니다. Application이 분산되어 있을때는 각 Applicatin은 하위에 존재하는 DB는 local 트랜잭션만 담당합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E즉, 각각의 Application의 트랜잭션 요청의 실패로 인한 Rollback 처리(보상 트랜잭션)은 Application에서 구현합니다. \u003C\u002Fp\u003E\n\u003Cp\u003E이러한 과정을 통해서 순차적으로 트랜잭션이 처리되며, 마지막 트랜잭션이 끝났을 때 데이터가 완전히 영속되었음을 확인하고 종료합니다. 이 방법을 통해서 최종 일관성(Eventually Consistency)를 달성할 수 있습니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"saga-패턴의-종류\"\u003E\u003Ca href=\"#saga-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESAGA 패턴의 종류\u003C\u002Fh2\u003E\n\u003Cp\u003E일반적으로 SAGA 패턴은 크게 2가지로 나누어집니다. 하나는 \u003Cstrong\u003EChoreography based SAGA pattern\u003C\u002Fstrong\u003E이고 다른 하나는 \u003Cstrong\u003EOrchestration based SAGA pattern\u003C\u002Fstrong\u003E입니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"choreography-based-saga-pattern\"\u003E\u003Ca href=\"#choreography-based-saga-pattern\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EChoreography based SAGA pattern\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102895303-ccbb8280-44a7-11eb-8b80-8b87630db5f5.png\" alt=\"Choreography-Based Saga Success\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EChoreography-based Saga 패턴은 보유한 서비스 내의 Local 트랜잭션을 관리하며 트랜잭션이 종료하게 되면 완료 Event를 발행합니다. 만약 그 다음 수행해야할 트랜잭션이 있으면 해당 트랜잭션을 수행해야하는 App으로 이벤트를 보내고, 해당 App은 완료 Event를 수신받고 다음 작업을 진행합니다. 이를 순차적으로 수행합니다. 이때 Event는 Kafka와 같은 메시지 큐를 통해서 비동기 방식으로 전달할 수 있습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102895310-cf1ddc80-44a7-11eb-9941-de72656dd3a8.png\" alt=\"Choreography-Based Saga Fail\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EChoreography-base Saga 패턴에서는 각 App별로 트랜잭션을 관리하는 로직이 있습니다. 이를 통해서 중간에 트랜잭션이 실패하면 해당 트랜잭션 취소 처리를 실패한 App에서 보상 Event를 발행해서 Rollback 처리를 시도합니다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"장점\"\u003E\u003Ca href=\"#%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E장점\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E구성하기 편합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"단점\"\u003E\u003Ca href=\"#%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E단점\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E운영자 입장에서 트랜잭션의 현재 상태를 확인하기 어렵습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"orchestration-based-saga-pattern\"\u003E\u003Ca href=\"#orchestration-based-saga-pattern\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EOrchestration based SAGA pattern\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102895290-c927fb80-44a7-11eb-88ee-8f08ec4b2c21.png\" alt=\"Orchestration-Based Saga Success\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EOrchestration-Based Saga 패턴은 트랜잭션 처리를 위해 Saga 인스턴스(Manager)가 별도로 존재합니다. 트랜잭션에 관여하는 모든 App은 Manager에 의해 점진적으로 트랜잭션을 수행하며 결과를 Manager에게 전달하게 되고, 비지니스 로직상 마지막 트랜잭션이 끝나면 Manager를 종료해서 전체 트랜잭션 처리를 종료합니다. 만약 중간에 실패하게 되면 Manager에서 보상 트랜잭션을 발동하여 일관성을 유지합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102895323-d47b2700-44a7-11eb-9bc1-2c46cf517c06.png\" alt=\"Orchestration-Based Saga Fail\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E해당 Orchestration-Based Saga 패턴은 모든 관리를 Manager가 호출하기 때문에 분산트랜잭션의 중앙 집중화가 이루어집니다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"장점-1\"\u003E\u003Ca href=\"#%EC%9E%A5%EC%A0%90-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E장점\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E서비스간의 복잡성이 줄어들어서 구현 및 테스트가 쉬워집니다.\u003C\u002Fli\u003E\n\u003Cli\u003E트랜잭션의 현재 상태를 Manager가 알고 있으므로 롤백을 하기 쉽습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"단점-1\"\u003E\u003Ca href=\"#%EB%8B%A8%EC%A0%90-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E단점\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E관리를 해야하는 Orchestrator 서비스가 추가되어야하기 때문에 인프라 구현이 복잡해집니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"마무리\"\u003E\u003Ca href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E마무리\u003C\u002Fh2\u003E\n\u003Cp\u003EMSA 아키텍처 중 가장 유명한 SAGA 패턴에 대해 알아보았습니다. 다만 항상 SAGA 패턴이 좋다고는 볼 수 없습니다. 비지니스 로직상 트랜잭션 처리가 반드시 필요한 경우에만 사용하는 것이 좋습니다. 그렇지 않으면 여러곳에서 트랜잭션 처리 지옥을 경험할 수 있기 때문에 필요한 곳에서만 사용할 수 있도록 비지니스 로직을 설계하고 사용하는 것이 좋습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E다음 게시글에서는 CQRS 패턴에 대해서 정리해보겠습니다. 감사합니다.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fjjeongil.tistory.com\u002F1100\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fjjeongil.tistory.com\u002F1100\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fcla9.tistory.com\u002F22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fcla9.tistory.com\u002F22\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvelog.io\u002F@dvmflstm\u002FSAGA-pattern%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fvelog.io\u002F@dvmflstm\u002FSAGA-pattern%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fichi.pro\u002Fko\u002Fmaikeulo-seobiseu-akitegcheo-saga-paeteon-ilan-mueos-imyeo-eolmana-jung-yohabnikka-94512583990635\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fichi.pro\u002Fko\u002Fmaikeulo-seobiseu-akitegcheo-saga-paeteon-ilan-mueos-imyeo-eolmana-jung-yohabnikka-94512583990635\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}},{"node":{"title":"[Architecture] MSA 개념 잡기","path":"\u002F00-architecture-msa\u002F","date":"21. December 2020","timeToRead":4,"description":" 마이크로 서비스 아키텍처에 대한 개념을 정리합니다 ","content":"\u003Ch1 id=\"microservice-architecture\"\u003E\u003Ca href=\"#microservice-architecture\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMicroservice Architecture\u003C\u002Fh1\u003E\n\u003Cp\u003E크게 아키텍처는 Monolithic Architecture과 Microservice Architecture 등으로 구성됩니다. 그러나 많은 회사들이 Monolithic 아키텍처의 단점으로 인해 MSA 아키텍처로 넘어가기 위해 노력하려고 합니다. 오늘은 그 차이에 대해 정리하고, 그 개념에 대해 정리해볼려고 합니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"msa의-등장\"\u003E\u003Ca href=\"#msa%EC%9D%98-%EB%93%B1%EC%9E%A5\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMSA의 등장\u003C\u002Fh2\u003E\n\u003Cp\u003EMSA는 microservice architecture의 약자로서, \u003Cstrong\u003E하나의 큰 어플리케이션을 여러개의 작은 어플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처\u003C\u002Fstrong\u003E 입니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"기존-monolithic의-한계\"\u003E\u003Ca href=\"#%EA%B8%B0%EC%A1%B4-monolithic%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E기존 Monolithic의 한계\u003C\u002Fh3\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E왜 필요할까요?\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E기존의 서비스는 Monolithic Architecture의 구조를 가지고 있었습니다. \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102787038-cebc0d80-43e3-11eb-9a67-829adb6ebe51.png\" alt=\"monolithic-vs-msa\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EMonolithic Architecture은 소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어 있는 서비스입니다. 현재 많은 회사들의 소프트웨어가 \u003Cstrong\u003E레거시\u003C\u002Fstrong\u003E 또는 필요로 인해서 Monolithic 형태로 구현되어 있습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E소규모의 프로젝트에서는 Monolithic 형태는 간단하며, 유지보수가 편하기 때문에 선호됩니다.\u003C\u002Fp\u003E\n\u003Cp\u003E그러나 일정 규모 이상을 넘어가면 Monolithic은 많은 한계점에 봉착합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E전체 시스템 구조 파악의 문제\u003C\u002Fli\u003E\n\u003Cli\u003E빌드 시간 및 테스트, 배포 시간의 급증\u003C\u002Fli\u003E\n\u003Cli\u003E서비스의 특정 부분만 scale-out을 하기 어렵습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E부분의 장애가 전체 서비스의 장애로 이어질 수도 있습니다.\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E이러한 이유로 인해서, MSA가 등장하게 되었습니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"msa의-정의\"\u003E\u003Ca href=\"#msa%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMSA의 정의\u003C\u002Fh2\u003E\n\u003Cp\u003EMSA의 핵심은 \u003Cstrong\u003Esmall services, each running in its own process\u003C\u002Fstrong\u003E + \u003Cstrong\u003Eindependently deployable\u003C\u002Fstrong\u003E 으로 표현할 수 있습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이를 번역한다면, \u003Cstrong\u003E스스로 돌아갈 수 있는 서비스\u003C\u002Fstrong\u003E와 \u003Cstrong\u003E독립적인 배포 기능\u003C\u002Fstrong\u003E입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102787740-e8118980-43e4-11eb-8760-c52424630810.png\" alt=\"architecture-diff\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003Esoa를 추가해서 좀 더 자세하게 보자면.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F102787984-4474a900-43e5-11eb-8a27-4e60f3aecfca.png\" alt=\"architecture-diff-2\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E다음과 같이 구성됩니다.\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"msa의-장단점\"\u003E\u003Ca href=\"#msa%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMSA의 장단점\u003C\u002Fh2\u003E\n\u003Ch3 id=\"msa의-장점\"\u003E\u003Ca href=\"#msa%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMSA의 장점\u003C\u002Fh3\u003E\n\u003Ch4 id=\"1-배포\"\u003E\u003Ca href=\"#1-%EB%B0%B0%ED%8F%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. 배포\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E서비스 별 개별 배포가 가능합니다. (배포 시 전체 서비스의 중단이 없습니다.)\u003C\u002Fli\u003E\n\u003Cli\u003E요구사항을 반영하여 빠르게 배포 가능합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"2-확장\"\u003E\u003Ca href=\"#2-%ED%99%95%EC%9E%A5\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2. 확장\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E특정 서비스에 대한 확장성이 유리합니다. (scale-out)\u003C\u002Fli\u003E\n\u003Cli\u003E클라우드 사용 시 적합합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"3-장애-해결error-handling\"\u003E\u003Ca href=\"#3-%EC%9E%A5%EC%95%A0-%ED%95%B4%EA%B2%B0error-handling\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. 장애 해결(Error Handling)\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E일부 장애가 전체 서비스로 확장될 가능성이 적습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E부분적으로 발생하는 장애에 대해 격리가 수월합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"4-그-외\"\u003E\u003Ca href=\"#4-%EA%B7%B8-%EC%99%B8\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E4. 그 외\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E새로운 기술을 적용하기 유연합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E서비스를 polyglot(여러 언어를 사용하여)하게 개발 및 운영할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"msa의-단점\"\u003E\u003Ca href=\"#msa%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMSA의 단점\u003C\u002Fh3\u003E\n\u003Ch4 id=\"1-성능-이슈\"\u003E\u003Ca href=\"#1-%EC%84%B1%EB%8A%A5-%EC%9D%B4%EC%8A%88\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. 성능 이슈\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E서비스 간 호출 시 API를 사용하므로, 통신 비용이나 Latency에 대해 이슈가 존재합니다. 다만 일반적으로 Monolithic에서 MSA로 넘어오는 이유가 Monolithic으로 더이상 성능적인 한계에 봉착했을 때 넘어오는 느낌이 있습니다...\u003C\u002Fli\u003E\n\u003Cli\u003E최근 우아한 테크 컨퍼런스에서는 이벤트 발행을 통해서 해당 부분을 해결했다고 했는데 이부분은 한번 참고해서 보면 좋을 듯 합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"2-테스트--트랜잭션\"\u003E\u003Ca href=\"#2-%ED%85%8C%EC%8A%A4%ED%8A%B8--%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2. 테스트 \u002F 트랜잭션\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E서비스가 분리되어 있어 테스트와 트랜잭션의 복잡도가 증가합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E많은 자원이 필요합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"3-데이터-관리\"\u003E\u003Ca href=\"#3-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. 데이터 관리\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E데이터가 여러서비스에 분산되어 조회하기 어렵습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E데이터를 관리하기 어렵습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"마무리\"\u003E\u003Ca href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E마무리.\u003C\u002Fh2\u003E\n\u003Cp\u003E간단하게 MSA에 대해 개념을 잡았습니다. 다음에는 이 MSA에 대한 개념을 바탕으로 SAGA 패턴과 CQRS 패턴에 대해 작성하겠습니다.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvelog.io\u002F@tedigom\u002FMSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fvelog.io\u002F@tedigom\u002FMSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.samsungsds.com\u002Fkr\u002Finsights\u002Fmsa.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fwww.samsungsds.com\u002Fkr\u002Finsights\u002Fmsa.html\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}},{"node":{"title":"[Architeture] 서버리스 아키텍처에 대한 기초 지식","path":"\u002F00-architecture-serverless\u002F","date":"25. November 2020","timeToRead":13,"description":" 서버리스와 서버 아키텍처에 대한 기본 내용을 정리한 글입니다. ","content":"\u003Ch1 id=\"서버리스-아키텍처에-대하여\"\u003E\u003Ca href=\"#%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E서버리스 아키텍처에 대하여\u003C\u002Fh1\u003E\n\u003Cp\u003E회사에서 개발과 관련해서 이야기를 하는데, CaaS, FaaS, BaaS 등에 대한 이야기를 듣게 되었다. 생각해보니 이름만 들어보고 한 번도 제대로 알아본적이 없어서 이번기회에 정리합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E서버리스(Serverless)란 말 그대로 서버가 없다는 의미는 아닙니다. 다만, 특정 작업을 수행하기 위해서 컴퓨터 혹은 가상머신에 서버를 설정할 필요없이 다른 서비스(BaaS, FaaS) 등에 의존해서 작업을 처리합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F100229273-5474a680-2f67-11eb-8a3a-467c9f409a72.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E들어가기에 앞서서 간단한 발전 과정은 다음과 같습니다.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E\u003Cbr\u002F\u003E\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"기존-애플리케이션\"\u003E\u003Ca href=\"#%EA%B8%B0%EC%A1%B4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E기존 애플리케이션\u003C\u002Fh2\u003E\n\u003Ch3 id=\"1-자체-설계\"\u003E\u003Ca href=\"#1-%EC%9E%90%EC%B2%B4-%EC%84%A4%EA%B3%84\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. 자체 설계\u003C\u002Fh3\u003E\n\u003Cp\u003E시스템에서 필요한 모든 인프라를 직접 관리합니다. 기존의 \u003Cstrong\u003E전산실\u003C\u002Fstrong\u003E로 이해하면 됩니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E필요한 모든 인프라를 직접 관리. 예를 들어 기업 전산실에서 서버 및 하드웨어, 네트워크, 운영체제 등을 갖추어 모두 직접 처리해야합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E시스템이 커질 수록 유지할 관리자가 필요하고, 이에 따른 비용이 발생합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"2-iaasinfrastructure-as-a-service\"\u003E\u003Ca href=\"#2-iaasinfrastructure-as-a-service\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2. IaaS(Infrastructure as a Service)\u003C\u002Fh3\u003E\n\u003Cp\u003EAWS, Azure 등의 서비스에서 제공하는 서비스입니다. 서버자원, 네트워크, 전력 등의 인프라를 직접 구축할 필요없이 이러한 \u003Cstrong\u003E인프라를 가상화\u003C\u002Fstrong\u003E하여 관리하기 쉽게 해주는 서비스를 제공합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E사용자는 해당 서비스를 통해서 관리자패널에서 인프라를 구성하면 됩니다. 사용자는 가상머신을 만들고 네트워크를 설정하고, 하드웨어를 설정하고, 운영체제를 설치해서 애플리케이션을 구동합니다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"3-paasplatform-as-a-service\"\u003E\u003Ca href=\"#3-paasplatform-as-a-service\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. PaaS(Platform as a Service)\u003C\u002Fh3\u003E\n\u003Cp\u003EIaaS에서 좀 더 추상화된 모델입니다. 네트워크, OS, 런타임을 제공합니다. 사용자는 애플리케이션만 배포하면 바로 구동할 수 있습니다. 또한 Auto Scaling 및 Load Balacing도 손쉽게 적용가능합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E예시로는 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAWS Elastic Beanstalk, Azure App Servies 등등\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"servless\"\u003E\u003Ca href=\"#servless\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EServless\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E서버리스는 애플리케이션 개발자가 서버를 프로비저닝하거나 애플리케이션의 확장을 관리할 필요가 없습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E프로비저닝(Provisioning) : 사용자의 요구에 맞게 시스템을 할당하고 배치, 배포한 이후 필요시에 시스템을 즉시 사용할 수 있는 상태로 미리 준비해놓는 것입니다.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cul\u003E\n\u003Cli\u003E서버가 없다는 뜻은 아니며, 작업을 처리하는 서버는 있지만 서버를 관리할 필요가 없습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E대표적으로 \u003Cstrong\u003EBaaS\u003C\u002Fstrong\u003E 와 \u003Cstrong\u003EFaaS\u003C\u002Fstrong\u003E로 나눠집니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"1-baasbackend-as-a-service\"\u003E\u003Ca href=\"#1-baasbackend-as-a-service\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. BaaS(Backend as a Service)\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F100353200-82beb880-3031-11eb-89d9-5a361d5f88c4.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E애플리케이션에서 일반 사용자가 보는 영역은 프론트엔드, 관리자가 보는 영역은 백엔드로 불립니다. \u003Cstrong\u003E이때 BaaS는 백엔드인 관리자 영역을 모듈화하여 서비스\u003C\u002Fstrong\u003E로 제공합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E백엔드 개발(데이터 저장, 다른 기기로 접근, 파일 공유 등)이 필요한 경우, 개발자가 이러한 모든 서비스를 구축하기 어려워서, BaaS를 통해서 개발 시간을 단축합니다.\u003C\u002Fli\u003E\n\u003Cli\u003EIaaS, PaaS가 서버 인프라를 대체하는 정도였다면, \u003Cstrong\u003EBaaS와 FaaS는 서버 운영까지 맡기는 서비스\u003C\u002Fstrong\u003E입니다.\u003C\u002Fli\u003E\n\u003Cli\u003E대표적인 서비스로는 \u003Cstrong\u003EFirebase\u003C\u002Fstrong\u003E가 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E장점\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E개발 시간의 단축\u003C\u002Fli\u003E\n\u003Cli\u003E서버 확장의 불필요함\u003C\u002Fli\u003E\n\u003Cli\u003E백엔드에 대한 지식이 부족하더라도 빠른 속도로 개발이 가능\u003C\u002Fli\u003E\n\u003Cli\u003E토이 프로젝트, 소규모 프로젝트에서는 백엔드로 유용하게 사용가능\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E단점\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E클라이언트 위주의 코드\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E백엔드 로직이 클라이언트 쪽에 구현됨 (보안 등의 큰 이슈)\u003C\u002Fli\u003E\n\u003Cli\u003EFirebase SDK를 통해 서버쪽에서 개발할 수 있지만, 이보다는 직접 구현이 좋습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E데이터단의 로직이 변경되면 클라이언트 코드 수정이 이루어집니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E가격\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EFirebase의 경우 초반에는 무료이지만, 앱의 규모가 커지면 비싸집니다.\u003C\u002Fli\u003E\n\u003Cli\u003E서비스 규모가 늘어날 수록 직접 구현의 장점이 가능합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E복잡한 쿼리가 불가능함\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EFirebase는 데이터 베이스가 하나의 큰 Json 형식으로 구조화 되어 있습니다. \u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"2-faasfunction-as-a-service\"\u003E\u003Ca href=\"#2-faasfunction-as-a-service\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2. FaaS(Function as a Service)\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F100354291-468c5780-3033-11eb-8d18-e6b0ba4fdf20.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E코드, \u003Cstrong\u003E함수\u003C\u002Fstrong\u003E를 서비스로 제공합니다. 애플리케이션 개발에서 함수를 실행하기 위해 서버를 올리고 런타임을  구성하고 코드를 배포해서 실행해야 하는 일련의 과정을 없애고 원하는 로직을 함수로 등록만 해놓으면 특정 이벤트시 함수가 실행되고 종료됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E서버가 계속 대기하면서 사용자의 요청하는 것이 아니라, 이벤트가 발생했을 때만 함수가 실행되기 때문에 함수가 실행되는 시간 및 호출된 횟수만큼만 비용을 지불합니다.\u003C\u002Fli\u003E\n\u003Cli\u003EPaaS의 경우는 전체 애플리케이션을 배포하여 서버에서 애플리케이션이 계속 돌아가지만, FaaS는 애플리케이션을 더 작게 쪼갠 함수를 배포하며, 특정 이벤트가 발생했을 때만 실행되고 종료됩니다.\u003C\u002Fli\u003E\n\u003Cli\u003E주로 서비스 사이의 간단한 작업을 처리하는 용도로 쓰이며, BaaS와 결합해서 사용하기 좋습니다. 대표적인 예시로는 AWS Lambda, 구글의 Knative, Nuclio 등이 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E장점\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E비용\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E특정 작업을 하기위해 서버를 준비하고 켜놓는 것이 아니라면, 필요시만 호출되기 때문에 많은 비용을 절감할 수 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E인프라 관리\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E네트워크, 장비 등에 대해 신경쓸 필요가 없습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E인프라 보안\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E리눅스 업데이트, 취약점 보안 패치 등에 큰 신경을 쓰지 않다도 됩니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E확장성\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E확장성에서 굉장히 유연합니다. (AutoScaling 등의 필요없습니다. 그저 호출만 될뿐...)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E단점\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E제한\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E함수에서 사용할 수 있는 자원의 제한이 존재합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E웹소켓과 같이 계속 켜놓는 것은 사용하기 힘듭니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E제공사에 대한 강한 의존\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E로컬 데이터 사용 불가능\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E함수들은 무상태이기 때문에 이 데이터를 로컬 스토리지에 쓸수없습니다. (물론, AWS는 S3, Azure는 Storage를 사용 가능합니다.)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"3-정리\"\u003E\u003Ca href=\"#3-%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E3. 정리\u003C\u002Fh3\u003E\n\u003Cp\u003EServerless의 특징은 다음과 같습니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003ECold Start\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E클라우드 업체는 자원을 효율적으로 관리하기 위해 일정 기간 행위가 없는 사용자에게는 컴퓨팅 파워를 제공하지않습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E비활성 함수가 갑자기 호출되면 서버가 준비되는 지연 시간이 발생하여 애플리케이션 성능에 영향을 줄 수도 있습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EStateless\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E함수가 없는 경우에는 모든 리소스 종류가 존재하지 않습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E세션을 보존해야하는 경우에는 DB에 저장하는 것이 좋습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E일시적 컨테이너\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E특정 이벤트가 발생하는 일정 기간 동안에만 컨테이너에 배포되고, 그 이후는 자원이 없습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E큰 요구사항이 필요한 경우에는 적합하지 않습니다.\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E언어지원\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAWS Lambda: Node.js, Python, Java, C#, Go\u003C\u002Fli\u003E\n\u003Cli\u003EMS Azure: C#, Javascript, F#, Python, Batch, PHP, PowerShell\u003C\u002Fli\u003E\n\u003Cli\u003EGoogle Function: Node.js, Python, Javascript\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003ENoSQL\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E함수는 제한된 데이터베이스 색인(Index)을 구성하기 때문에 서버리스 아키텍처에서 관계형 데이터베이스를 사용하면 동시 연결 수 제한으로 확장성과 성능 문제가 발생합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E따라서 RDBMS 보다는 \u003Cstrong\u003ENoSQL\u003C\u002Fstrong\u003E이 적합합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E그러나. 현재는 Stateless, 일시적 컨테이너에 따른 특징으로 인해 \u003Cstrong\u003E큰 프로젝트에는 적합하지 않습니다.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"그-외\"\u003E\u003Ca href=\"#%EA%B7%B8-%EC%99%B8\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E그 외.\u003C\u002Fh2\u003E\n\u003Ch3 id=\"1-caascontainer-as-as-service\"\u003E\u003Ca href=\"#1-caascontainer-as-as-service\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E1. CaaS(Container as as Service)\u003C\u002Fh3\u003E\n\u003Cp\u003E컨테이너 기반 추상화를 통해 사용자가 애플리케이션을 배포하고 관리하도록 지원하는 클라우드 서비스 컴퓨팅 모델입니다. 제공없체는 컨테이너가 배포 및 관리되는 프레임워크 또는 오케스트레이션 플랫폼을 제공합니다.\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E오케스트레이션(orchestration)이란?\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EContainer orchestration이란 컨테이너의 배포, 관리, 확장 및 네트워킹을 자동화합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E클라우드 서비스의 범위에서 CaaS는 IaaS의 하위집합으로 간주되며 I\u003Cstrong\u003EaaS와 서비스 플랫폼인 PaaS 사이\u003C\u002Fstrong\u003E에 존재한다고 이해하면 됩니다.\u003C\u002Fp\u003E\n\u003Cp\u003E컨테이너를 사용하므로 다음과 같은 특징을 가집니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E이식성 : private, public 등의 다양한 환경에서 배포가능\u003C\u002Fli\u003E\n\u003Cli\u003E확장성 : 컨테이너의 수를 늘려서 확장할 수 있습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E효율성 : 컨테이너는 별도의 운영체제가 필요없으므로 가상 머신(VM)보다 리소스가 적게 필요합니다.\u003C\u002Fli\u003E\n\u003Cli\u003E보안강화 : 컨테이너는 격리되어 있으므로 다른 컨테이너에 영향을 주지 않습니다.\u003C\u002Fli\u003E\n\u003Cli\u003E속도 : 운영 체제에 구애받지 않기 때문에 시작과 종료시간이 짧습니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E이와 같은 환경에서는 \u003Cstrong\u003E쿠버네티스\u003C\u002Fstrong\u003E를 사용하는 것이 좋습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E쿠버네티스에 대한 간단한 정리는 아래의 링크를 보시면 좋을 듯합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E: \u003Ca href=\"https:\u002F\u002Fazderica.github.io\u002Fbackend\u002F2020\u002F11\u002F10\u002Fbackend-kubernetes-study\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E쿠버네티스란?\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"2dbaasdatabase-as-a-service\"\u003E\u003Ca href=\"#2dbaasdatabase-as-a-service\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E2.DBaaS(Database as a Service)\u003C\u002Fh3\u003E\n\u003Cp\u003EDBaaS는 \u003Cstrong\u003E클라우드 아키텍처\u003C\u002Fstrong\u003E로서 데이터베이스 서비스 프로바이더가 하나 아싱의 서비스 소비자에게 데이터베이스 서비스를 제공하는 아키텍처, 운영 전략입니다.\u003C\u002Fp\u003E\n\u003Cp\u003E다음과 같은 요구사항을 만족합니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E리소스의 빠른 제공 및 Self-Service 동작, 데이터베이스 관리\u003C\u002Fli\u003E\n\u003Cli\u003E데이터베이스 서비스 사용량에 기반한 Show-back 리포트와 Charge-back 기능을 제공합니다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E이러한 특성을 바탕으로 DBaaS는 클라우드 서비스를 통해 자원의 탄력적인 운용과 확장가능, 자동화된 자원 관리, 용량 설정 및 설계의 기능을 제공합니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이러한 기능은 다음의 장점을 가집니다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E비용절감\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E서비스 수준향상\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ESelf-Service Provising, 관리\u003C\u002Fli\u003E\n\u003Cli\u003E미리 약속된 서비스 정의\u003C\u002Fli\u003E\n\u003Cli\u003EMetering 및 Chargeback을 통한 IT 비용 및 활용도 측정 가능\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cbr\u002F\u003E\n\u003Ch2 id=\"정리\"\u003E\u003Ca href=\"#%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E정리.\u003C\u002Fh2\u003E\n\u003Cp\u003E간단하게 서버리스 아키텍처에 대해 정리하였습니다. 흔히 듣던, IaaS, BaaS, PaaS, FaaS에 대해 간단하게 정리해보았고, 최근에 들었던 CaaS에 대해서도 간단하게 조사했습니다.\u003C\u002Fp\u003E\n\u003Cp\u003E이후 부족한 내용이나 보완되어야하는 내용이 있다면 편하게 이야기주세요.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E출처\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvelopert.com\u002F3543\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fvelopert.com\u002F3543\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fstonesteel1023.github.io\u002FTIL181109\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fstonesteel1023.github.io\u002FTIL181109\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fm.blog.naver.com\u002FPostView.nhn?blogId=shakey7&#x26;logNo=221739057486&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fm.blog.naver.com\u002FPostView.nhn?blogId=shakey7&#x26;logNo=221739057486&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.redhat.com\u002Fko\u002Ftopics\u002Fcloud-computing\u002Fwhat-is-caas\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fwww.redhat.com\u002Fko\u002Ftopics\u002Fcloud-computing\u002Fwhat-is-caas\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}}]}}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.5a286e2f.js" defer></script><script src="/assets/js/page--src--templates--tag-vue.762abdba.js" defer></script>
  </body>
</html>