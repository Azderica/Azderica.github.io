<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>[Review] Clean Code 내용정리 - 4 - Azderica</title><meta name="gridsome:hash" content="fc6e29a67ddc38efe16f045a3de184da00f36a74"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="부족하지만 꿈많은 웹 개발자의 발전 기록입니다."><meta data-vue-tag="ssr" name="description" content=" Clean code 책 정리 4편입니다. "><link rel="preload" href="/blog/assets/css/0.styles.4ccc9e1d.css" as="style"><link rel="preload" href="/blog/assets/js/app.672b1d96.js" as="script"><link rel="preload" href="/blog/assets/js/page--src--templates--post-vue.238f89b8.js" as="script"><link rel="prefetch" href="/blog/assets/js/page--node-modules--gridsome--app--pages--404-vue.b6200640.js"><link rel="prefetch" href="/blog/assets/js/page--src--pages--index-vue.41e1013f.js"><link rel="prefetch" href="/blog/assets/js/page--src--templates--tag-vue.7eab7acd.js"><link rel="stylesheet" href="/blog/assets/css/0.styles.4ccc9e1d.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      (function() {
        window.__onThemeChange = function() {};
        function setTheme(newTheme) {
          window.__theme = newTheme;
          preferredTheme = newTheme;
          document.body.setAttribute('data-theme', newTheme);
          window.__onThemeChange(newTheme);
        }

        var preferredTheme;
        try {
          preferredTheme = localStorage.getItem('theme');
        } catch (err) { }

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme);
          try {
            localStorage.setItem('theme', newTheme);
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)');
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        });

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'));
      })();
    </script>

    <div id="app" data-server-rendered="true"><header class="header"><div class="header__left"><a href="/blog/" class="logo active"><span class="logo__text">
    ← Azderica
  </span></a></div><div class="header__right"><button role="button" aria-label="Toggle dark/light" class="toggle-theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></header><main class="main"><div class="post-title"><h1 class="post-title__text">
      [Review] Clean Code 내용정리 - 4
    </h1><div class="post-meta">
   Posted 6. November 2020.
   <strong>26 min read.</strong></div></div><div class="post content-box"><div class="post__header"><img alt="Cover image" src="data:image/svg+xml,%3csvg fill='none' viewBox='0 0 860 1021' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-2da16ebb829634911838dadcc8b5c487'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='10'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-2da16ebb829634911838dadcc8b5c487)' width='860' height='1021' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCABMAEADASIAAhEBAxEB/8QAGwAAAgMBAQEAAAAAAAAAAAAABAUCAwYAAQj/xAAxEAACAQMDAQUGBgMAAAAAAAABAgMABBESITFBBRMzUWEGFCIycZEVFkKhwfBigdH/xAAXAQEBAQEAAAAAAAAAAAAAAAAAAQID/8QAGREBAQEBAQEAAAAAAAAAAAAAAAERAhIx/9oADAMBAAIRAxEAPwD6pql7qGN9MkiISwUamAyT0HnV1Y3tiCS59tOzkjkChAJCp2yFck9M8Cg15lUSBCy6z0zUs45BoK57v3kh2YEqMHoDvjNeESKpMc4YBR%2brJ/vO9Y9NYO1L517zS3XdBA2nVnG2K8jllaTS8enrkZqzpMM66s1e%2b01lZSrG8szMXKHRGTpx1OenTIrRQsWiVjya0idJrm3mk7Zs54XjWOGR%2b9VlGp1ZMAA488HGRTms9f3fc%2b03ZdqIo3Ny8xLMCSoRAdug%2bYc5/mgZ3LYuWHdhgUGojkDf7VVKIWViupWIGAw2/vFM8A8gb1XJDGynKgEjGQOlc7xrUpYyR7aJ9OOdiOagQ%2b%2bi6Ugf5f8AaOa1i0BdJwPWqJLSI9D96eaaDlE2j41jkXyIDU7tvAT6UpazQHZmA8qbW3gJWuZZ9SrKzPaXdfm7sQsjNMDchCGwACi6tsb9Oo/3xWmpPN2Wl327Z9oNLIr2JlCovyv3igHP0xWkOKHdLklyJYwNtI0fzmiKqnnjiAEjYJ4GM0tz6ArRL1Wb3uRGGTgDy%2bwq9%2btS71HKhWB1DUPUVF%2btBS1G23gJQbUZbeAlBZQ8Dr7xMmRqJzj0q55EQfEwFILm%2bEPtDYBQzrOZI9mxjjcjrx%2b9BoaDkdYb12lOkMgCk/vRlBz6p7kw6yqKuo45JrPSwJO3DQIUzExA68jeqGPwEB8xlxjDNgbefJo5nlhCRHEkrE6STjb1qk3LvhI0USfFqBOwxWMaBYdotRL6ljUjc85NP7bwFpElzIsUaqNRCgnIJJyaeWvgJWuMTpXdWwlU4ODQdvZyJJHqEOEYkl1y31U9Ka11bZdkeYoaeJjL3sEgV8aTkZBFE11SzSXABtG0oVdhKpJ14znPO1RNhsulnDDOWBALZ5pjXVPMXaW/hgwoyQAMfNyPWmEKlI1U7kVKuqySfEf/2Q==' /%3e%3c/svg%3e" width="860" data-src="/blog/assets/static/CleancodeBook.07cc2b7.7222e95f3717f77d5f3ed287711f1d64.jpg" data-srcset="/blog/assets/static/CleancodeBook.a67b0b2.7222e95f3717f77d5f3ed287711f1d64.jpg 480w, /blog/assets/static/CleancodeBook.07cc2b7.7222e95f3717f77d5f3ed287711f1d64.jpg 860w" data-sizes="(max-width: 860px) 100vw, 860px" class="g-image g-image--lazy g-image--loading"><noscript><img src="/blog/assets/static/CleancodeBook.07cc2b7.7222e95f3717f77d5f3ed287711f1d64.jpg" class="g-image g-image--loaded" width="860" alt="Cover image"></noscript></div><div class="post__content"><h1 id="clean-code-내용-정리---4"><a href="#clean-code-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC---4" aria-hidden="true"><span class="icon icon-link"></span></a>Clean Code 내용 정리 - 4</h1>
<h2 id="11장-시스템"><a href="#11%EC%9E%A5-%EC%8B%9C%EC%8A%A4%ED%85%9C" aria-hidden="true"><span class="icon icon-link"></span></a>11장. 시스템</h2>
<h3 id="도시가-잘-돌아가는-이유"><a href="#%EB%8F%84%EC%8B%9C%EA%B0%80-%EC%9E%98-%EB%8F%8C%EC%95%84%EA%B0%80%EB%8A%94-%EC%9D%B4%EC%9C%A0" aria-hidden="true"><span class="icon icon-link"></span></a>도시가 잘 돌아가는 이유</h3>
<ul>
<li>다양한 분야를 관리하는 팀원</li>
<li>적절한 추상화와 모듈화</li>
</ul>
<h3 id="시스템-제작과-시스템-사용을-분리"><a href="#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%A0%9C%EC%9E%91%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%82%AC%EC%9A%A9%EC%9D%84-%EB%B6%84%EB%A6%AC" aria-hidden="true"><span class="icon icon-link"></span></a>시스템 제작과 시스템 사용을 분리</h3>
<p>제작과 사용은 다르다.</p>
<p>소프트웨어 시스템은 <strong>준비 과정</strong>(애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는)과 <strong>런타임 로직</strong>(준비 과정 이후의 단계)을 분리해야 한다.</p>
<h4 id="관심사-분리"><a href="#%EA%B4%80%EC%8B%AC%EC%82%AC-%EB%B6%84%EB%A6%AC" aria-hidden="true"><span class="icon icon-link"></span></a>관심사 분리.</h4>
<ul>
<li>Ex) 초기화 지연(Lazy Initialization), 계산 지연(Lazy Evaluation)</li>
<li>
<p>장점</p>
<ol>
<li>애플리케이션을 시작하는 시간이 그만큼 빨라진다.</li>
<li>어떤 경우에도 null을 반환하지 않는다.</li>
</ol>
</li>
<li>
<p>단점</p>
<ol>
<li>의존성을 해결해야 한다.</li>
<li>테스트에서 문제가 생긴다. 즉, 일시적으로라도 단일 책임 원칙(SRP, Single Responsibility Principle)을 깨야한다.</li>
</ol>
</li>
</ul>
<h4 id="main-분리"><a href="#main-%EB%B6%84%EB%A6%AC" aria-hidden="true"><span class="icon icon-link"></span></a>Main 분리.</h4>
<blockquote>
<p>시스템 생성과 사용을 분리하는 방법.</p>
</blockquote>
<p>main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘기며, 애플리케이션은 그저 객체를 사용한다.</p>
<h4 id="팩토리"><a href="#%ED%8C%A9%ED%86%A0%EB%A6%AC" aria-hidden="true"><span class="icon icon-link"></span></a>팩토리</h4>
<blockquote>
<p>Factory 패턴은 부모 클래스에 알려지지 않은 구체 클래스를 생성하는 패턴이며.<br>
자식 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴이다.</p>
</blockquote>
<p>객체가 생성하는 시점을 애플리케이션이 결정할 필요가 있는 경우에는 Abstact factory 패턴을 사용한다.</p>
<h4 id="의존성-주입"><a href="#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85" aria-hidden="true"><span class="icon icon-link"></span></a>의존성 주입</h4>
<blockquote>
<p>의존성 주입(DI, Dependency Injection)은 하나의 객체가 다른 객체의 의존성을 제공하는 테크닉이다. "의존성"은 예를 들어 서비스로 사용할 수 있는 객체이다. 클라이언트가 어떤 서비스를 사용할 것인지 지정하는 대신, 클라이언트에게 무슨 서비스를 사용할 것인지를 말해주는 것</p>
</blockquote>
<p>사용과 제작을 분리하는 강력한 메커니즘. 객체는 의존성 자체를 인스턴스로 만드는 책임을 지지 않는 대신에 다른 메커니즘에 넘겨야 한다.</p>
<ul>
<li>해당 방법으로 'main'루틴이나 특수 컨테이너를 사용한다.</li>
<li>스프링 프레임워크는 잘 알려진 자바 DI 컨테이너를 제공한다.</li>
</ul>
<h3 id="확장"><a href="#%ED%99%95%EC%9E%A5" aria-hidden="true"><span class="icon icon-link"></span></a>확장</h3>
<p>깨끗한 코드는 코드 수준에서는 시스템을 조정하고 확장하기 쉽게 만들어진다.</p>
<p>그러나 <strong>시스템 수준</strong>에서는 그렇지 않다. 단순한 아키텍처를 복잡한 아키텍처로 조금씩 키울 수는 없다.</p>
<ul>
<li>따라서 소프트웨어 시스템은 관심사를 적절한 게 분리해 관리해야 한다.</li>
</ul>
<h4 id="횡단cross-cutting-관심사"><a href="#%ED%9A%A1%EB%8B%A8cross-cutting-%EA%B4%80%EC%8B%AC%EC%82%AC" aria-hidden="true"><span class="icon icon-link"></span></a>횡단(Cross-cutting) 관심사</h4>
<blockquote>
<p>횡단 관심사는 다른 관심사에 영향을 미치는 프로그램의 측면이다. 이 관심사들은 디자인과 구현 면에서 시스템의 나머지 부분으로부터 깨끗이 분해되지 못하는 경우가 있을 수 있으며 분산되거나 얽히는 일이 일어날 수 있다.</p>
</blockquote>
<p>이를 해결하기 대처하기 위해 나온 방법론으로 <strong>관점 지향 프로그래밍</strong>(AOP, Aspet-Oriented Programming)이 있다.</p>
<ul>
<li>AOP에서의 관점 : 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다.</li>
</ul>
<h3 id="자바-프록시"><a href="#%EC%9E%90%EB%B0%94-%ED%94%84%EB%A1%9D%EC%8B%9C" aria-hidden="true"><span class="icon icon-link"></span></a>자바 프록시</h3>
<ul>
<li>단순한 상황에 적합하다. Ex) 개별 객체나 클래스에서 메서드 호출을 감싸는 경우.</li>
<li>JDK가 지원하는 동적 프록시는 인터페이스만 지원하며, 클래스 프록시를 사용하려면 CGLIB, ASM. Javassist 같은 바이트 코드 처리 라이브러리가 필요하다.</li>
</ul>
<h3 id="순수-자바-aop-프레임워크"><a href="#%EC%88%9C%EC%88%98-%EC%9E%90%EB%B0%94-aop-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC" aria-hidden="true"><span class="icon icon-link"></span></a>순수 자바 AOP 프레임워크</h3>
<p>POJO는 순수하게 도메인에 초점을 맞추며, 다른 도메인에 의존하지 않는다. 따라서 테스트가 개념적으로 더 쉽고 간단하며, 단순하여 구현에 쉬우며 이후 코드를 보수하고 개선하기 편하다.</p>
<blockquote>
<p>POJO(Plain Old Java Object) : 오래된 방식의 간단한 자바 오브젝트라는 말로서 Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 "무거운" 객체를 만들게 된 것에 반발해서 사용되게 된 용어</p>
</blockquote>
<h3 id="aspectj-관점"><a href="#aspectj-%EA%B4%80%EC%A0%90" aria-hidden="true"><span class="icon icon-link"></span></a>AspectJ 관점</h3>
<p>AspectJ는 관심사를 관점으로 분리하는 가장 강력한 도구이다.</p>
<ul>
<li>AspectJ '애너테이션 폼'은 새로운 도구와 새로운 언어의 부담을 제거한다.</li>
<li>애너테이션이란 주석처럼 프로그래밍에 영향을 미치지 않으며, 유용한 정보를 제공</li>
</ul>
<h3 id="테스트-주도-시스템-아키텍처-구축"><a href="#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%B6%95" aria-hidden="true"><span class="icon icon-link"></span></a>테스트 주도 시스템 아키텍처 구축</h3>
<ul>
<li>애플리케이션 도메인 논리를 POJO로 작성할 수 있다면 (코드 수준에서 아키텍처 관심사를 분리할 수 있다면), <strong>테스트 주도 아키텍처</strong> 구축이 가능하다.</li>
<li>좋은 웹 사이트 들은 고도의 자료 캐싱, 보안, 가상화 등을 이용해 아주 높은 가용성과 성능을 효율적이고 유연하게 달성한다.</li>
<li>이를 정리하면, 최선의 시스템 구조는 각기 POJO 객체로 구현되는 모듈화 된 관심사 영역(도메인)으로 구성된다. 이러한 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합하며, 이러한 구조는 테스트 주도 기법을 사용할 수 있다.</li>
</ul>
<h3 id="의사-결정을-최적화"><a href="#%EC%9D%98%EC%82%AC-%EA%B2%B0%EC%A0%95%EC%9D%84-%EC%B5%9C%EC%A0%81%ED%99%94" aria-hidden="true"><span class="icon icon-link"></span></a>의사 결정을 최적화</h3>
<ul>
<li>모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능하다.</li>
<li>
<p>가능한 마지막 순간까지 결정을 미루는 방법이 좋은 경우가 있는데, 이러한 경우에서 옳게 쓰일 수 있다.</p>
<ul>
<li>즉, 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공하고, 이러한 기민함은 최신 정보에 기반에 최선의 시점에 최적의 결정을 내리는데 도움을 준다. 더불어 결정의 복잡성도 감소한다.</li>
</ul>
</li>
</ul>
<h3 id="명백한-가치가-있을-때-표준을-현명하게-사용"><a href="#%EB%AA%85%EB%B0%B1%ED%95%9C-%EA%B0%80%EC%B9%98%EA%B0%80-%EC%9E%88%EC%9D%84-%EB%95%8C-%ED%91%9C%EC%A4%80%EC%9D%84-%ED%98%84%EB%AA%85%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9" aria-hidden="true"><span class="icon icon-link"></span></a>명백한 가치가 있을 때 표준을 현명하게 사용</h3>
<p>표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉬우며 컴포넌트를 엮기 쉽다.</p>
<p>단점으로는 표준을 만드는 시간이 너무 오래 걸리게 된다면, 다른 업계가 기다리지 못한다. 더불어 표준이 목적을 잃어버리는 경우도 발생한다.</p>
<h3 id="시스템은-도메인-특화-언어가-필요"><a href="#%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%ED%8A%B9%ED%99%94-%EC%96%B8%EC%96%B4%EA%B0%80-%ED%95%84%EC%9A%94" aria-hidden="true"><span class="icon icon-link"></span></a>시스템은 도메인 특화 언어가 필요</h3>
<blockquote>
<p>도메인 특화 언어(DSL, Domain-Specific Language)이란. 간단한 스크립트 언어나 표준 언어로 구현한 API</p>
</blockquote>
<ul>
<li>좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 '의사소통 간극'을 줄여주며, 도메인을 잘못 구현할 가능성이 줄어든다.</li>
<li>추상화 수준을 코드 관용구나 디자인 패턴 이상의 효과를 만들어 낼 수 있다.</li>
<li>DSL을 사용하면 고차원 정책에서 저 차원 세부사항에 이르기까지 모든 추상화 수준과 모든 도메인을 POJO로 표현 가능하다.</li>
</ul>
<h3 id="결론"><a href="#%EA%B2%B0%EB%A1%A0" aria-hidden="true"><span class="icon icon-link"></span></a>결론</h3>
<ul>
<li>깨끗한 아키텍처는 도메인 논리를 높여주며, 기민성을 높이고, 제품 품질이 떨어지며, TDD가 제공하는 단점이 사라진다.</li>
<li>POJO를 작성하고 관점 등을 통해 관심사를 분리해서 추상화 단계에서의 의도를 명확히 표현해야 한다.</li>
<li>핵심 중 하나는 <strong>실제로 돌아가는 가장 단순한 수단을 사용해야 한다.</strong></li>
</ul>
<h2 id="12장-창발성"><a href="#12%EC%9E%A5-%EC%B0%BD%EB%B0%9C%EC%84%B1" aria-hidden="true"><span class="icon icon-link"></span></a>12장. 창발성</h2>
<h3 id="창발적-설계로-깔끔한-코드를-구현"><a href="#%EC%B0%BD%EB%B0%9C%EC%A0%81-%EC%84%A4%EA%B3%84%EB%A1%9C-%EA%B9%94%EB%81%94%ED%95%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EA%B5%AC%ED%98%84" aria-hidden="true"><span class="icon icon-link"></span></a>창발적 설계로 깔끔한 코드를 구현</h3>
<p>우수한 설계가 나오는 간단한 규칙 4가지</p>
<ol>
<li>모든 테스트를 실행한다</li>
<li>중복을 없앤다.</li>
<li>프로그래머 의도를 표현한다.</li>
<li>클래스와 메서드 수를 최소로 줄인다.</li>
</ol>
<p>단 위가 밑보다 중요하다.</p>
<h3 id="단순한-설계-규칙-1-모든-테스트를-실행"><a href="#%EB%8B%A8%EC%88%9C%ED%95%9C-%EC%84%A4%EA%B3%84-%EA%B7%9C%EC%B9%99-1-%EB%AA%A8%EB%93%A0-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%8B%A4%ED%96%89" aria-hidden="true"><span class="icon icon-link"></span></a>단순한 설계 규칙 1: 모든 테스트를 실행</h3>
<ul>
<li>설계는 의도한 대로 돌아가야 한다.</li>
<li>철저한 테스트가 가능한 시스템은 더 나은 설계를 만든다.</li>
<li>결합도가 높을수록 테스트 케이스를 작성하기 어렵다.</li>
<li>테스트 케이스를 만들고 돌리는 것 -> 낮은 결합도와 높은 응집력</li>
</ul>
<h3 id="단순한-설계-규칙-24-리팩터링"><a href="#%EB%8B%A8%EC%88%9C%ED%95%9C-%EC%84%A4%EA%B3%84-%EA%B7%9C%EC%B9%99-24-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81" aria-hidden="true"><span class="icon icon-link"></span></a>단순한 설계 규칙 2~4: 리팩터링</h3>
<ul>
<li>테스트 케이스를 모두 작성했다면, 코드와 클래스를 점진적으로 정리하면 된다.</li>
<li>코드를 정리하면서 테스트 케이스를 통해 깨지지 않도록 한다.</li>
<li>리팩터링 단계에서는 소프트웨어 설계 품질을 높이는 기법을 사용하는 것이 좋다.</li>
<li>이 단계 동안 중복을 없애고, 프로그래머 의도를 표현하고 클래스와 메서드 수를 줄이는 단계이다.</li>
</ul>
<h3 id="중복을-없애라"><a href="#%EC%A4%91%EB%B3%B5%EC%9D%84-%EC%97%86%EC%95%A0%EB%9D%BC" aria-hidden="true"><span class="icon icon-link"></span></a>중복을 없애라</h3>
<ul>
<li>중복은 추가 작업, 추가 위협, 불필요한 복잡도를 의미한다.</li>
<li>TEMPLATE METHOD 패턴은 고차원 중복을 제거할 목적으로 자주사 사용하는 기법</li>
</ul>
<blockquote>
<p>Templaet Method Pattern. 동작 상의 알고리즘의 프로그램 뼈대를 정의하는 행위 디자인 패턴, 알고리즘의 구조를 변경하지 않고 알고리즘의 특정 단계들을 다시 정의할 수 있게 해 준다</p>
</blockquote>
<h3 id="표현하기"><a href="#%ED%91%9C%ED%98%84%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="icon icon-link"></span></a>표현하기</h3>
<p>많은 소프트웨어 프로젝트 비용 중 대다수는 장기적인 유지보수에 들어간다.</p>
<p>이를 해결하는 방법은 다음과 같다.</p>
<ol>
<li>좋은 이름 선택한다.</li>
<li>함수와 클래스 크기를 가능한 줄인다.</li>
<li>표준 명칭을 사용한다.</li>
<li>단위 테스트 케이스를 꼼꼼히 작성한다.</li>
</ol>
<p>가장 큰 핵심은 나중에 볼 사람을 위해서 <strong>노력</strong>해야 한다.</p>
<h3 id="클래스와-메서드-수를-최소로-줄이기"><a href="#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%88%98%EB%A5%BC-%EC%B5%9C%EC%86%8C%EB%A1%9C-%EC%A4%84%EC%9D%B4%EA%B8%B0" aria-hidden="true"><span class="icon icon-link"></span></a>클래스와 메서드 수를 최소로 줄이기</h3>
<ul>
<li>너무 중복을 제거하고, 의도를 표현하고, SRP를 준수하는 경우에는 단점이 발생할 수 있다.</li>
<li>목표는 함수와 클래스 크기를 줄이면서 시스템 크기를 작게 유지하는 것이다.</li>
<li>단, 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다.</li>
</ul>
<h2 id="13장-동시성"><a href="#13%EC%9E%A5-%EB%8F%99%EC%8B%9C%EC%84%B1" aria-hidden="true"><span class="icon icon-link"></span></a>13장. 동시성</h2>
<p>동시성과 깔끔한 코드는 양립하기 아주 어렵다. 깨끗한 동시성은 사실 매우 중요하며, 어려운 문제이다.</p>
<h3 id="동시성이-필요한-이유"><a href="#%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0" aria-hidden="true"><span class="icon icon-link"></span></a>동시성이 필요한 이유?</h3>
<ul>
<li>동시성은 결함(coupling)을 없애는 전략. 즉, <strong>무엇</strong>과 <strong>언제</strong>를 분리하는 전략이다.</li>
<li>무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.</li>
<li>시스템 응답 시간과 작업 처리량 개선으로 인해 동시성이 필요하다.</li>
</ul>
<h4 id="미신과-오해"><a href="#%EB%AF%B8%EC%8B%A0%EA%B3%BC-%EC%98%A4%ED%95%B4" aria-hidden="true"><span class="icon icon-link"></span></a> 미신과 오해</h4>
<p>대표적인 오해.</p>
<ul>
<li>
<p>동시성은 항상 성능을 높여준다.</p>
<ul>
<li>동시성은 <strong>때로</strong> 성능을 높여준다. 즉, 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.</li>
</ul>
</li>
<li>
<p>동시성을 구현해도 설계는 변하지 않는다.</p>
<ul>
<li>단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. 일반적으로 <strong>무엇</strong>과 <strong>언제</strong>를 분리하면 시스템 구조가 달라진다.</li>
</ul>
</li>
<li>
<p>웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.</p>
<ul>
<li>실제로는 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지 알아야 한다.</li>
</ul>
</li>
</ul>
<p>타당한 생각.</p>
<ul>
<li><strong>동시성은 사소 부하를 유발한다.</strong> 성능 측면에서 부하가 걸리며, 코드도 더 짜야한다.</li>
<li><strong>동시성은 복잡하다.</strong> 간단한 문제라도 동시성은 복잡하다.</li>
<li><strong>일반적으로 동시성 버그는 제한하기 어렵다.</strong> 그래서 진짜 결함으로 간주 하지 않고 일회성 문제로 여겨 무시하기 쉽다.</li>
<li><strong>동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.</strong></li>
</ul>
<h3 id="난관"><a href="#%EB%82%9C%EA%B4%80" aria-hidden="true"><span class="icon icon-link"></span></a>난관</h3>
<pre><code class="language-java">public class X {
  private int lastIdUsed;

  public int getNextId() {
    return ++lastIdUsed;
  }
}
</code></pre>
<p>다음과 같은 경우. 인스턴스 X를 생성하고 lastIdUsed를 필드. 42로 설정하는 경우로 보면.</p>
<ul>
<li>어떤 스레드는 43을 받고 다른 스레드는 44를 받는데 저장은 제각각이다. 이러한 스레드가 수많이 있다.</li>
</ul>
<h3 id="동시성-방어-원칙"><a href="#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%B0%A9%EC%96%B4-%EC%9B%90%EC%B9%99" aria-hidden="true"><span class="icon icon-link"></span></a>동시성 방어 원칙</h3>
<p>다양한 방어 원칙과 기술이 있다.</p>
<h4 id="단일-책임-원칙srp-single-reponsibility-priniciple"><a href="#%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99srp-single-reponsibility-priniciple" aria-hidden="true"><span class="icon icon-link"></span></a>단일 책임 원칙(SRP, Single Reponsibility Priniciple)</h4>
<blockquote>
<p>SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙</p>
</blockquote>
<p>동시성은 복잡성 하므로 다른 코드와 분리해야 한다. 아래는 고려해야 할 사항이다.</p>
<ul>
<li>동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.</li>
<li>동시성 코드에는 독자적인 난관이 있으며 이는 더 어렵다.</li>
<li>잘못 구현된 동시성 코드는 온갖 에러가 발생한다.</li>
</ul>
<p><strong>따라서. 동시성 코드는 다른 코드와 분리한다.</strong></p>
<h4 id="따름-정리corollary--자료-범위를-제한해라"><a href="#%EB%94%B0%EB%A6%84-%EC%A0%95%EB%A6%ACcorollary--%EC%9E%90%EB%A3%8C-%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%A0%9C%ED%95%9C%ED%95%B4%EB%9D%BC" aria-hidden="true"><span class="icon icon-link"></span></a>따름 정리(corollary) : 자료 범위를 제한해라</h4>
<p>공유 객체를 사용하는 코드 <strong>임계 영역(critical</strong> section)을 synchronized 키워드로 보호하는 것뿐만 아니라, 이 수를 줄여야 한다.</p>
<p>수가 많으면 다음과 같은 문제가 발생한다.</p>
<ul>
<li>보호할 임계 영역을 빼먹어서 해당 자료를 수정하는 모든 코드가 망가진다.</li>
<li>모든 임계 영역을 올바로 보호했는지 확인하느라 똑같은 노력과 수고가 필요하다.</li>
<li>찾기 어려운 버그를 더 찾기 힘들어진다.</li>
</ul>
<p><strong>따라서. 자료를 캡슐화해야 하며, 공유 자료를 최대한 줄여야 한다.</strong></p>
<h4 id="따름-정리--자료-사본을-사용하기"><a href="#%EB%94%B0%EB%A6%84-%EC%A0%95%EB%A6%AC--%EC%9E%90%EB%A3%8C-%EC%82%AC%EB%B3%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="icon icon-link"></span></a>따름 정리 : 자료 사본을 사용하기</h4>
<p>공유 자료를 줄이는 최고의 방법은 공유하지 않은 방법이다. 즉, 객체를 복사해서 읽는 방법도 존재한다. 객체를 복사하는 비용이 그렇게 크지않다면 나쁘지 않는 방법이다.</p>
<h4 id="따름-정리--스레드는-가능한-독립적으로-구현하라"><a href="#%EB%94%B0%EB%A6%84-%EC%A0%95%EB%A6%AC--%EC%8A%A4%EB%A0%88%EB%93%9C%EB%8A%94-%EA%B0%80%EB%8A%A5%ED%95%9C-%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9C%BC%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%98%EB%9D%BC" aria-hidden="true"><span class="icon icon-link"></span></a>따름 정리 : 스레드는 가능한 독립적으로 구현하라</h4>
<p>다른 스레드와 공유하지 않는 독립적인 스레드를 구성해라. (예를 들면 로컬 변수 등)</p>
<p><strong>따라서, 독자적인 스레드로, 가능하다면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할한다.</strong></p>
<h3 id="라이브러리를-이해하기"><a href="#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="icon icon-link"></span></a>라이브러리를 이해하기.</h3>
<p>자바 5에서 스레드를 구현한다면 다음을 고려해보기.</p>
<ul>
<li>스레드 환경에 안전한 컬렉션을 사용.</li>
<li>서로 무관한 작업을 수행할 때는 executor 프레임워크 사용.</li>
<li>가능하다면 스레드가 차단(blocking) 되지 않는 방법을 사용.</li>
<li>일부 클래스 라이브러리는 스레드에 안전하지 못함.</li>
</ul>
<h4 id="스레드-환경에-안전한-컬렉션"><a href="#%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%99%98%EA%B2%BD%EC%97%90-%EC%95%88%EC%A0%84%ED%95%9C-%EC%BB%AC%EB%A0%89%EC%85%98" aria-hidden="true"><span class="icon icon-link"></span></a>스레드 환경에 안전한 컬렉션</h4>
<p>다중 스레드에서 안전한 메소드로 여러 가지 존재한다.</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConcurrentHashMap</td>
<td>HashMap보다 거의 모든 상황에서 빠르다.</td>
</tr>
<tr>
<td>ReentrantLock</td>
<td>한 메서드에서 잠그고 다른 메서드에서 푸는 락(lock)이다.</td>
</tr>
<tr>
<td>Semaphore</td>
<td>전형적인 세마포어, 개수(count)가 있는 락이다.</td>
</tr>
<tr>
<td>CountDownLatch</td>
<td>지정한 수만큼 이벤트가 발생하고 대기 중인 스레드를 모드 해제하는 락.</td>
</tr>
<tr>
<td>모든 스레드에게 동시에 공평하게 시작할 권리를 제공</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="실행-모델을-이해하기"><a href="#%EC%8B%A4%ED%96%89-%EB%AA%A8%EB%8D%B8%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="icon icon-link"></span></a>실행 모델을 이해하기.</h3>
<p>간단한 기본 용어는 다음과 같다.</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>한정된 자원 (Bound Resource)</td>
<td>다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다.</td>
</tr>
<tr>
<td>데이터 베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예시이다.</td>
<td></td>
</tr>
<tr>
<td>상호 배제 (Mutual Exclusion)</td>
<td>한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.</td>
</tr>
<tr>
<td>기아 (Starvation)</td>
<td>한 스레드나 여러 스레드가 굉장히 오랫동안 호은 영원한 자원을 기다린다.</td>
</tr>
<tr>
<td>예를 들어, 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속적으로 이루어지는 경우, 긴 스레드가 기아 상태에 빠진다.</td>
<td></td>
</tr>
<tr>
<td>데드락 (Deadlock)</td>
<td>여러 스레드가 서로가 끝나기를 기다린다.</td>
</tr>
<tr>
<td>모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느쪽도 더이상 진행하지 못한다.</td>
<td></td>
</tr>
<tr>
<td>라이브락 (Livelock)</td>
<td>락을 거는 단계에서 각 스레드가 서로를 방해한다.</td>
</tr>
<tr>
<td>스레드는 계속해서 진행하려 하지만, 공명(response)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.</td>
<td></td>
</tr>
</tbody>
</table>
<p>다중 스레드 프로그래밍에서 실행하는 방법은 대부분 아래의 3가지 방법이다.</p>
<h4 id="생산자-소비자producer-consumer"><a href="#%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90producer-consumer" aria-hidden="true"><span class="icon icon-link"></span></a>생산자-소비자(Producer-Consumer)</h4>
<p><img src="https://user-images.githubusercontent.com/42582516/92720407-84b49c00-f39f-11ea-971b-582f1952a73a.png" alt="image"></p>
<p>다음 그림처럼 <strong>한정적 자원</strong>을 생산자는 정보를 생성하고, 소비자는 정보를 사용한다.</p>
<p>생산자 스레드는 정보를 채우고 시그널을 보내고, 소비자는 대기열에 정보를 읽은 후 시그널을 보낸다. 단, 동시에 시그널을 기다릴 가능성 또한 존재한다.</p>
<h4 id="읽기-쓰기readers-writers"><a href="#%EC%9D%BD%EA%B8%B0-%EC%93%B0%EA%B8%B0readers-writers" aria-hidden="true"><span class="icon icon-link"></span></a>읽기-쓰기(Readers-Writers)</h4>
<p><img src="https://user-images.githubusercontent.com/42582516/92720672-e412ac00-f39f-11ea-9905-8e06721b39ab.png" alt="image"></p>
<p>읽기 스레드가 공유 자원을 사용하지만, 처리율이 부족한 경우 기아 현상이나 오래된 정보가 쌓인다.</p>
<p>이러한 처리율을 높이는 방법은 여러 가지가 있는데.</p>
<ul>
<li>간단한 전략 : 읽기 스레드가 없을 때까지 쓰기 스레드가 버퍼를 기다리는 방법, 하지만 쓰기 스레드가 기아 발생 가능.</li>
<li>이러한 방법을 갱신하는 밥법은 "<strong>식사하는 철학자들</strong>" 방법이 있다.</li>
</ul>
<h4 id="식사하는-철학자들dining-philosopheres"><a href="#%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4dining-philosopheres" aria-hidden="true"><span class="icon icon-link"></span></a>식사하는 철학자들(Dining Philosopheres)</h4>
<p><img src="https://user-images.githubusercontent.com/42582516/92725422-196ec800-f3a7-11ea-8f11-9ff2bbac63f6.png" alt="image"></p>
<p>여기서 철학자는 스레드이고, 포크는 자원이다. 여기서, 자원을 얻으려면 몇몇의 스레드는 쉬어야 하는 것을 알 수 있다.</p>
<p>단 이와 같은 설계를 할 때는 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 고려해서 사용해야 한다.</p>
<h3 id="동기화하는-메서드-사이에-존재하는-의존성을-이해"><a href="#%EB%8F%99%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%82%AC%EC%9D%B4%EC%97%90-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%84-%EC%9D%B4%ED%95%B4" aria-hidden="true"><span class="icon icon-link"></span></a>동기화하는 메서드 사이에 존재하는 의존성을 이해</h3>
<ul>
<li><strong>공유 객체 하나에는 메서드 하나만 사용하기.</strong></li>
</ul>
<p>공유 객체 하나에 여러 메서드가 필요한 경우는 다음과 같은 세 가지 방법을 고려한다.</p>
<ul>
<li>클라이언트에서 잠금 : 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠금. 마지막 메서드를 호출할 때까지 잠금을 유지한다</li>
<li>서버에서 잠금 : 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는" 메서드를 구현. 클라이언트는 이 메서드를 구현</li>
<li>연결(Adapted) 서버 : 잠금을 수행하는 중간 단계를 생성. '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경하지 않음</li>
</ul>
<h3 id="동기화하는-부분을-작게-만들기"><a href="#%EB%8F%99%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84%EC%9D%84-%EC%9E%91%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0" aria-hidden="true"><span class="icon icon-link"></span></a>동기화하는 부분을 작게 만들기</h3>
<p>필요 이상으로 임계 영역 크기를 키우면 스레드 간 경쟁이 늘어나고 프로그램 성능이 떨어진다.</p>
<p><strong>따라서. 동기화하는 부분을 최대한 작게 만든다.</strong></p>
<h3 id="올바른-종료-코드는-구현하기-어렵다"><a href="#%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%A2%85%EB%A3%8C-%EC%BD%94%EB%93%9C%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-%EC%96%B4%EB%A0%B5%EB%8B%A4" aria-hidden="true"><span class="icon icon-link"></span></a>올바른 종료 코드는 구현하기 어렵다</h3>
<p>데드락에 걸려서 종료 코드가 안 갈 수도 있다. 따라서 <strong>종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현해야 한다. 생각보다 오래 걸리고 어려우므로 나온 알고리즘을 검토하는 것도 좋은 방법이다.</strong></p>
<h3 id="스레드-코드-테스트하기"><a href="#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="icon icon-link"></span></a>스레드 코드 테스트하기</h3>
<p>하나의 스레드에서는 이전에 했던 모든 말 들이 통용되지만, 여러 스레드에서의 상황은 복잡하다.</p>
<p><strong>따라서. 문제를 노출하는 테스트 케이스를 작성한다. 프로그램 설정과 시스템 설정과 부하를 바꿔가면서 자주 돌리고 테스트가 실패할 경우 원인을 추적해야 한다. 다시 돌렸더니 통과한다는 이유로 넘어가면 안 된다.</strong></p>
<p>구체적인 지침은 다음과 같다.</p>
<ul>
<li>
<p>말이 안 되는 실패를 잠정적인 스레드 문제로 취급하기</p>
<ul>
<li>시스템 실패를 '일회성'이라고 취급하지 말기.</li>
</ul>
</li>
<li>
<p>다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들기</p>
<ul>
<li>스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하면 안 된다. 먼저 스레드 환경 밖부터 해결해야 한다.</li>
</ul>
</li>
<li>
<p>다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현</p>
<ul>
<li>다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현</li>
</ul>
</li>
<li>
<p>다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정해주기</p>
<ul>
<li>프로그램 처리율과 효율에 따라 스레드 개수를 조율하는 코드도 고민해보기</li>
</ul>
</li>
<li>
<p>프로세서 수보다 많은 스레드 돌려보기</p>
<ul>
<li>스와핑이 잦을수록 임계 영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.</li>
</ul>
</li>
<li>
<p>다른 플랫폼에서 돌려보기</p>
<ul>
<li>처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려보는 것이 좋다.</li>
</ul>
</li>
<li>
<p>코드에 보조 코드(instruction)를 넣어 돌리기. 강제로 실패 만들기.</p>
<ul>
<li>
<p>방법 1. 직접 구현하기</p>
<ul>
<li>코드에다 wait(), sleep(), yield(), probity() 함수를 추가하기.</li>
<li>생각했는 결과물과 맞는지 체크하기.</li>
</ul>
</li>
<li>
<p>방법 2. 자동화</p>
<ul>
<li>AOP(Aspect-Oriented Framework), CGLIB, ASM 등의 도구를 사용</li>
<li><strong>흔들기 기법</strong>(jiggle) 등을 사용해 오류를 찾는 것도 좋다. 이를 사용하면 스레드를 매번 다른 순서로 실행한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="결론-1"><a href="#%EA%B2%B0%EB%A1%A0-1" aria-hidden="true"><span class="icon icon-link"></span></a>결론.</h3>
<p>핵심은 다음과 같다.</p>
<ul>
<li>SRP를 준수하기</li>
<li>동시성 오류를 일으키는 잠정적 원인을 정학하게 이해</li>
<li>사용하는 라이브러리와 기본 알고리즘을 정확히 이해</li>
<li>보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해</li>
</ul>
</div><div class="post__footer"><div class="post-tags"><a href="/blog/tag/Review/" class="post-tags__link"><span>#</span> Review
		</a><a href="/blog/tag/Book/" class="post-tags__link"><span>#</span> Book
		</a><a href="/blog/tag/CleanCode/" class="post-tags__link"><span>#</span> CleanCode
		</a><a href="/blog/tag/Clean-code/" class="post-tags__link"><span>#</span> Clean-code
		</a><a href="/blog/tag/Java/" class="post-tags__link"><span>#</span> Java
		</a></div></div></div><div class="post-comments"></div><div class="author post-author"><img alt="Author image" src="data:image/svg+xml,%3csvg fill='none' viewBox='0 0 180 180' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-bfb91fc8d3516221a47de6ec13d7cf4f'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='5'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-bfb91fc8d3516221a47de6ec13d7cf4f)' width='180' height='180' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCABAAEADASIAAhEBAxEB/8QAHAAAAQUBAQEAAAAAAAAAAAAABgEDBAcIBQIA/8QAMBAAAQMDAgQFAwQDAQAAAAAAAQIDBAAFERIhBhMxUQciQWFxFJGhFiMygRVCsdH/xAAYAQADAQEAAAAAAAAAAAAAAAABAgMABP/EACARAAICAgICAwAAAAAAAAAAAAECABEDEiExBCITQUL/2gAMAwEAAhEDEQA/ALKr4mmyo5pdVPJXFNIakR4ynUlaspbAznHX4qp/EzxOTw9LctVnQ07cEpBW%2b4QW2sjYY9VfOMe9LuLqNowFyzx0pDWTX%2bM%2bIZMovOcQT9ZUFYbdKQD8DbHxWg/Cy7XriC0xZl%2bTEYiyBy4i06ua%2bpOcqV/qAcHHqaBcDuMqMxoQtNeTUiayGVJKM6TsQeqVDqKjUVYMLEzKVNGeiupMCOZTnZtP8jTcSGp/C3Mpa/JqJfLythf0VrbQp0DzFX8UDuankyfle4%2bLFfs/AnL4x42t9puRgPsZitMuPPSCSSjSkkBCR1Vt%2bM1Stv8ADfibjGQ5f5S4Mf6xfNCJWvUpJ6FSUjbbHrmrNn8PNTo036xXOkymy2VgYCQrY4HxtRBw5DegyHhHhpiAq0lZeLnNGNlHI2PpjeoHbH33Oz0zGh0JRvF/hfxBbYvPiRbc4003%2b43BdcKlnfK9Lm5PsD0HSjjwB46uHEN/uFivKkGN9Ml2KylGAyWyElI7DGDjvRRf1SHJMlEh66ocLepK2NJYwTgJ0k5J37dM71WEaR%2bkfEW0Xvkqw4tUeWllJ8yVDBUB3Gx/qtvtw0Pw6cpNFXZCkMuDqcZz8Vy0kFIPcV3w7HutuS7GcS4hadSVJ6GhoL5bqmVbLRtg0%2bA0SJDyFNAx%2b/XUsIDMfd1Ww/8Aa4DCNIJJJKjlSj1Ue9DDvHvDqOfImXNlK9ZSkDKjgdgM1HV4l8MJjB4zHic45YYUV/bpj%2b6piUKLPcjmcsaHUN0Hzox1yK6z85wJy0yXloQf2kKAVn060B/rOxC1xLg7cEMsSgS0Fg6zg4PlGTsaM7KLbxxZ2btZ5KCtOWXkLRgpUOpwfQ7GtlTeiJTxMioSH6ntcpSLQtU1gIcGdshRx6Zx61XCoKLnci88hTSUkltWN09Onuf%2bVYlybs/DlsU2FtyX86iEKyhJ7k%2bp9qDVXBMyQ64CnmZBWkHdORtkfGKgMPNMZ0t5OtsghxwI%2bhhKoKAEtgakJAwB3p/iqERiUyPOnc49aGLDK5FxYWFY82D8GrGdQmRG3wQRRcatxJo26%2b0wVpK0kDb4pWm3HGwlIyoq0bd6QOBCCTXbtLIMaK6oDSnU8fk9KuBc4pDlQzGmuac%2bVsKH23/Io/8ADriViySXY90b5lskJAdSUatB9FY6/b27UKzG%2bdIQsbamSPuRXp0aClY9Nj8U2sIYjmWNfeIOHks86LeA7g4RFRGWgJHck7mq2uV0luXQ3GO%2b8zLkrAy2op0J7bewFNTUnWgBX8t6bbwJaUkbcsn8ikCAG5R8zMoX6EIovGd8YkM65ijo3xoTggeh23PvWrrFLTMtzLqCClxtK0/BGaxo6%2bhSlKO2lRT8d60t4MXX/IcFW4knWyDHUD1Gk4H4xSZR0Y%2bA8kT/2Q==' /%3e%3c/svg%3e" width="180" data-src="/blog/assets/static/author.e6b6009.98a7113f4952b5eaa532b5d16696f13d.jpg" data-srcset="/blog/assets/static/author.e6b6009.98a7113f4952b5eaa532b5d16696f13d.jpg 180w" data-sizes="(max-width: 180px) 100vw, 180px" class="author__image g-image g-image--lazy g-image--loading"><noscript><img src="/blog/assets/static/author.e6b6009.98a7113f4952b5eaa532b5d16696f13d.jpg" class="author__image g-image g-image--loaded" width="180" alt="Author image"></noscript><!----><p class="author__intro">
		To be a Pro in Web developer
	</p><p class="author__links"><a href="//linkedin.com/in/myeonghun-park-7693a1184/">Linkedin</a><a href="//github.com/Azderica">GitHub</a></p></div></main><footer class="footer"><span class="footer__copyright">Copyright © 2020. </span><span class="footer__links">Powered by <a href="//gridsome.org"> Gridsome </a></span></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"title":"[Review] Clean Code 내용정리 - 4","path":"\u002Freview-clean-code-4\u002F","date":"6. November 2020","timeToRead":26,"tags":[{"id":"Review","title":"Review","path":"\u002Ftag\u002FReview\u002F"},{"id":"Book","title":"Book","path":"\u002Ftag\u002FBook\u002F"},{"id":"CleanCode","title":"CleanCode","path":"\u002Ftag\u002FCleanCode\u002F"},{"id":"Clean-code","title":"Clean-code","path":"\u002Ftag\u002FClean-code\u002F"},{"id":"Java","title":"Java","path":"\u002Ftag\u002FJava\u002F"}],"description":" Clean code 책 정리 4편입니다. ","content":"\u003Ch1 id=\"clean-code-내용-정리---4\"\u003E\u003Ca href=\"#clean-code-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC---4\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EClean Code 내용 정리 - 4\u003C\u002Fh1\u003E\n\u003Ch2 id=\"11장-시스템\"\u003E\u003Ca href=\"#11%EC%9E%A5-%EC%8B%9C%EC%8A%A4%ED%85%9C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E11장. 시스템\u003C\u002Fh2\u003E\n\u003Ch3 id=\"도시가-잘-돌아가는-이유\"\u003E\u003Ca href=\"#%EB%8F%84%EC%8B%9C%EA%B0%80-%EC%9E%98-%EB%8F%8C%EC%95%84%EA%B0%80%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E도시가 잘 돌아가는 이유\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E다양한 분야를 관리하는 팀원\u003C\u002Fli\u003E\n\u003Cli\u003E적절한 추상화와 모듈화\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"시스템-제작과-시스템-사용을-분리\"\u003E\u003Ca href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%A0%9C%EC%9E%91%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%82%AC%EC%9A%A9%EC%9D%84-%EB%B6%84%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E시스템 제작과 시스템 사용을 분리\u003C\u002Fh3\u003E\n\u003Cp\u003E제작과 사용은 다르다.\u003C\u002Fp\u003E\n\u003Cp\u003E소프트웨어 시스템은 \u003Cstrong\u003E준비 과정\u003C\u002Fstrong\u003E(애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는)과 \u003Cstrong\u003E런타임 로직\u003C\u002Fstrong\u003E(준비 과정 이후의 단계)을 분리해야 한다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"관심사-분리\"\u003E\u003Ca href=\"#%EA%B4%80%EC%8B%AC%EC%82%AC-%EB%B6%84%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E관심사 분리.\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003EEx) 초기화 지연(Lazy Initialization), 계산 지연(Lazy Evaluation)\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E장점\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E애플리케이션을 시작하는 시간이 그만큼 빨라진다.\u003C\u002Fli\u003E\n\u003Cli\u003E어떤 경우에도 null을 반환하지 않는다.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E단점\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E의존성을 해결해야 한다.\u003C\u002Fli\u003E\n\u003Cli\u003E테스트에서 문제가 생긴다. 즉, 일시적으로라도 단일 책임 원칙(SRP, Single Responsibility Principle)을 깨야한다.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"main-분리\"\u003E\u003Ca href=\"#main-%EB%B6%84%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMain 분리.\u003C\u002Fh4\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E시스템 생성과 사용을 분리하는 방법.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003Emain 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘기며, 애플리케이션은 그저 객체를 사용한다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"팩토리\"\u003E\u003Ca href=\"#%ED%8C%A9%ED%86%A0%EB%A6%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E팩토리\u003C\u002Fh4\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EFactory 패턴은 부모 클래스에 알려지지 않은 구체 클래스를 생성하는 패턴이며.\u003Cbr\u003E\n자식 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴이다.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E객체가 생성하는 시점을 애플리케이션이 결정할 필요가 있는 경우에는 Abstact factory 패턴을 사용한다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"의존성-주입\"\u003E\u003Ca href=\"#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E의존성 주입\u003C\u002Fh4\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E의존성 주입(DI, Dependency Injection)은 하나의 객체가 다른 객체의 의존성을 제공하는 테크닉이다. \"의존성\"은 예를 들어 서비스로 사용할 수 있는 객체이다. 클라이언트가 어떤 서비스를 사용할 것인지 지정하는 대신, 클라이언트에게 무슨 서비스를 사용할 것인지를 말해주는 것\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E사용과 제작을 분리하는 강력한 메커니즘. 객체는 의존성 자체를 인스턴스로 만드는 책임을 지지 않는 대신에 다른 메커니즘에 넘겨야 한다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E해당 방법으로 'main'루틴이나 특수 컨테이너를 사용한다.\u003C\u002Fli\u003E\n\u003Cli\u003E스프링 프레임워크는 잘 알려진 자바 DI 컨테이너를 제공한다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"확장\"\u003E\u003Ca href=\"#%ED%99%95%EC%9E%A5\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E확장\u003C\u002Fh3\u003E\n\u003Cp\u003E깨끗한 코드는 코드 수준에서는 시스템을 조정하고 확장하기 쉽게 만들어진다.\u003C\u002Fp\u003E\n\u003Cp\u003E그러나 \u003Cstrong\u003E시스템 수준\u003C\u002Fstrong\u003E에서는 그렇지 않다. 단순한 아키텍처를 복잡한 아키텍처로 조금씩 키울 수는 없다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E따라서 소프트웨어 시스템은 관심사를 적절한 게 분리해 관리해야 한다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"횡단cross-cutting-관심사\"\u003E\u003Ca href=\"#%ED%9A%A1%EB%8B%A8cross-cutting-%EA%B4%80%EC%8B%AC%EC%82%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E횡단(Cross-cutting) 관심사\u003C\u002Fh4\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E횡단 관심사는 다른 관심사에 영향을 미치는 프로그램의 측면이다. 이 관심사들은 디자인과 구현 면에서 시스템의 나머지 부분으로부터 깨끗이 분해되지 못하는 경우가 있을 수 있으며 분산되거나 얽히는 일이 일어날 수 있다.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E이를 해결하기 대처하기 위해 나온 방법론으로 \u003Cstrong\u003E관점 지향 프로그래밍\u003C\u002Fstrong\u003E(AOP, Aspet-Oriented Programming)이 있다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAOP에서의 관점 : 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"자바-프록시\"\u003E\u003Ca href=\"#%EC%9E%90%EB%B0%94-%ED%94%84%EB%A1%9D%EC%8B%9C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E자바 프록시\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E단순한 상황에 적합하다. Ex) 개별 객체나 클래스에서 메서드 호출을 감싸는 경우.\u003C\u002Fli\u003E\n\u003Cli\u003EJDK가 지원하는 동적 프록시는 인터페이스만 지원하며, 클래스 프록시를 사용하려면 CGLIB, ASM. Javassist 같은 바이트 코드 처리 라이브러리가 필요하다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"순수-자바-aop-프레임워크\"\u003E\u003Ca href=\"#%EC%88%9C%EC%88%98-%EC%9E%90%EB%B0%94-aop-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E순수 자바 AOP 프레임워크\u003C\u002Fh3\u003E\n\u003Cp\u003EPOJO는 순수하게 도메인에 초점을 맞추며, 다른 도메인에 의존하지 않는다. 따라서 테스트가 개념적으로 더 쉽고 간단하며, 단순하여 구현에 쉬우며 이후 코드를 보수하고 개선하기 편하다.\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EPOJO(Plain Old Java Object) : 오래된 방식의 간단한 자바 오브젝트라는 말로서 Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 \"무거운\" 객체를 만들게 된 것에 반발해서 사용되게 된 용어\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3 id=\"aspectj-관점\"\u003E\u003Ca href=\"#aspectj-%EA%B4%80%EC%A0%90\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EAspectJ 관점\u003C\u002Fh3\u003E\n\u003Cp\u003EAspectJ는 관심사를 관점으로 분리하는 가장 강력한 도구이다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAspectJ '애너테이션 폼'은 새로운 도구와 새로운 언어의 부담을 제거한다.\u003C\u002Fli\u003E\n\u003Cli\u003E애너테이션이란 주석처럼 프로그래밍에 영향을 미치지 않으며, 유용한 정보를 제공\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"테스트-주도-시스템-아키텍처-구축\"\u003E\u003Ca href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%B6%95\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E테스트 주도 시스템 아키텍처 구축\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E애플리케이션 도메인 논리를 POJO로 작성할 수 있다면 (코드 수준에서 아키텍처 관심사를 분리할 수 있다면), \u003Cstrong\u003E테스트 주도 아키텍처\u003C\u002Fstrong\u003E 구축이 가능하다.\u003C\u002Fli\u003E\n\u003Cli\u003E좋은 웹 사이트 들은 고도의 자료 캐싱, 보안, 가상화 등을 이용해 아주 높은 가용성과 성능을 효율적이고 유연하게 달성한다.\u003C\u002Fli\u003E\n\u003Cli\u003E이를 정리하면, 최선의 시스템 구조는 각기 POJO 객체로 구현되는 모듈화 된 관심사 영역(도메인)으로 구성된다. 이러한 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합하며, 이러한 구조는 테스트 주도 기법을 사용할 수 있다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"의사-결정을-최적화\"\u003E\u003Ca href=\"#%EC%9D%98%EC%82%AC-%EA%B2%B0%EC%A0%95%EC%9D%84-%EC%B5%9C%EC%A0%81%ED%99%94\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E의사 결정을 최적화\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능하다.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E가능한 마지막 순간까지 결정을 미루는 방법이 좋은 경우가 있는데, 이러한 경우에서 옳게 쓰일 수 있다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E즉, 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공하고, 이러한 기민함은 최신 정보에 기반에 최선의 시점에 최적의 결정을 내리는데 도움을 준다. 더불어 결정의 복잡성도 감소한다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"명백한-가치가-있을-때-표준을-현명하게-사용\"\u003E\u003Ca href=\"#%EB%AA%85%EB%B0%B1%ED%95%9C-%EA%B0%80%EC%B9%98%EA%B0%80-%EC%9E%88%EC%9D%84-%EB%95%8C-%ED%91%9C%EC%A4%80%EC%9D%84-%ED%98%84%EB%AA%85%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E명백한 가치가 있을 때 표준을 현명하게 사용\u003C\u002Fh3\u003E\n\u003Cp\u003E표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉬우며 컴포넌트를 엮기 쉽다.\u003C\u002Fp\u003E\n\u003Cp\u003E단점으로는 표준을 만드는 시간이 너무 오래 걸리게 된다면, 다른 업계가 기다리지 못한다. 더불어 표준이 목적을 잃어버리는 경우도 발생한다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"시스템은-도메인-특화-언어가-필요\"\u003E\u003Ca href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%ED%8A%B9%ED%99%94-%EC%96%B8%EC%96%B4%EA%B0%80-%ED%95%84%EC%9A%94\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E시스템은 도메인 특화 언어가 필요\u003C\u002Fh3\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E도메인 특화 언어(DSL, Domain-Specific Language)이란. 간단한 스크립트 언어나 표준 언어로 구현한 API\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cul\u003E\n\u003Cli\u003E좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 '의사소통 간극'을 줄여주며, 도메인을 잘못 구현할 가능성이 줄어든다.\u003C\u002Fli\u003E\n\u003Cli\u003E추상화 수준을 코드 관용구나 디자인 패턴 이상의 효과를 만들어 낼 수 있다.\u003C\u002Fli\u003E\n\u003Cli\u003EDSL을 사용하면 고차원 정책에서 저 차원 세부사항에 이르기까지 모든 추상화 수준과 모든 도메인을 POJO로 표현 가능하다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"결론\"\u003E\u003Ca href=\"#%EA%B2%B0%EB%A1%A0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E결론\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E깨끗한 아키텍처는 도메인 논리를 높여주며, 기민성을 높이고, 제품 품질이 떨어지며, TDD가 제공하는 단점이 사라진다.\u003C\u002Fli\u003E\n\u003Cli\u003EPOJO를 작성하고 관점 등을 통해 관심사를 분리해서 추상화 단계에서의 의도를 명확히 표현해야 한다.\u003C\u002Fli\u003E\n\u003Cli\u003E핵심 중 하나는 \u003Cstrong\u003E실제로 돌아가는 가장 단순한 수단을 사용해야 한다.\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"12장-창발성\"\u003E\u003Ca href=\"#12%EC%9E%A5-%EC%B0%BD%EB%B0%9C%EC%84%B1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E12장. 창발성\u003C\u002Fh2\u003E\n\u003Ch3 id=\"창발적-설계로-깔끔한-코드를-구현\"\u003E\u003Ca href=\"#%EC%B0%BD%EB%B0%9C%EC%A0%81-%EC%84%A4%EA%B3%84%EB%A1%9C-%EA%B9%94%EB%81%94%ED%95%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EA%B5%AC%ED%98%84\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E창발적 설계로 깔끔한 코드를 구현\u003C\u002Fh3\u003E\n\u003Cp\u003E우수한 설계가 나오는 간단한 규칙 4가지\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E모든 테스트를 실행한다\u003C\u002Fli\u003E\n\u003Cli\u003E중복을 없앤다.\u003C\u002Fli\u003E\n\u003Cli\u003E프로그래머 의도를 표현한다.\u003C\u002Fli\u003E\n\u003Cli\u003E클래스와 메서드 수를 최소로 줄인다.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E단 위가 밑보다 중요하다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"단순한-설계-규칙-1-모든-테스트를-실행\"\u003E\u003Ca href=\"#%EB%8B%A8%EC%88%9C%ED%95%9C-%EC%84%A4%EA%B3%84-%EA%B7%9C%EC%B9%99-1-%EB%AA%A8%EB%93%A0-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%8B%A4%ED%96%89\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E단순한 설계 규칙 1: 모든 테스트를 실행\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E설계는 의도한 대로 돌아가야 한다.\u003C\u002Fli\u003E\n\u003Cli\u003E철저한 테스트가 가능한 시스템은 더 나은 설계를 만든다.\u003C\u002Fli\u003E\n\u003Cli\u003E결합도가 높을수록 테스트 케이스를 작성하기 어렵다.\u003C\u002Fli\u003E\n\u003Cli\u003E테스트 케이스를 만들고 돌리는 것 -\u003E 낮은 결합도와 높은 응집력\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"단순한-설계-규칙-24-리팩터링\"\u003E\u003Ca href=\"#%EB%8B%A8%EC%88%9C%ED%95%9C-%EC%84%A4%EA%B3%84-%EA%B7%9C%EC%B9%99-24-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E단순한 설계 규칙 2~4: 리팩터링\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E테스트 케이스를 모두 작성했다면, 코드와 클래스를 점진적으로 정리하면 된다.\u003C\u002Fli\u003E\n\u003Cli\u003E코드를 정리하면서 테스트 케이스를 통해 깨지지 않도록 한다.\u003C\u002Fli\u003E\n\u003Cli\u003E리팩터링 단계에서는 소프트웨어 설계 품질을 높이는 기법을 사용하는 것이 좋다.\u003C\u002Fli\u003E\n\u003Cli\u003E이 단계 동안 중복을 없애고, 프로그래머 의도를 표현하고 클래스와 메서드 수를 줄이는 단계이다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"중복을-없애라\"\u003E\u003Ca href=\"#%EC%A4%91%EB%B3%B5%EC%9D%84-%EC%97%86%EC%95%A0%EB%9D%BC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E중복을 없애라\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E중복은 추가 작업, 추가 위협, 불필요한 복잡도를 의미한다.\u003C\u002Fli\u003E\n\u003Cli\u003ETEMPLATE METHOD 패턴은 고차원 중복을 제거할 목적으로 자주사 사용하는 기법\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003ETemplaet Method Pattern. 동작 상의 알고리즘의 프로그램 뼈대를 정의하는 행위 디자인 패턴, 알고리즘의 구조를 변경하지 않고 알고리즘의 특정 단계들을 다시 정의할 수 있게 해 준다\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3 id=\"표현하기\"\u003E\u003Ca href=\"#%ED%91%9C%ED%98%84%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E표현하기\u003C\u002Fh3\u003E\n\u003Cp\u003E많은 소프트웨어 프로젝트 비용 중 대다수는 장기적인 유지보수에 들어간다.\u003C\u002Fp\u003E\n\u003Cp\u003E이를 해결하는 방법은 다음과 같다.\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E좋은 이름 선택한다.\u003C\u002Fli\u003E\n\u003Cli\u003E함수와 클래스 크기를 가능한 줄인다.\u003C\u002Fli\u003E\n\u003Cli\u003E표준 명칭을 사용한다.\u003C\u002Fli\u003E\n\u003Cli\u003E단위 테스트 케이스를 꼼꼼히 작성한다.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E가장 큰 핵심은 나중에 볼 사람을 위해서 \u003Cstrong\u003E노력\u003C\u002Fstrong\u003E해야 한다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"클래스와-메서드-수를-최소로-줄이기\"\u003E\u003Ca href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%88%98%EB%A5%BC-%EC%B5%9C%EC%86%8C%EB%A1%9C-%EC%A4%84%EC%9D%B4%EA%B8%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E클래스와 메서드 수를 최소로 줄이기\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E너무 중복을 제거하고, 의도를 표현하고, SRP를 준수하는 경우에는 단점이 발생할 수 있다.\u003C\u002Fli\u003E\n\u003Cli\u003E목표는 함수와 클래스 크기를 줄이면서 시스템 크기를 작게 유지하는 것이다.\u003C\u002Fli\u003E\n\u003Cli\u003E단, 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"13장-동시성\"\u003E\u003Ca href=\"#13%EC%9E%A5-%EB%8F%99%EC%8B%9C%EC%84%B1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E13장. 동시성\u003C\u002Fh2\u003E\n\u003Cp\u003E동시성과 깔끔한 코드는 양립하기 아주 어렵다. 깨끗한 동시성은 사실 매우 중요하며, 어려운 문제이다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"동시성이-필요한-이유\"\u003E\u003Ca href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E동시성이 필요한 이유?\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E동시성은 결함(coupling)을 없애는 전략. 즉, \u003Cstrong\u003E무엇\u003C\u002Fstrong\u003E과 \u003Cstrong\u003E언제\u003C\u002Fstrong\u003E를 분리하는 전략이다.\u003C\u002Fli\u003E\n\u003Cli\u003E무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.\u003C\u002Fli\u003E\n\u003Cli\u003E시스템 응답 시간과 작업 처리량 개선으로 인해 동시성이 필요하다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"미신과-오해\"\u003E\u003Ca href=\"#%EB%AF%B8%EC%8B%A0%EA%B3%BC-%EC%98%A4%ED%95%B4\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E 미신과 오해\u003C\u002Fh4\u003E\n\u003Cp\u003E대표적인 오해.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E동시성은 항상 성능을 높여준다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E동시성은 \u003Cstrong\u003E때로\u003C\u002Fstrong\u003E 성능을 높여준다. 즉, 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E동시성을 구현해도 설계는 변하지 않는다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. 일반적으로 \u003Cstrong\u003E무엇\u003C\u002Fstrong\u003E과 \u003Cstrong\u003E언제\u003C\u002Fstrong\u003E를 분리하면 시스템 구조가 달라진다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E실제로는 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지 알아야 한다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E타당한 생각.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E동시성은 사소 부하를 유발한다.\u003C\u002Fstrong\u003E 성능 측면에서 부하가 걸리며, 코드도 더 짜야한다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E동시성은 복잡하다.\u003C\u002Fstrong\u003E 간단한 문제라도 동시성은 복잡하다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E일반적으로 동시성 버그는 제한하기 어렵다.\u003C\u002Fstrong\u003E 그래서 진짜 결함으로 간주 하지 않고 일회성 문제로 여겨 무시하기 쉽다.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"난관\"\u003E\u003Ca href=\"#%EB%82%9C%EA%B4%80\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E난관\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-java\"\u003Epublic class X {\n  private int lastIdUsed;\n\n  public int getNextId() {\n    return ++lastIdUsed;\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E다음과 같은 경우. 인스턴스 X를 생성하고 lastIdUsed를 필드. 42로 설정하는 경우로 보면.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E어떤 스레드는 43을 받고 다른 스레드는 44를 받는데 저장은 제각각이다. 이러한 스레드가 수많이 있다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"동시성-방어-원칙\"\u003E\u003Ca href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%B0%A9%EC%96%B4-%EC%9B%90%EC%B9%99\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E동시성 방어 원칙\u003C\u002Fh3\u003E\n\u003Cp\u003E다양한 방어 원칙과 기술이 있다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"단일-책임-원칙srp-single-reponsibility-priniciple\"\u003E\u003Ca href=\"#%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99srp-single-reponsibility-priniciple\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E단일 책임 원칙(SRP, Single Reponsibility Priniciple)\u003C\u002Fh4\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003ESRP는 주어진 메서드\u002F클래스\u002F컴포넌트를 변경할 이유가 하나여야 한다는 원칙\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E동시성은 복잡성 하므로 다른 코드와 분리해야 한다. 아래는 고려해야 할 사항이다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.\u003C\u002Fli\u003E\n\u003Cli\u003E동시성 코드에는 독자적인 난관이 있으며 이는 더 어렵다.\u003C\u002Fli\u003E\n\u003Cli\u003E잘못 구현된 동시성 코드는 온갖 에러가 발생한다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E따라서. 동시성 코드는 다른 코드와 분리한다.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch4 id=\"따름-정리corollary--자료-범위를-제한해라\"\u003E\u003Ca href=\"#%EB%94%B0%EB%A6%84-%EC%A0%95%EB%A6%ACcorollary--%EC%9E%90%EB%A3%8C-%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%A0%9C%ED%95%9C%ED%95%B4%EB%9D%BC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E따름 정리(corollary) : 자료 범위를 제한해라\u003C\u002Fh4\u003E\n\u003Cp\u003E공유 객체를 사용하는 코드 \u003Cstrong\u003E임계 영역(critical\u003C\u002Fstrong\u003E section)을 synchronized 키워드로 보호하는 것뿐만 아니라, 이 수를 줄여야 한다.\u003C\u002Fp\u003E\n\u003Cp\u003E수가 많으면 다음과 같은 문제가 발생한다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E보호할 임계 영역을 빼먹어서 해당 자료를 수정하는 모든 코드가 망가진다.\u003C\u002Fli\u003E\n\u003Cli\u003E모든 임계 영역을 올바로 보호했는지 확인하느라 똑같은 노력과 수고가 필요하다.\u003C\u002Fli\u003E\n\u003Cli\u003E찾기 어려운 버그를 더 찾기 힘들어진다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E따라서. 자료를 캡슐화해야 하며, 공유 자료를 최대한 줄여야 한다.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch4 id=\"따름-정리--자료-사본을-사용하기\"\u003E\u003Ca href=\"#%EB%94%B0%EB%A6%84-%EC%A0%95%EB%A6%AC--%EC%9E%90%EB%A3%8C-%EC%82%AC%EB%B3%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E따름 정리 : 자료 사본을 사용하기\u003C\u002Fh4\u003E\n\u003Cp\u003E공유 자료를 줄이는 최고의 방법은 공유하지 않은 방법이다. 즉, 객체를 복사해서 읽는 방법도 존재한다. 객체를 복사하는 비용이 그렇게 크지않다면 나쁘지 않는 방법이다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"따름-정리--스레드는-가능한-독립적으로-구현하라\"\u003E\u003Ca href=\"#%EB%94%B0%EB%A6%84-%EC%A0%95%EB%A6%AC--%EC%8A%A4%EB%A0%88%EB%93%9C%EB%8A%94-%EA%B0%80%EB%8A%A5%ED%95%9C-%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9C%BC%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%98%EB%9D%BC\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E따름 정리 : 스레드는 가능한 독립적으로 구현하라\u003C\u002Fh4\u003E\n\u003Cp\u003E다른 스레드와 공유하지 않는 독립적인 스레드를 구성해라. (예를 들면 로컬 변수 등)\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E따라서, 독자적인 스레드로, 가능하다면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할한다.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"라이브러리를-이해하기\"\u003E\u003Ca href=\"#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E라이브러리를 이해하기.\u003C\u002Fh3\u003E\n\u003Cp\u003E자바 5에서 스레드를 구현한다면 다음을 고려해보기.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E스레드 환경에 안전한 컬렉션을 사용.\u003C\u002Fli\u003E\n\u003Cli\u003E서로 무관한 작업을 수행할 때는 executor 프레임워크 사용.\u003C\u002Fli\u003E\n\u003Cli\u003E가능하다면 스레드가 차단(blocking) 되지 않는 방법을 사용.\u003C\u002Fli\u003E\n\u003Cli\u003E일부 클래스 라이브러리는 스레드에 안전하지 못함.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"스레드-환경에-안전한-컬렉션\"\u003E\u003Ca href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%99%98%EA%B2%BD%EC%97%90-%EC%95%88%EC%A0%84%ED%95%9C-%EC%BB%AC%EB%A0%89%EC%85%98\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E스레드 환경에 안전한 컬렉션\u003C\u002Fh4\u003E\n\u003Cp\u003E다중 스레드에서 안전한 메소드로 여러 가지 존재한다.\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003E이름\u003C\u002Fth\u003E\n\u003Cth\u003E설명\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EConcurrentHashMap\u003C\u002Ftd\u003E\n\u003Ctd\u003EHashMap보다 거의 모든 상황에서 빠르다.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EReentrantLock\u003C\u002Ftd\u003E\n\u003Ctd\u003E한 메서드에서 잠그고 다른 메서드에서 푸는 락(lock)이다.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003ESemaphore\u003C\u002Ftd\u003E\n\u003Ctd\u003E전형적인 세마포어, 개수(count)가 있는 락이다.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003ECountDownLatch\u003C\u002Ftd\u003E\n\u003Ctd\u003E지정한 수만큼 이벤트가 발생하고 대기 중인 스레드를 모드 해제하는 락.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E모든 스레드에게 동시에 공평하게 시작할 권리를 제공\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\n\u003Ch3 id=\"실행-모델을-이해하기\"\u003E\u003Ca href=\"#%EC%8B%A4%ED%96%89-%EB%AA%A8%EB%8D%B8%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E실행 모델을 이해하기.\u003C\u002Fh3\u003E\n\u003Cp\u003E간단한 기본 용어는 다음과 같다.\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003E이름\u003C\u002Fth\u003E\n\u003Cth\u003E설명\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E한정된 자원 (Bound Resource)\u003C\u002Ftd\u003E\n\u003Ctd\u003E다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E데이터 베이스 연결, 길이가 일정한 읽기\u002F쓰기 버퍼 등이 예시이다.\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E상호 배제 (Mutual Exclusion)\u003C\u002Ftd\u003E\n\u003Ctd\u003E한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E기아 (Starvation)\u003C\u002Ftd\u003E\n\u003Ctd\u003E한 스레드나 여러 스레드가 굉장히 오랫동안 호은 영원한 자원을 기다린다.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E예를 들어, 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속적으로 이루어지는 경우, 긴 스레드가 기아 상태에 빠진다.\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E데드락 (Deadlock)\u003C\u002Ftd\u003E\n\u003Ctd\u003E여러 스레드가 서로가 끝나기를 기다린다.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느쪽도 더이상 진행하지 못한다.\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E라이브락 (Livelock)\u003C\u002Ftd\u003E\n\u003Ctd\u003E락을 거는 단계에서 각 스레드가 서로를 방해한다.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E스레드는 계속해서 진행하려 하지만, 공명(response)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\n\u003Cp\u003E다중 스레드 프로그래밍에서 실행하는 방법은 대부분 아래의 3가지 방법이다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"생산자-소비자producer-consumer\"\u003E\u003Ca href=\"#%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90producer-consumer\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E생산자-소비자(Producer-Consumer)\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F92720407-84b49c00-f39f-11ea-971b-582f1952a73a.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E다음 그림처럼 \u003Cstrong\u003E한정적 자원\u003C\u002Fstrong\u003E을 생산자는 정보를 생성하고, 소비자는 정보를 사용한다.\u003C\u002Fp\u003E\n\u003Cp\u003E생산자 스레드는 정보를 채우고 시그널을 보내고, 소비자는 대기열에 정보를 읽은 후 시그널을 보낸다. 단, 동시에 시그널을 기다릴 가능성 또한 존재한다.\u003C\u002Fp\u003E\n\u003Ch4 id=\"읽기-쓰기readers-writers\"\u003E\u003Ca href=\"#%EC%9D%BD%EA%B8%B0-%EC%93%B0%EA%B8%B0readers-writers\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E읽기-쓰기(Readers-Writers)\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F92720672-e412ac00-f39f-11ea-9905-8e06721b39ab.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E읽기 스레드가 공유 자원을 사용하지만, 처리율이 부족한 경우 기아 현상이나 오래된 정보가 쌓인다.\u003C\u002Fp\u003E\n\u003Cp\u003E이러한 처리율을 높이는 방법은 여러 가지가 있는데.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E간단한 전략 : 읽기 스레드가 없을 때까지 쓰기 스레드가 버퍼를 기다리는 방법, 하지만 쓰기 스레드가 기아 발생 가능.\u003C\u002Fli\u003E\n\u003Cli\u003E이러한 방법을 갱신하는 밥법은 \"\u003Cstrong\u003E식사하는 철학자들\u003C\u002Fstrong\u003E\" 방법이 있다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"식사하는-철학자들dining-philosopheres\"\u003E\u003Ca href=\"#%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4dining-philosopheres\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E식사하는 철학자들(Dining Philosopheres)\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F42582516\u002F92725422-196ec800-f3a7-11ea-8f11-9ff2bbac63f6.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E여기서 철학자는 스레드이고, 포크는 자원이다. 여기서, 자원을 얻으려면 몇몇의 스레드는 쉬어야 하는 것을 알 수 있다.\u003C\u002Fp\u003E\n\u003Cp\u003E단 이와 같은 설계를 할 때는 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 고려해서 사용해야 한다.\u003C\u002Fp\u003E\n\u003Ch3 id=\"동기화하는-메서드-사이에-존재하는-의존성을-이해\"\u003E\u003Ca href=\"#%EB%8F%99%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%82%AC%EC%9D%B4%EC%97%90-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%84-%EC%9D%B4%ED%95%B4\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E동기화하는 메서드 사이에 존재하는 의존성을 이해\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E공유 객체 하나에는 메서드 하나만 사용하기.\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E공유 객체 하나에 여러 메서드가 필요한 경우는 다음과 같은 세 가지 방법을 고려한다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E클라이언트에서 잠금 : 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠금. 마지막 메서드를 호출할 때까지 잠금을 유지한다\u003C\u002Fli\u003E\n\u003Cli\u003E서버에서 잠금 : 서버에다 \"서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는\" 메서드를 구현. 클라이언트는 이 메서드를 구현\u003C\u002Fli\u003E\n\u003Cli\u003E연결(Adapted) 서버 : 잠금을 수행하는 중간 단계를 생성. '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경하지 않음\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"동기화하는-부분을-작게-만들기\"\u003E\u003Ca href=\"#%EB%8F%99%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84%EC%9D%84-%EC%9E%91%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E동기화하는 부분을 작게 만들기\u003C\u002Fh3\u003E\n\u003Cp\u003E필요 이상으로 임계 영역 크기를 키우면 스레드 간 경쟁이 늘어나고 프로그램 성능이 떨어진다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E따라서. 동기화하는 부분을 최대한 작게 만든다.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"올바른-종료-코드는-구현하기-어렵다\"\u003E\u003Ca href=\"#%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%A2%85%EB%A3%8C-%EC%BD%94%EB%93%9C%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-%EC%96%B4%EB%A0%B5%EB%8B%A4\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E올바른 종료 코드는 구현하기 어렵다\u003C\u002Fh3\u003E\n\u003Cp\u003E데드락에 걸려서 종료 코드가 안 갈 수도 있다. 따라서 \u003Cstrong\u003E종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현해야 한다. 생각보다 오래 걸리고 어려우므로 나온 알고리즘을 검토하는 것도 좋은 방법이다.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"스레드-코드-테스트하기\"\u003E\u003Ca href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E스레드 코드 테스트하기\u003C\u002Fh3\u003E\n\u003Cp\u003E하나의 스레드에서는 이전에 했던 모든 말 들이 통용되지만, 여러 스레드에서의 상황은 복잡하다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E따라서. 문제를 노출하는 테스트 케이스를 작성한다. 프로그램 설정과 시스템 설정과 부하를 바꿔가면서 자주 돌리고 테스트가 실패할 경우 원인을 추적해야 한다. 다시 돌렸더니 통과한다는 이유로 넘어가면 안 된다.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E구체적인 지침은 다음과 같다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E말이 안 되는 실패를 잠정적인 스레드 문제로 취급하기\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E시스템 실패를 '일회성'이라고 취급하지 말기.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들기\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하면 안 된다. 먼저 스레드 환경 밖부터 해결해야 한다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정해주기\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E프로그램 처리율과 효율에 따라 스레드 개수를 조율하는 코드도 고민해보기\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E프로세서 수보다 많은 스레드 돌려보기\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E스와핑이 잦을수록 임계 영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E다른 플랫폼에서 돌려보기\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려보는 것이 좋다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E코드에 보조 코드(instruction)를 넣어 돌리기. 강제로 실패 만들기.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E방법 1. 직접 구현하기\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E코드에다 wait(), sleep(), yield(), probity() 함수를 추가하기.\u003C\u002Fli\u003E\n\u003Cli\u003E생각했는 결과물과 맞는지 체크하기.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E방법 2. 자동화\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAOP(Aspect-Oriented Framework), CGLIB, ASM 등의 도구를 사용\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E흔들기 기법\u003C\u002Fstrong\u003E(jiggle) 등을 사용해 오류를 찾는 것도 좋다. 이를 사용하면 스레드를 매번 다른 순서로 실행한다.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"결론-1\"\u003E\u003Ca href=\"#%EA%B2%B0%EB%A1%A0-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E결론.\u003C\u002Fh3\u003E\n\u003Cp\u003E핵심은 다음과 같다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ESRP를 준수하기\u003C\u002Fli\u003E\n\u003Cli\u003E동시성 오류를 일으키는 잠정적 원인을 정학하게 이해\u003C\u002Fli\u003E\n\u003Cli\u003E사용하는 라이브러리와 기본 알고리즘을 정확히 이해\u003C\u002Fli\u003E\n\u003Cli\u003E보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n","cover_image":{"type":"image","mimeType":"image\u002Fjpeg","src":"\u002Fblog\u002Fassets\u002Fstatic\u002FCleancodeBook.07cc2b7.7222e95f3717f77d5f3ed287711f1d64.jpg","size":{"width":860,"height":1021},"sizes":"(max-width: 860px) 100vw, 860px","srcset":["\u002Fblog\u002Fassets\u002Fstatic\u002FCleancodeBook.a67b0b2.7222e95f3717f77d5f3ed287711f1d64.jpg 480w","\u002Fblog\u002Fassets\u002Fstatic\u002FCleancodeBook.07cc2b7.7222e95f3717f77d5f3ed287711f1d64.jpg 860w"],"dataUri":"data:image\u002Fsvg+xml,%3csvg fill='none' viewBox='0 0 860 1021' xmlns='http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg' xmlns:xlink='http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-2da16ebb829634911838dadcc8b5c487'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='10'\u002F%3e%3c\u002Ffilter%3e%3c\u002Fdefs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-2da16ebb829634911838dadcc8b5c487)' width='860' height='1021' xlink:href='data:image\u002Fjpeg%3bbase64%2c\u002F9j\u002F2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj\u002F2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj\u002FwAARCABMAEADASIAAhEBAxEB\u002F8QAGwAAAgMBAQEAAAAAAAAAAAAABAUCAwYAAQj\u002FxAAxEAACAQMDAQUGBgMAAAAAAAABAgMABBESITFBBRMzUWEGFCIycZEVFkKhwfBigdH\u002FxAAXAQEBAQEAAAAAAAAAAAAAAAAAAQID\u002F8QAGREBAQEBAQEAAAAAAAAAAAAAAAERAhIx\u002F9oADAMBAAIRAxEAPwD6pql7qGN9MkiISwUamAyT0HnV1Y3tiCS59tOzkjkChAJCp2yFck9M8Cg15lUSBCy6z0zUs45BoK57v3kh2YEqMHoDvjNeESKpMc4YBR%2brJ\u002FvO9Y9NYO1L517zS3XdBA2nVnG2K8jllaTS8enrkZqzpMM66s1e%2b01lZSrG8szMXKHRGTpx1OenTIrRQsWiVjya0idJrm3mk7Zs54XjWOGR%2b9VlGp1ZMAA488HGRTms9f3fc%2b03ZdqIo3Ny8xLMCSoRAdug%2bYc5\u002FmgZ3LYuWHdhgUGojkDf7VVKIWViupWIGAw2\u002FvFM8A8gb1XJDGynKgEjGQOlc7xrUpYyR7aJ9OOdiOagQ%2b%2bi6Ugf5f8AaOa1i0BdJwPWqJLSI9D96eaaDlE2j41jkXyIDU7tvAT6UpazQHZmA8qbW3gJWuZZ9SrKzPaXdfm7sQsjNMDchCGwACi6tsb9Oo\u002F3xWmpPN2Wl327Z9oNLIr2JlCovyv3igHP0xWkOKHdLklyJYwNtI0fzmiKqnnjiAEjYJ4GM0tz6ArRL1Wb3uRGGTgDy%2bwq9%2btS71HKhWB1DUPUVF%2btBS1G23gJQbUZbeAlBZQ8Dr7xMmRqJzj0q55EQfEwFILm%2bEPtDYBQzrOZI9mxjjcjrx%2b9BoaDkdYb12lOkMgCk\u002FvRlBz6p7kw6yqKuo45JrPSwJO3DQIUzExA68jeqGPwEB8xlxjDNgbefJo5nlhCRHEkrE6STjb1qk3LvhI0USfFqBOwxWMaBYdotRL6ljUjc85NP7bwFpElzIsUaqNRCgnIJJyaeWvgJWuMTpXdWwlU4ODQdvZyJJHqEOEYkl1y31U9Ka11bZdkeYoaeJjL3sEgV8aTkZBFE11SzSXABtG0oVdhKpJ14znPO1RNhsulnDDOWBALZ5pjXVPMXaW\u002FhgwoyQAMfNyPWmEKlI1U7kVKuqySfEf\u002F2Q==' \u002F%3e%3c\u002Fsvg%3e"}}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/blog/assets/js/app.672b1d96.js" defer></script><script src="/blog/assets/js/page--src--templates--post-vue.238f89b8.js" defer></script>
  </body>
</html>