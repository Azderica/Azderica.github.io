{"hash":"0cbdbe3ad78e6929600cc32326d49aab3f1f64f3","data":{"post":{"title":"[Architecture] MSA 개념 잡기","path":"/00-architecture-msa/","date":"21. December 2020","timeToRead":4,"tags":[{"id":"Architecture","title":"Architecture","path":"/tag/Architecture/"},{"id":"MSA","title":"MSA","path":"/tag/MSA/"},{"id":"micro service architecture","title":"micro service architecture","path":"/tag/micro%20service%20architecture/"}],"description":" 마이크로 서비스 아키텍처에 대한 개념을 정리합니다 ","content":"<h1 id=\"microservice-architecture\"><a href=\"#microservice-architecture\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Microservice Architecture</h1>\n<p>크게 아키텍처는 Monolithic Architecture과 Microservice Architecture 등으로 구성됩니다. 그러나 많은 회사들이 Monolithic 아키텍처의 단점으로 인해 MSA 아키텍처로 넘어가기 위해 노력하려고 합니다. 오늘은 그 차이에 대해 정리하고, 그 개념에 대해 정리해볼려고 합니다.</p>\n<br/>\n<h2 id=\"msa의-등장\"><a href=\"#msa%EC%9D%98-%EB%93%B1%EC%9E%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 등장</h2>\n<p>MSA는 microservice architecture의 약자로서, <strong>하나의 큰 어플리케이션을 여러개의 작은 어플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처</strong> 입니다.</p>\n<h3 id=\"기존-monolithic의-한계\"><a href=\"#%EA%B8%B0%EC%A1%B4-monolithic%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>기존 Monolithic의 한계</h3>\n<blockquote>\n<p>왜 필요할까요?</p>\n</blockquote>\n<p>기존의 서비스는 Monolithic Architecture의 구조를 가지고 있었습니다. </p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102787038-cebc0d80-43e3-11eb-9a67-829adb6ebe51.png\" alt=\"monolithic-vs-msa\"></p>\n<p>Monolithic Architecture은 소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어 있는 서비스입니다. 현재 많은 회사들의 소프트웨어가 <strong>레거시</strong> 또는 필요로 인해서 Monolithic 형태로 구현되어 있습니다.</p>\n<p>소규모의 프로젝트에서는 Monolithic 형태는 간단하며, 유지보수가 편하기 때문에 선호됩니다.</p>\n<p>그러나 일정 규모 이상을 넘어가면 Monolithic은 많은 한계점에 봉착합니다.</p>\n<ul>\n<li>전체 시스템 구조 파악의 문제</li>\n<li>빌드 시간 및 테스트, 배포 시간의 급증</li>\n<li>서비스의 특정 부분만 scale-out을 하기 어렵습니다.</li>\n<li><strong>부분의 장애가 전체 서비스의 장애로 이어질 수도 있습니다.</strong></li>\n</ul>\n<p>이러한 이유로 인해서, MSA가 등장하게 되었습니다.</p>\n<br/>\n<h2 id=\"msa의-정의\"><a href=\"#msa%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 정의</h2>\n<p>MSA의 핵심은 <strong>small services, each running in its own process</strong> + <strong>independently deployable</strong> 으로 표현할 수 있습니다.</p>\n<p>이를 번역한다면, <strong>스스로 돌아갈 수 있는 서비스</strong>와 <strong>독립적인 배포 기능</strong>입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102787740-e8118980-43e4-11eb-8760-c52424630810.png\" alt=\"architecture-diff\"></p>\n<p>soa를 추가해서 좀 더 자세하게 보자면.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102787984-4474a900-43e5-11eb-8a27-4e60f3aecfca.png\" alt=\"architecture-diff-2\"></p>\n<p>다음과 같이 구성됩니다.</p>\n<br/>\n<h2 id=\"msa의-장단점\"><a href=\"#msa%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 장단점</h2>\n<h3 id=\"msa의-장점\"><a href=\"#msa%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 장점</h3>\n<h4 id=\"1-배포\"><a href=\"#1-%EB%B0%B0%ED%8F%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 배포</h4>\n<ul>\n<li>서비스 별 개별 배포가 가능합니다. (배포 시 전체 서비스의 중단이 없습니다.)</li>\n<li>요구사항을 반영하여 빠르게 배포 가능합니다.</li>\n</ul>\n<h4 id=\"2-확장\"><a href=\"#2-%ED%99%95%EC%9E%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 확장</h4>\n<ul>\n<li>특정 서비스에 대한 확장성이 유리합니다. (scale-out)</li>\n<li>클라우드 사용 시 적합합니다.</li>\n</ul>\n<h4 id=\"3-장애-해결error-handling\"><a href=\"#3-%EC%9E%A5%EC%95%A0-%ED%95%B4%EA%B2%B0error-handling\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 장애 해결(Error Handling)</h4>\n<ul>\n<li>일부 장애가 전체 서비스로 확장될 가능성이 적습니다.</li>\n<li>부분적으로 발생하는 장애에 대해 격리가 수월합니다.</li>\n</ul>\n<h4 id=\"4-그-외\"><a href=\"#4-%EA%B7%B8-%EC%99%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>4. 그 외</h4>\n<ul>\n<li>새로운 기술을 적용하기 유연합니다.</li>\n<li>서비스를 polyglot(여러 언어를 사용하여)하게 개발 및 운영할 수 있습니다.</li>\n</ul>\n<h3 id=\"msa의-단점\"><a href=\"#msa%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 단점</h3>\n<h4 id=\"1-성능-이슈\"><a href=\"#1-%EC%84%B1%EB%8A%A5-%EC%9D%B4%EC%8A%88\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 성능 이슈</h4>\n<ul>\n<li>서비스 간 호출 시 API를 사용하므로, 통신 비용이나 Latency에 대해 이슈가 존재합니다. 다만 일반적으로 Monolithic에서 MSA로 넘어오는 이유가 Monolithic으로 더이상 성능적인 한계에 봉착했을 때 넘어오는 느낌이 있습니다...</li>\n<li>최근 우아한 테크 컨퍼런스에서는 이벤트 발행을 통해서 해당 부분을 해결했다고 했는데 이부분은 한번 참고해서 보면 좋을 듯 합니다.</li>\n</ul>\n<h4 id=\"2-테스트--트랜잭션\"><a href=\"#2-%ED%85%8C%EC%8A%A4%ED%8A%B8--%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 테스트 / 트랜잭션</h4>\n<ul>\n<li>서비스가 분리되어 있어 테스트와 트랜잭션의 복잡도가 증가합니다.</li>\n<li>많은 자원이 필요합니다.</li>\n</ul>\n<h4 id=\"3-데이터-관리\"><a href=\"#3-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 데이터 관리</h4>\n<ul>\n<li>데이터가 여러서비스에 분산되어 조회하기 어렵습니다.</li>\n<li>데이터를 관리하기 어렵습니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간단하게 MSA에 대해 개념을 잡았습니다. 다음에는 이 MSA에 대한 개념을 바탕으로 SAGA 패턴과 CQRS 패턴에 대해 작성하겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e</a></li>\n<li><a href=\"https://www.samsungsds.com/kr/insights/msa.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.samsungsds.com/kr/insights/msa.html</a></li>\n</ul>\n","cover_image":null}},"context":{}}