{"hash":"4d08d5d9909bc52ba8ae53ab8b5e8ea790bc2d53","data":{"tag":{"title":"Database","belongsTo":{"edges":[{"node":{"title":"[DB] Redis의 개념과 특징, 아키텍처","path":"/01-db-nosql-redis/","date":"15. September 2021","timeToRead":9,"description":"Nosql 중 Redis에 대해 좀 더 자세하게 알아봅니다.","content":"<h1 id=\"redis를-좀-더-자세하게\"><a href=\"#redis%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis를 좀 더 자세하게.</h1>\n<p>지난번 게시글에서는 <a href=\"https://azderica.github.io/00-db-nosql/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL</a>에 대한 기본 개념과 종류에 대해서 정리했습니다.</p>\n<p>이번에는 더 나아가서 대표적인 NoSQL이 가지는 아키텍처를 정리합니다. 오늘은 Redis에 대해 좀 더 정리하려고합니다.</p>\n<h2 id=\"redis란\"><a href=\"#redis%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis란.</h2>\n<ul>\n<li>고 성능의 키-값 데이터 구조 스토어입니다.</li>\n<li>여러 자료구조를 지원하며 크게 <code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 등의 데이터 형식을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis-특징\"><a href=\"#redis-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 특징</h2>\n<ul>\n<li>\n<p>영속성을 지원하는 인메모리 데이터 저장소</p>\n<ul>\n<li>왜 영속성을 제공하는지는 아래에서 설명합니다.</li>\n</ul>\n</li>\n<li>\n<p>읽기 성능 증대를 위한 서버 측 복제를 지원합니다.</p>\n<ul>\n<li>전체 데이터베이스의 초기 복사본을 받는 마스터/슬레이브 복제를 지원합니다.</li>\n<li>마스터에서 쓰기가 수행되면 슬레이브 데이터 세트를 실시간으로 업데이터하기 위해 연결된 모든 슬레이브로 전송됩니다.</li>\n</ul>\n</li>\n<li>쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding)을 지원합니다.</li>\n<li><code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 과 같은 다양한 데이터형을 지원합니다.</li>\n</ul>\n<blockquote>\n<p>샤딩(Sharding)</p>\n</blockquote>\n<p>파티셔닝과 동일하며, 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미합니다.</p>\n<br/>\n<h2 id=\"redis-특징-1\"><a href=\"#redis-%ED%8A%B9%EC%A7%95-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 특징</h2>\n<h3 id=\"key-value-store\"><a href=\"#key-value-store\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Key-Value Store</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133774329-00ddf3c0-a24e-40b0-9dd8-460616ea5400.png\" alt=\"Redis-is-map\"></p>\n<ul>\n<li>Redis는 거대한 맵(Map) 데이터 저장소입니다.</li>\n<li>Redis는 익히기 쉬우며 직관적입니다. 그러나, 데이터를 레디스 자체 내에서는 처리하기 어렵습니다.</li>\n</ul>\n<h3 id=\"다양한-데이터-타입\"><a href=\"#%EB%8B%A4%EC%96%91%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>다양한 데이터 타입</h3>\n<ul>\n<li><code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 등의 타입을 지원합니다.</li>\n</ul>\n<h3 id=\"persistence\"><a href=\"#persistence\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Persistence</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133775761-c7644499-ae6f-4aa8-bd25-8208780c41e0.png\" alt=\"Redis-Persistence\"></p>\n<ul>\n<li>Redis는 영속성을 가집니다.</li>\n<li>Redis는 데이터를 disk에 저장할 수 있습니다. 따라서 Redis는 서버가 강제 종료되고 재시작하더라도 disk에 저장해놓은 데이터를 다시 읽어서 데이터가 유실되지 않습니다.</li>\n<li>\n<p>redis의 데이터를 disk에 저장하는 방식은 <strong>snapshot, AOF</strong> 방식이 있습니다.</p>\n<ul>\n<li><code class=\"language-text\">Snapshot</code> : RDB와 비슷하게 어떤 특정 시점의 데이터를 Disk에 담는 방식을 뜻합니다. <strong>Blocking</strong> 방식의 <strong>SAVE</strong>와 <strong>Non-blocking</strong> 방식의 <strong><a href=\"http://redisgate.kr/redis/server/bgsave.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">BGSAVE</a></strong> 방식이 있습니다.</li>\n<li><code class=\"language-text\">AOF</code> : Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태입니다. 서버가 재시작 시 write/update를 순차적으로 재실행하고 데이터를 복구합니다.</li>\n<li>가장 좋은 방식은 두 방법을 혼용해서 사용하는 방법으로 주기적으로 snapshot으로 백업을 하고 다음 snapshot까지의 저장을 AOF 방식으로 수행하는 방식입니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ansi-c로-작성\"><a href=\"#ansi-c%EB%A1%9C-%EC%9E%91%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ANSI C로 작성</h3>\n<ul>\n<li>C언어로 작성되어 Java와 같이 가상머신 위에서 동작하는 언어에서 발생하는 성능 문제에서 자유롭습니다.</li>\n</ul>\n<h3 id=\"서버측-복제-및-샤딩-지원\"><a href=\"#%EC%84%9C%EB%B2%84%EC%B8%A1-%EB%B3%B5%EC%A0%9C-%EB%B0%8F-%EC%83%A4%EB%94%A9-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서버측 복제 및 샤딩 지원</h3>\n<ul>\n<li>읽기 성능 증대를 위해 서버 측 복제를 지원합니다.</li>\n<li>쓰기 성능 증대를 위해 클라이언트 측 샤딩을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis의-장점\"><a href=\"#redis%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis의 장점</h2>\n<ul>\n<li>리스트, 배열과 같은 데이터를 처리하는데 유용합니다.</li>\n<li>Message Queue, Shared Memory, Remote Dictionary(RDBMS의 캐시 솔루션 / read 속도가 매우 빠릅니다.) 용도로 사용됩니다.</li>\n<li>메모리를 활용하면서 데이터를 보존합니다.</li>\n<li>Redis Server는 1개의 싱글 쓰레드로 수행되며, 서버 하나에 여러개의 서버를 띄우는 것이 가능합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis-아키텍처-구성\"><a href=\"#redis-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 아키텍처, 구성</h2>\n<ul>\n<li>HA(High Availability) : 무중단 서비스 등</li>\n</ul>\n<h3 id=\"standalone--no-ha-마스터\"><a href=\"#standalone--no-ha-%EB%A7%88%EC%8A%A4%ED%84%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Standalone : No HA, 마스터</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133778042-cf59f712-752a-4c61-8a1a-b9ac435726a1.png\" alt=\"Redis-Standalone\"></p>\n<ul>\n<li>레디스 서버 1대로 구성하며 이를 마스터 노드라고 합니다.</li>\n<li>서버 다운시 AOF 또는 Snapshot 파일을 이용해 재 시작합니다.</li>\n</ul>\n<h3 id=\"replication--half-ha-마스터-슬레이브\"><a href=\"#replication--half-ha-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%AC%EB%A0%88%EC%9D%B4%EB%B8%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Replication : Half HA, 마스터-슬레이브</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133778753-41bfa929-aa5f-48e5-9509-7e4df1379baa.png\" alt=\"Redis-Replication\"></p>\n<ul>\n<li>레디스 서버 2대(마스터-슬레이브)로 구성됩니다. 슬레이브는 마스터의 데이터를 실시간으로 전달받아 보관합니다.</li>\n<li>마스터 다운 시 슬레이브 서버를 통해 서비스를 계속할 수 있습니다. 하지만, 이때는 수동으로 슬레이브 서버를 마스터로 변경해야합니다.</li>\n<li>한 마스터에 슬레이브를 여러 대 구성할 수 도 있습니다.</li>\n</ul>\n<h3 id=\"이중화--센티널sentinel--ha-무중단-서비스-가능\"><a href=\"#%EC%9D%B4%EC%A4%91%ED%99%94--%EC%84%BC%ED%8B%B0%EB%84%90sentinel--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>이중화 + 센티널(Sentinel) : HA, 무중단 서비스 가능</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133779960-5c97207f-75d7-405c-a4ea-730bba593e2d.png\" alt=\"image\"></p>\n<ul>\n<li>마스터-슬레이브 구성에 <strong>센티널</strong>을 추가해서 각 서버를 감시하도록하며, 센티널은 마스터 서버를 감시하고 있다가 다운되면 슬레이브를 마스터로 승격시킵니다.</li>\n<li>다운된 마스터가 다시 시작되면 센티널이 슬레이브로 전환시킵니다.</li>\n<li>레디스 마스터 노드가 모든 데이터를 가지고 있으며 슬레이브는 마스터에 대한 복제본을 유지하고 있으며, 데이터를 분산하지 않습니다.</li>\n<li>일반적으로 레디스 센티널은 레디스 서버마다 하나씩 설치하며, 레디스 서버와 분리된 프로세스이며 다른 포트를 사용합니다. (데이터를 처리하지 않습니다.)</li>\n<li>레디스 센티널은 높은 가용성과 자동 fail over 을 해결하지만 <strong>데이터 분산 문제를 해결하지 못합니다.</strong></li>\n</ul>\n<p><a href=\"https://hub.docker.com/r/erichsu/redis-sentinel/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Sentinel Docker</a></p>\n<h3 id=\"레디스-클러스터cluster--ha-무중단-서비스-가능\"><a href=\"#%EB%A0%88%EB%94%94%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0cluster--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>레디스 클러스터(Cluster) : HA, 무중단 서비스 가능</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133781464-16c21b85-1ca2-4e0f-8028-5acf9a37a2f8.png\" alt=\"Redis-Cluster-Type-1\"></p>\n<p>머신 하나가 죽었을 시 해결이 됩니다. 다만 두개가 죽으면 해결이 안됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133782017-fe094509-ed9a-419c-9739-35a766b4e334.png\" alt=\"Redis-Cluster-Type-2\"></p>\n<p>위의 문제를 해결하는 방법입니다.</p>\n<ul>\n<li>\n<p><strong>샤딩</strong></p>\n<ul>\n<li>클라스터는 <strong>샤딩</strong>(sharding, 대량의 데이터를 처리하기 위해 여러 개의 데이터베이스에 분할하는 기술) 방법을 제공하는 방법입니다.</li>\n<li>100개의 데이터를 1번 마스터에 33개, 2번 마스터 33개, 3번 마스터에 나머지 34개가 저장되는 방식입니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>Hash 함수</strong></p>\n<ul>\n<li>데이터를 나누는 방식은 키에 hash 함수를 적용해서 값을 추출하고, 이 값을 각 마스터 서버에 할당합니다.</li>\n<li>클러스터 구성시 해쉬 함수를 통해서 1~33까지를 1번 서버, 34~ 66번까지를 2번 서버, 3번 서버는 또 다르게 할당됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>해시 슬록(16384 슬롯)</strong></p>\n<ul>\n<li>레디스에서 hash 값의 개수는 16384(0~16383)이고 슬롯(slot)이라고 합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>해시 태그</strong></p>\n<ul>\n<li>다중 키 작업을 진행하려면 동일 노드에 저장될 모든 키가 필요합니다. 해시 태그는 레디스 클러스터에서 다중키를 사용할 수 있는 유일한 방법입니다.</li>\n<li>해시 함수를 적용해 동일한 해시 슬롯에 여러 개의 키 이름을 저장할 수 있도록 사용됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>레디스 클라이언트</strong></p>\n<ul>\n<li>클라이언트는 서버와 동일한 hash 함수를 가지고 있으며 마스터 서버에 접속해서 각 서버에 할당된 슬롯 정보를 가지고 있습니다.</li>\n<li>키가 입력되면 hash 함수를 적용해서 어느 마스터에 저장할지 판단해서 해당 마스터에 저장합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>데이터 서버 + 센티널</strong></p>\n<ul>\n<li>각 마스터 서버는 데이터의 처리와 센티널의 역할을 같이수행합니다.</li>\n<li>1번 마스터 서버가 다운되면 나머지 살아있는 마스터들 중에서 리더를 선출해서 리더가 1번 마스터의 슬레이브를 마스터로 승격시킵니다.</li>\n</ul>\n</li>\n<li>\n<p>최소 3대</p>\n<ul>\n<li>마스터 서버는 최소 3대로 구성하고 각각은 슬레이브를 가질 수 있습니다.</li>\n</ul>\n</li>\n<li>마스터를 관리하는 마스터는 없습니다. 이는 또 하나의 장애점입니다.</li>\n<li>레디스가 사용하는 포트는 2개이며 하나는 클라이언트 하나는 노드 간의 통신을 위한 버스로 사용됩니다.</li>\n</ul>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jyejye9201.medium.com/%EB%A0%88%EB%94%94%EC%8A%A4-redis-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-2b7af75fa818\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis란 무엇인가</a></li>\n<li><a href=\"https://docs.redis.com/latest/rs/concepts/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Concept</a></li>\n<li><a href=\"http://redisgate.kr/redis/configuration/redis_overview.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Architecture Overview</a></li>\n<li><a href=\"https://cla9.tistory.com/101\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis 구조</a></li>\n<li><a href=\"https://engkimbs.tistory.com/869\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">레디스 소개 및 아키텍처, 주의할 점</a></li>\n<li><a href=\"https://coding-start.tistory.com/128\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis - Cluster &#x26; Sentinel</a></li>\n<li><a href=\"https://redis.io/commands\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Command</a></li>\n<li><a href=\"https://redis.com/redis-enterprise/technology/redis-enterprise-cluster-architecture/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Enterprise Cluster Architecture</a></li>\n</ul>\n"}},{"node":{"title":"[DB] INDEX SEEK 정리","path":"/00-db-index-seek/","date":"14. July 2021","timeToRead":2,"description":"INDEX SEEK와 SCAN에 대해 정리합니다.","content":"<h1 id=\"db-mssql-index-seek\"><a href=\"#db-mssql-index-seek\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>[DB] MSSQL Index Seek</h1>\n<h2 id=\"index-seek란\"><a href=\"#index-seek%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Index Seek란?</h2>\n<p>일종의 Non-Clustered Index를 인덱스 트리를 타고 원하는 데이터로 바로 접근한 경우입니다.</p>\n<p>일반적으로 Non-Clustered Index는 Dense Index이고, Secondary Index입니다.</p>\n<ul>\n<li>*Index : 검색의 효율성을 높이기 위한 물리적인 데이터 구조</li>\n<li>*Sparse Index : 해당 레코드 존재 페이지를 가리키는 포인터를 저장합니다.</li>\n<li>*Dense Index(Secondary Index) : 해당 레코드를 가리키는 포인터를 저장합니다.</li>\n</ul>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> TableA\n<span class=\"token keyword\">where</span> colA <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'B105'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'C101'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- colA에 Non-Clustered Index가 생성됩니다.</span>\n<span class=\"token comment\">-- Clustered Index는 생성되지 않습니다.</span>\n<span class=\"token comment\">-- 이 쿼리는 실제 실행에서 Index Seek를 한다고 가정합니다.</span></code></pre>\n<p>이 쿼리문을 처리하는 과정은 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/125635036-f05263f7-f7f2-4dcc-9d11-a20b10247b6d.png\" alt=\"image\"></p>\n<p>SQL Server는 'B105'를 찾기위해서 동작하고 이 동작을 Index Seek라고 부릅니다.</p>\n<ul>\n<li>Root Page를 통해서 Index Page를 찾습니다.</li>\n<li>Index Path에서 Data Page를 찾아, 해당 Row를 읽습니다.</li>\n</ul>\n<p>다만 이 경우 Unique Index인지, Non-Unique Index인지에 따라 페이지를 읽은 수가 다릅니다.</p>\n<ul>\n<li>Unique Index 인 경우, 3Page를 읽습니다.(Index Page = 2, Data Page = 1)</li>\n<li>Non-Unique Index 인 경우, 한 페이지를 더 읽어야합니다. ('B105' 다음이 있는지 확인해야 마지막인 것을 확인할 수 있으므로)</li>\n</ul>\n<p>다만, <strong>핵심 중 하나는 적은 Row 수를 가지는 경우</strong>에서는 Index를 생성하지 않는 것이 좋습니다. 그 이유는 CPU 비용이 Index Seek 보다 Full Scan이 더 적기 때문입니다. (Index Seek 보다는 Data Page를 처음부터 끝까지 읽어서 필요한 부분을 읽는 것이 더 좋습니다.)</p>\n<h2 id=\"index-scan과-index-seek-의-차이\"><a href=\"#index-scan%EA%B3%BC-index-seek-%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Index Scan과 Index Seek 의 차이</h2>\n<ul>\n<li>Index Scan : 해당 테이블의 컬럼을 모두 찾습니다.</li>\n<li>Index Seek : 해당 인덱스를 바로 찾아갑니다.</li>\n</ul>\n<p>이와 같이 Seek가 일반적으로 Scan보다 비용(cost)이 적게 드는 것을 확인할 수 있습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"http://databaser.net/moniwiki/wiki.php/Index\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Index</a></li>\n<li><a href=\"http://databaser.net/moniwiki/wiki.php/IndexSeek\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">IndexSeek</a></li>\n<li><a href=\"https://psawesome.tistory.com/14\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Index Seek, Index Scan</a></li>\n<li><a href=\"https://blog.naver.com/PostView.nhn?blogId=waws01&#x26;logNo=60181424769\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">인덱스 SCAN과 SEEK의 차이</a></li>\n</ul>\n"}},{"node":{"title":"[DB] ORM에 대해 정리하기","path":"/00-db-orm/","date":"3. April 2021","timeToRead":5,"description":"ORM에 대해 정리합니다. ","content":"<h1 id=\"orm에-대해\"><a href=\"#orm%EC%97%90-%EB%8C%80%ED%95%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ORM에 대해</h1>\n<p>지난 게시글에서는 jpa에 대해서 정리하면서 ORM에 대한 개념을 언급했는데 오늘은 ORM에 대한 상세 내용을 정리합니다.</p>\n<ul>\n<li><a href=\"https://azderica.github.io/00-java-jpa/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JPA 정리글</a></li>\n</ul>\n<br/>\n<h2 id=\"영속성persistence\"><a href=\"#%EC%98%81%EC%86%8D%EC%84%B1persistence\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>영속성(Persistence)</h2>\n<p>먼저 ORM에 들어가기전에 영속성에 대한 개념을 정리합니다.</p>\n<p>영속성은 다음을 의미합니다.</p>\n<ul>\n<li>데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터 특성</li>\n<li>영속성이 없는 데이터는 단지 메모리에서만 존재하므로, 프로그램 종료 시 모두 잃어버립니다.</li>\n<li>\n<p><strong>Object Persistence(영구적인 객체)</strong></p>\n<ul>\n<li>메모리 상의 데이터를 File이나 DB를 활용해서 영속성을 부여합니다.</li>\n</ul>\n</li>\n</ul>\n<p>자바에서 데이터를 저장하는 방법은 다음과 같습니다.</p>\n<ul>\n<li>JDBC</li>\n<li>Spring JDBC</li>\n<li><strong>Persistence Framework</strong>(Hibernate, Mybatis...)</li>\n</ul>\n<blockquote>\n<p>Persistence Framework</p>\n</blockquote>\n<p>Persistence Layer</p>\n<ul>\n<li>데이터베이스에서 데이터를 읽어(Read) 객체화하거나, 데이터 베이스에 데이터를 저장(Create), 수정(Update), 삭제(Delete)하는 역할</li>\n</ul>\n<p><strong>Persistence Framework</strong></p>\n<ul>\n<li>JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와연동되는 시스템을 빠르게 개발할 수 있습니다.</li>\n<li>\n<p>일반적으로 SQL Mapper와 ORM으로 나눠집니다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">SQL Mapper</code></p>\n<ul>\n<li>SQL &#x3C;-> SQL Mapper &#x3C;-> Object 필드</li>\n<li>SQL 문장으로 직접 데이터베이스 데이터를 다룬다.</li>\n<li>SQL을 직접 작성합니다.</li>\n<li><strong>Mybatis, JdbcTemplates(Spring)</strong></li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">ORM</code></p>\n<ul>\n<li>Database data &#x3C;-> ORM &#x3C;-> Object 필드</li>\n<li>객체를 통해서 간접적으로 데이터베이스 데이터를 다룹니다.</li>\n<li>객체와 관계형 데이터베이스의 데이터를 자동으로 맵핑시켜줍니다.</li>\n<li><strong>JPA, Hibernate</strong> 등이 있습니다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"orm의-정의\"><a href=\"#orm%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ORM의 정의</h2>\n<p>ORM(Object-relational mapping)은 <strong>객체(클래스)와 관계(RDB, Relational Database)와의 설정</strong>을 의미합니다.</p>\n<p>객체 지향 프로그래밍은 클래스를 사용하고 관계형 데이터 베이스는 테이블을 사용합니다. 여기서 객체 모델과 관계형 모델간에 불일치가 발생하게 되는데, ORM은 이러한 <strong>불일치를 객체간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결</strong>합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/111995242-0ca00d80-8b5c-11eb-9662-7f60f1dfc0c7.png\" alt=\"ORM\"></p>\n<p>해당 그림처럼, Object와 DB 데이터 사이에서 매핑을 합니다.</p>\n<br/>\n<h2 id=\"orm의-장단점\"><a href=\"#orm%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ORM의 장단점</h2>\n<h3 id=\"orm-장점\"><a href=\"#orm-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ORM 장점</h3>\n<ul>\n<li>\n<p>객체 지향적 코드를 사용함으로서 직관적이보 비지니스 로직에 집중할 수 있도록 도와줍니다.</p>\n<ul>\n<li>CRUD를 위한 SQL문을 작성할 필요는 없습니다. (쿼리 작성은 필요)</li>\n<li>각 객체(Model) 별로 코드를 작성하므로 가독성이 높아집니다.</li>\n</ul>\n</li>\n<li>\n<p>재사용 및 유지 보수의 편리성이 증가합니다.</p>\n<ul>\n<li>ORM은 독립적으로 작성이 되어 있고 해당 객체들은 재사용이 가능합니다.</li>\n</ul>\n</li>\n<li>\n<p>DBMS에 대한 종속성이 줄어듭니다.</p>\n<ul>\n<li>대부분의 ORM은 DB에 비종속적입니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"orm-단점\"><a href=\"#orm-%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ORM 단점</h3>\n<ul>\n<li>\n<p>완벽한 ORM만으로는 구현하기가 어렵습니다.</p>\n<ul>\n<li>사용하기는 편하지만 설계는 신중해야합니다.</li>\n<li>프로젝트의 복잡성이 높아질 경우, 난이도가 높아집니다.</li>\n<li>잘못 구현하는 경우 속도 저하 및 심한 경우, 일관성이 무너질 수도 있습니다.</li>\n</ul>\n</li>\n<li>프로시저가 많은 시스템에서는 ORM의 객체 지향적인 장점을 활용하기가 어렵습니다.</li>\n</ul>\n<br/>\n<h2 id=\"orm의-종류\"><a href=\"#orm%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ORM의 종류</h2>\n<p>앞서 이야기한 것외에도 다양한 ORM이 존재합니다.</p>\n<ul>\n<li>Flask : SQLAlchemy</li>\n<li>Django : 내장 ORM</li>\n<li><strong>Node.js : Sequalize</strong></li>\n<li><strong>Java : Hybernate, JPA</strong></li>\n<li>GraphQL : Prisma</li>\n</ul>\n<p>해당 ORM에 대해서는 직접 사용해보면서 차이를 느껴보고 개념을 이해하는 것을 추천합니다. (개인적으로 사용해본 것은 Sequalize와 Hybernate, JPA이지만, 실무에서는 따로 환경이 안나와서 써보지 못했습니다...)</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>핵심적인 내용은 정리르 했으나, 개인적으로 알고 싶은 내용인 queryDsl과 Jooq에 대해서는 따로 정리를 하지 못했습니다. 해당 글은 좀 더 개념을 잡아 정리하겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://velog.io/@alskt0419/ORM%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C...-iek4f0o3fg\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ORM이란?</a></li>\n<li><a href=\"https://changrea.io/jpa/orm/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ORM</a></li>\n<li><a href=\"https://velog.io/@alskt0419/ORM%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C...-iek4f0o3fg\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ORM에 대해서</a></li>\n<li><a href=\"https://gmlwjd9405.github.io/2019/02/01/orm.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DB, ORM이란</a></li>\n</ul>\n"}},{"node":{"title":"[Database] Couchbase XDCR","path":"/00-db-couchbase-xdcr/","date":"2. April 2021","timeToRead":4,"description":"Couchbase XDCR에 대해 정리합니다.","content":"<h1 id=\"couchbase-xdcr\"><a href=\"#couchbase-xdcr\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase XDCR</h1>\n<p>최근 진행해야하는 작업 중 하나가, 기존 Couchbase 서버가 있는 데이터 센터에서 서버 부하 해결 및 안정성을 위해 다른 데이터 센터에 데이터를 복제를 해야할 필요성이 존재합니다.</p>\n<p>회사에서 작업하는 주 목적은 데이터 서버에 있는 Couchbase 서버가 모두 죽었을 때, 정상적으로 작동하도록 구성하는 것이 목표입니다.</p>\n<p>이를 위해서 Cross Data Center Replication (약어, XDCR)에 대해 정리합니다.</p>\n<br/>\n<h2 id=\"xdcr이란\"><a href=\"#xdcr%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>XDCR이란.</h2>\n<p>XDCR(Cross Data Center Replication)은 클러스터 간의 데이터를 복제하며, 데이터 센터 장애에 대한 보호 기능과 고성능 데이터 액세스 기능을 제공합니다.</p>\n<p>XDCR은 source 클러스터의 특정 버킷에서 대상 클러스터의 특정 버킷으로 데이터를 복제합니다. XDCR agent를 통해 Database Change Protocol을 사용하여 버킷에서 다른 타켓 버킷으로 데이터를 넘길 수 있습니다.</p>\n<br/>\n<h2 id=\"xdcr과-클러스터-내부-복제와의-차이\"><a href=\"#xdcr%EA%B3%BC-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EB%82%B4%EB%B6%80-%EB%B3%B5%EC%A0%9C%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>XDCR과 클러스터 내부 복제와의 차이</h2>\n<ul>\n<li>클러스터 내부 복제의 경우, 클로스터 노드 전체에 데이터를 복제하나 XDCR의 경우 다른 데이터센터에 있는 여러 클러스터에 데이터를 복제합니다.</li>\n<li>클러스터 내부 복제의 경우, 단일 버킷에 대해 수행되지만 XDCR은 복제를 위해 두 개의 버킷이 필요합니다. (하나는 복제 데이터 제공 소스 클러스터 버킷, 다른 하나는 수신 받을 대상의 클러스터)</li>\n<li>클러스터 내 복제는 버킷 생성에서 구성되지만, XDCR은 소스 버킷과 대상 버킷을 모두 생성 후에 구성됩니다.</li>\n</ul>\n<blockquote>\n<p>클러스터(cluster)</p>\n</blockquote>\n<p>여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하는 컴퓨터들의 집합, 해당 위에서는 서버들의 집합</p>\n<blockquote>\n<p>버킷(bucket)</p>\n</blockquote>\n<p>일반적으로 데이터가 영역으로 분할되는 document 유형입니다.</p>\n<br/>\n<h2 id=\"xdcr-절차\"><a href=\"#xdcr-%EC%A0%88%EC%B0%A8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>XDCR 절차</h2>\n<p>사전 작업</p>\n<ul>\n<li>\n<p>XDCR의 대상이 될 원격 클러스터에 대한 References를 정의합니다.</p>\n<ul>\n<li><a href=\"https://docs.couchbase.com/server/current/manage/manage-xdcr/create-xdcr-reference.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Document</a></li>\n</ul>\n</li>\n<li>\n<p>소스 버킷에서 지장된 대상 버킷으로 변경내용을 전송하는 복제를 정의하고 시작합니다.</p>\n<ul>\n<li><a href=\"https://docs.couchbase.com/server/current/learn/clusters-and-availability/xdcr-overview.html#manage:manage-xdcr/create-xdcr-replication\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Document</a></li>\n</ul>\n</li>\n<li>복제를 모니터링합니다.</li>\n</ul>\n<p>다음의 옵션을 사용할 수 있습니다.</p>\n<ul>\n<li>Couchbase Web Console</li>\n<li>CLI</li>\n<li>REST API(Web Console, CLI)</li>\n</ul>\n<br/>\n<h2 id=\"xdcr-direction-topology\"><a href=\"#xdcr-direction-topology\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>XDCR Direction, Topology</h2>\n<p>크게 전략은 단방향(Unidirectionally)와 양방향(Bidirectionally)로 구성됩니다.</p>\n<p>향후 진행할 작업은 양방향 XDCR을 구성할 방향이다.</p>\n<h3 id=\"unidirectionally\"><a href=\"#unidirectionally\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Unidirectionally</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/113409137-a2089080-93eb-11eb-9fdc-15f325939633.png\" alt=\"Unidirectionally\"></p>\n<p>지정된 소스 버킷에 포함된 데이터가 지정된 대상 버킷에 복제되며, 일반적으로 <strong>백업 용도로 사용</strong>됩니다.</p>\n<h3 id=\"bidirectionally\"><a href=\"#bidirectionally\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Bidirectionally</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/113409142-a5038100-93eb-11eb-8e01-c23ce981dfd5.png\" alt=\"Bidirectionally\"></p>\n<p>지정된 소스 버킷에 포함된 데이터는 대상 버킷에 복제되고, 반대의 방향의 경우에도 적용됩니다. 해당 두 버킷을 모두 데이터 서비스용으로 사용할 수 있으며, <strong>사용자에 좀 더 빠른 데이터 액세스를 제공</strong>할 수 있습니다.</p>\n<p>이러한 양방향 XDCR은 두 데이터 센터 이상으로도 작업할 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/113409371-1d6a4200-93ec-11eb-8ff6-0a2205b62be6.png\" alt=\"image\"></p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간략하게, XDCR에 대해 작성했습니다. 향후, 해당 작업 완료 후 추가적인 게시글을 작성할 예정입니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://docs.couchbase.com/server/current/learn/clusters-and-availability/xdcr-overview.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Couchbase XDCR Doc</a></li>\n</ul>\n"}},{"node":{"title":"[DB] NoSQL 데이터베이스 정리","path":"/00-db-nosql/","date":"1. April 2021","timeToRead":8,"description":"Nosql에 대해 소개하고 특징에 대해 정리합니다.","content":"<h1 id=\"nosql\"><a href=\"#nosql\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NoSQL</h1>\n<p>해당 게시글은 NoSQL에 대한 내용을 간략하게 정리하고, 여러가지 NoSQL Database를 특징별로 정리합니다.</p>\n<br/>\n<h2 id=\"rdb와의-차이\"><a href=\"#rdb%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>RDB와의 차이</h2>\n<p>대부분 RDB와 NoSQL의 차이를 인지하고 있는데 이를 표로 간략하게 정리하면 다음과 같습니다.</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>RDB</th>\n<th>NoSQL</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>데이터모델</td>\n<td>고정 행과 열이 있는 테이블</td>\n<td>document-Json, key value, ...</td>\n</tr>\n<tr>\n<td>예시</td>\n<td>Oracle, MySQL, MSSQL, PostgreSQL</td>\n<td>MongoDB, Redis, Hbase, Neo4j</td>\n</tr>\n<tr>\n<td>목적</td>\n<td>범용</td>\n<td>범용, 대량의 데이터 추출, 관계 분석, 탐색 등</td>\n</tr>\n<tr>\n<td>스키마</td>\n<td>엄격</td>\n<td>유연</td>\n</tr>\n<tr>\n<td>확장성</td>\n<td>수직</td>\n<td>수형성</td>\n</tr>\n<tr>\n<td>ACID 트랜잭션</td>\n<td>지원</td>\n<td>대부분 지원하지 않음</td>\n</tr>\n<tr>\n<td>ORM</td>\n<td>ORM 필요</td>\n<td>대부분 ORM이 필요없음</td>\n</tr>\n</tbody>\n</table>\n<br/>\n<h2 id=\"nosql의-장단점\"><a href=\"#nosql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NoSQL의 장단점</h2>\n<h3 id=\"nosql의-장점\"><a href=\"#nosql%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NoSQL의 장점</h3>\n<p>NoSQL은 다음의 장점을 가집니다.</p>\n<ul>\n<li>\n<p>유연한 데이터 모델</p>\n<ul>\n<li>유연한 스키마를 가지므로, 요구 사항이 변경되었을 때 데이터베이스를 쉽게 변경할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>수평적 확장</p>\n<ul>\n<li>일반적으로 RDB의 경우에는 용량 초과시 <strong>수직적 확장</strong>(크고 비싼 서버)가 필요하지만, NoSQL의 경우는 수평적 확장이 가능합니다. (제한은 존재함)</li>\n</ul>\n</li>\n<li>\n<p>빠른 쿼리</p>\n<ul>\n<li>일반적으로 RDB의 경우, 여러 테이블을 Join해서 쿼리를 사용하지만, NoSQL의 경우는 쿼리에 최적화되어 저장합니다.</li>\n</ul>\n</li>\n<li>\n<p>개발자에 친화적</p>\n<ul>\n<li>NoSQL은 데이터 구조를 일반적인 프로그래밍 언어의 데이터 구조에 매핑합니다.</li>\n<li>적은 코드를 작성하면서, 개발 시간을 단축하고 버그를 줄일 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"nosql의-단점\"><a href=\"#nosql%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NoSQL의 단점</h3>\n<p>NoSQL에서 이야기되는 가장 큰 단점으로는 ACID 트랜잭션을 지원하지 않는 것입니다. 물론 적절한 스키마 디자인을 제공하면 단일 레코드의 원자화는 가능합니다.</p>\n<blockquote>\n<p>ACID</p>\n</blockquote>\n<ul>\n<li>A : atomicity, 원자성</li>\n<li>C : consistency, 일관성</li>\n<li>I : isolation, 고립성</li>\n<li>D : durability, 지속성</li>\n</ul>\n<br/>\n<h2 id=\"nosql-데이터베이스-별-특징\"><a href=\"#nosql-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%B3%84-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NoSQL 데이터베이스 별 특징</h2>\n<p>NoSQL 데이터베이스의 특성을 크게 다음과 같이 4가지로 나눌 수 있습니다.</p>\n<ul>\n<li>Key-Value Database</li>\n<li>Document Database</li>\n<li>Column Family Database</li>\n<li>Graph Database</li>\n</ul>\n<h3 id=\"key-value-database\"><a href=\"#key-value-database\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Key-Value Database</h3>\n<p>Key와 Value로 이루어졌으며, <strong>저장과 조회</strong>이란 원칙에 가장 충실합니다.</p>\n<p>Key-Value Database는 다음의 특징을 가집니다.</p>\n<ul>\n<li>Key 값은 unique한 고유값으로 유지되어야합니다.</li>\n<li>테이블간 join을 고려하지 않으므로 RDB의 외부키 등이 필요없습니다.</li>\n<li>Value에 모든 데이터 타입을 허용하며 이에 따라 검증 로직을 잘 구성하는 것이 중요합니다.</li>\n</ul>\n<p>Key-Value Database는 다음과 같은 종류들이 있습니다.</p>\n<ul>\n<li><strong>Redis</strong></li>\n<li><strong>AWS DynamoDB</strong></li>\n<li>Oracle Berkely</li>\n<li>Riak</li>\n</ul>\n<p>Key-Value Database는 일반적으로 아래의 경우에서 많이 사용합니다.</p>\n<ul>\n<li><strong>성능 향상을 위해 데이터베이스 데이터 캐싱</strong></li>\n<li>웰 어플리케이션에서 일시적인 속성 추적</li>\n<li>\n<p>모바일 애플리케이션용 사용자 데이터 정보와 구성 정보 저장</p>\n<ul>\n<li>다만 개인정보 등은 NoSQL에 저장하는 것은 지양해야함.</li>\n</ul>\n</li>\n<li>\n<p>이미지나 오디오 파일 같은 대용량 객체 저장</p>\n<ul>\n<li>일반적으로 NAS를 사용하기는 함.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"document-database\"><a href=\"#document-database\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Document Database</h3>\n<p>Key-Value Database와 마찬가지로 데이터 저장시에는 Key-Value Type을 사용하지만, 가장 큰 차이는 <strong>Document 타입으로 저장</strong>됩니다. (Ex. JSON, XML)</p>\n<p>Document Database는 다음의 특징을 가집니다.</p>\n<ul>\n<li>값을 문서(semi-structured entity)로 저장합니다. (일반적으로 JSON, XML)</li>\n<li>값을 저장하기 전에 schema를 별도로 정의하지 않으며, document가 schema가 됩니다.</li>\n<li>\n<p>각 문서별로 다른 필드를 가질 수 있기 때문에 개발자는 입력시 <strong>컬럼과 필드에 대한 관리</strong>를 제대로 해야합니다.</p>\n<ul>\n<li>필도 속성에 대한 관리가 필요합니다.</li>\n</ul>\n</li>\n</ul>\n<p>Document Database는 다음과 같은 종류가 있습니다.</p>\n<ul>\n<li><strong>MongoDB</strong></li>\n<li>CouchDB</li>\n<li>Couchbase</li>\n</ul>\n<p>Document Database는 일반적으로 아래의 경우에서 많이 사용합니다.</p>\n<ul>\n<li>대용량 데이터를 읽고 쓰는 웹사이트 백엔드 지원</li>\n<li>제품처럼 다양한 속성이 있는 데이터 관리</li>\n<li>다양한 유형의 메타데이터 추적</li>\n<li>Json 데이터 구조를 사용하는 어플리케이션</li>\n<li>비정규화된 중첩 구조의 데이터를 사용하는 애플리케이션</li>\n</ul>\n<blockquote>\n<p>CouchDB와 Couchbase의 차이.</p>\n</blockquote>\n<ul>\n<li>Couchbase는 JSON용 SQL과 같은 쿼리 언어 N1QL이 있으나, CouchDB는 없습니다.</li>\n<li>Couchbase는 기업용이 있으나, CouchDB는 오픈소스만 있습니다.</li>\n<li>Couchbase는 pessimistic lock이 있으나, CouchDB는 MVCC 개념을 사용하므로 없습니다.</li>\n<li>Couchbase의 topology는 분산되어 있으나, CouchDB는 master-master 복제 개념입니다.</li>\n</ul>\n<h3 id=\"column-family-database\"><a href=\"#column-family-database\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Column Family Database</h3>\n<p>Column Family Database는 대용량 데이터, 읽기와 쓰기 성능, 고가용성을 위해 설계되었습니다. (Ex. 구글의 Big Table, 페이스북의 Cassandra)</p>\n<p>Column Family Database는 다음의 특징을 가집니다.</p>\n<ul>\n<li>\n<p>RDB와 같이 Column과 Row를 사용해서 스키마를 정의합니다.</p>\n<ul>\n<li>컬럼 수가 많으면 관련된 컬럼들을 컬렉션으로 묶을 수 있습니다. (이를 <strong>Column Family</strong>라고 합니다.)</li>\n</ul>\n</li>\n<li>Document Database와 같이 미리 정의된 스키마를 사용하지 않으므로 원하는 시점에 컬럼을 추가가능합니다.</li>\n<li>테이블간 조인을 지원하지 않습니다.</li>\n</ul>\n<p>즉, 다음과 같은 모습으로 구성되어 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/113298137-76779e80-9336-11eb-9ed1-cb287417ad04.png\" alt=\"Hbase Column Families\"></p>\n<p>Column Family Database는 다음과 같은 종류가 있습니다.</p>\n<ul>\n<li><strong>Hbase</strong></li>\n<li><strong>Cassandra</strong></li>\n<li>GCP(Google Cloud Platform) BigTable</li>\n<li>MS Azure Cosmos DB</li>\n</ul>\n<p>Column Family Database는 일반적으로 아래의 경우에서 많이 사용합니다.</p>\n<ul>\n<li>데이터베이스에 쓰기 작업이 많은 애플리케이션</li>\n<li>지리적으로 여러 데이터 센터에 분산되어 있는 애플리케이션</li>\n<li>복제본 데이터가 단기적으로 불일치해도 큰 문제가 없는 애플리케이션</li>\n<li>동적 필드를 처리하는 애플리케이션</li>\n<li>수백만 테라바이트 정도의 대용량 데이터를 처리할 수 있는 애플리케이션</li>\n</ul>\n<p>다음은 Column Family Database의 성능 표입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/113298465-d40beb00-9336-11eb-8c64-8752cb98d1eb.png\" alt=\"Column Family Database Trend Chart\"></p>\n<p>일반적으로 Hbase와 Cassandra가 많이 쓰입니다. 다만, Hbase는 성능이 높으나 시스켐 복잡도와 Learning Curve의 문제로 인해 Cassandra가 더 보편적으로 선호됩니다.</p>\n<h3 id=\"graph-database\"><a href=\"#graph-database\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Graph Database</h3>\n<p>Graph Database는 Graph 이론을 활용한 것이며, Node(노드)들과 Relationship(관계)로 구성된 개념입니다. 노드는 Key-Value 값을 가지고 있고 노드는 하나 이상의 레이블을 구성할 수 있습니다.</p>\n<p>Graph Database는 다음의 특징을 가집니다.</p>\n<ul>\n<li>간단하고 직관적인 데이터 모델을 가집니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/113299571-fb16ec80-9337-11eb-9b17-b42ce16c51d0.png\" alt=\"image\"></p>\n<p>Graph Database는 다음과 같은 종류가 있습니다.</p>\n<ul>\n<li><strong>Neo4j</strong></li>\n<li>Titan</li>\n<li>AllegroGraph</li>\n</ul>\n<p>Graph Database는 일반적으로 아래의 경우에서 많이 사용합니다.</p>\n<ul>\n<li>지식 그래프나 소셜 그래프</li>\n<li>자격 증명 그래프</li>\n<li>사기 탐지 및 추천 엔진</li>\n<li>생명 과학 분야</li>\n</ul>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jaemunbro.medium.com/nosql-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B9%EC%84%B1-%EB%B9%84%EA%B5%90-c9abe1b2838c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL 데이터베이스별 특징</a></li>\n<li><a href=\"https://velog.io/@hanblueblue/%EB%B2%88%EC%97%AD-NoSQL-vs-Relational-Databases\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL vs Relational Database</a></li>\n<li><a href=\"https://velog.io/@hanblueblue/%EB%B2%88%EC%97%AD-NoSQL-vs-Relational-Databases\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DB, RDBMS VS NoSQL</a></li>\n<li><a href=\"https://blogs.perficient.com/2017/07/18/to-know-more-about-nosql-counchdb-vs-couchbase/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Couchbase VS CouchDB</a></li>\n<li><a href=\"https://couplewith.tistory.com/entry/Graph-DB-%EC%99%80-RDBMS-%ED%8A%B8%EB%9E%9C%EB%93%9C-3%EB%B6%80-%EA%B7%B8%EB%9E%98%ED%94%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%A2%85%EB%A5%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GraphDB</a></li>\n</ul>\n"}},{"node":{"title":"[Database] CAP 정리","path":"/00-db-cap/","date":"9. February 2021","timeToRead":4,"description":"CAP 이론에 대해 정리합니다.","content":"<h1 id=\"cap-정리\"><a href=\"#cap-%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CAP 정리</h1>\n<p>DB에 대해 공부하다 보면, CAP 이론에 대해 듣게 됩니다. 비록 이야기가 조금 있기는 하지만 그래도 CAP에 대해 개념을 정리합니다.</p>\n<br/>\n<h2 id=\"cap-란\"><a href=\"#cap-%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CAP 란.</h2>\n<p>CAP이론(Brewer's theorem)은 Network로 연결된 분산된 데이터베이스 시스템은 일관성(Consistency), 가용성(Availability), 분할 내구성(Partition Tolerance)의 3가지 특성 중 2가지 특성만을 충족할 수 있고 3가지를 모두 충족할 수는 없다는 이론입니다.</p>\n<h3 id=\"c일관성-consistency\"><a href=\"#c%EC%9D%BC%EA%B4%80%EC%84%B1-consistency\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>C(<strong>일관성</strong>, Consistency)</h3>\n<ul>\n<li>일관성을 가진다는 것은 모든 데이터를 요청할 때 응답으로 가장 최신의 변경된 데이터를 리턴 또는 실패를 리턴합니다.</li>\n<li>모든 읽기에 대해서 DB노드가 항상 동일한 데이터를 가지고 있어야한다는 의미입니다.</li>\n</ul>\n<h3 id=\"a가용성-availability\"><a href=\"#a%EA%B0%80%EC%9A%A9%EC%84%B1-availability\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>A(<strong>가용성</strong>, Availability)</h3>\n<ul>\n<li>가용성은 모든 요청에 대해서 정상적인 응답을 합니다.</li>\n<li>클러스터의 노드 일부에서 장애가 발생해도 READ나 WRITE 등의 동작은 항상 성공적으로 리턴되어야합니다.</li>\n</ul>\n<h3 id=\"p분할내성-partition-tolerance\"><a href=\"#p%EB%B6%84%ED%95%A0%EB%82%B4%EC%84%B1-partition-tolerance\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>P(<strong>분할내성</strong>, Partition tolerance)</h3>\n<ul>\n<li>메시지 전달이 실패하는 시스템 일부가 망가져도 시스템이 계속 동작할 수 있습니다.</li>\n<li>분할 내구성이란 Node간의 통신 장애가 발생하더라도 동작해야합니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107368608-19285380-6b24-11eb-95b2-846fea107c43.png\" alt=\"image\"></p>\n<p>다만, 현재의 DB와는 문제가 있다는 이야기는 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107371626-d1a3c680-6b27-11eb-9d32-1edebb653aed.png\" alt=\"image\"></p>\n<br/>\n<h2 id=\"일반적으로\"><a href=\"#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9C%BC%EB%A1%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>일반적으로</h2>\n<h3 id=\"cpconsistency--partition-tolerance\"><a href=\"#cpconsistency--partition-tolerance\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CP(Consistency &#x26; Partition Tolerance)</h3>\n<ul>\n<li>어떤 상황에서도 안정적으로 시스템은 운영되지만 Consistency가 보장되지 않는다면 Error를 반환합니다.</li>\n<li><strong>매 순간 Read / Write 에 따른 정합성이 일치할 필요가 있는 경우 적합한 형태입니다.</strong></li>\n</ul>\n<h3 id=\"apavailability--partition-tolerance\"><a href=\"#apavailability--partition-tolerance\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>AP(Availability &#x26; Partition Tolerance)</h3>\n<ul>\n<li>어떤 상황에서도 안정적으로 시스템은 운영됩니다.</li>\n<li>데이터와 상관없이 안정적인 응답을 받을 수 있습니다.</li>\n<li>다만 데이터의 정합성에 대한 보장은 불가능합니다.</li>\n<li><strong>결과적으로 일관성이 보장되는 Eventual Consistency를 보장할 수 있는 시스템에 알맞는 형태입니다.</strong></li>\n</ul>\n<h3 id=\"대부분은\"><a href=\"#%EB%8C%80%EB%B6%80%EB%B6%84%EC%9D%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>대부분은...</h3>\n<ul>\n<li>사실 대부분 CP, AP 시스템은 없고 대부분 CP와 AP의 어느 중간 쯤에 존재합니다.</li>\n<li>예제에 봤듯이 configuration에 따라 변하기도 하고, 이론 자체에서 한계점도 존재합니다.</li>\n<li>가장 큰 문제는 P에 대한 명확한 정의가 부족합니다.</li>\n<li>기존의 문제를 해결하기 위해 PACELC 이론이 등장하였습니다.</li>\n</ul>\n<br/>\n<h2 id=\"pacelc-이론\"><a href=\"#pacelc-%EC%9D%B4%EB%A1%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PACELC 이론</h2>\n<p>다음과 같은 요소로 표현됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107372209-7faf7080-6b28-11eb-897d-461cc4b64a86.png\" alt=\"pacelc\"></p>\n<h3 id=\"pacelc-구성\"><a href=\"#pacelc-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PACELC 구성</h3>\n<p>PACELC는 크게 4가지로 구성됩니다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>구성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Partition</td>\n<td>Availability</td>\n<td>가용성</td>\n</tr>\n<tr>\n<td></td>\n<td>Consistency</td>\n<td>일관성</td>\n</tr>\n<tr>\n<td>Else</td>\n<td>Latency</td>\n<td>시간 지연</td>\n</tr>\n<tr>\n<td></td>\n<td>Consistency</td>\n<td>일관성</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"pacelc-대입\"><a href=\"#pacelc-%EB%8C%80%EC%9E%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PACELC 대입</h3>\n<p>이를 기존의 DB에 대입시키면 다음과 같이 볼 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107372699-0bc19800-6b29-11eb-96f0-957e59da40b8.png\" alt=\"pacelc-db\"></p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>CAP 이론과 PACELC 이론에 대한 개념을 잡았습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jins-dev.tistory.com/entry/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%98%EA%B2%BD-Distributed-System-%EC%97%90%EC%84%9C-BASE-%EC%9B%90%EC%B9%99%EA%B3%BC-CAP-%EC%A0%95%EB%A6%AC\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://jins-dev.tistory.com/entry/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%98%EA%B2%BD-Distributed-System-%EC%97%90%EC%84%9C-BASE-%EC%9B%90%EC%B9%99%EA%B3%BC-CAP-%EC%A0%95%EB%A6%AC</a></li>\n<li><a href=\"https://sabarada.tistory.com/91\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://sabarada.tistory.com/91</a></li>\n<li><a href=\"https://m.blog.naver.com/PostView.nhn?blogId=windfalcon1&#x26;logNo=220402574806&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.blog.naver.com/PostView.nhn?blogId=windfalcon1&#x26;logNo=220402574806&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F</a></li>\n</ul>\n"}}]}}},"context":{}}