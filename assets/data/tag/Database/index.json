{"hash":"6eab5397a2d6c11ddf021b778b38f6e8e79b2231","data":{"tag":{"title":"Database","belongsTo":{"edges":[{"node":{"title":"[DB] DB의 INDEX 개념정리","path":"/00-db-index/","date":"27. October 2021","timeToRead":7,"description":"DB의 INDEX에 대해 정리합니다.","content":"<h1 id=\"db-index-개념-정리\"><a href=\"#db-index-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>[DB] Index 개념 정리</h1>\n<h2 id=\"개념\"><a href=\"#%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>개념</h2>\n<ul>\n<li>일종의 책 뒤의 찾아보기나 책 앞의 목차의 개념으로 이해하면 됩니다.</li>\n<li>주로 쿼리의 성능을 높이기 위해 사용됩니다.</li>\n</ul>\n<br/>\n<h2 id=\"장단점\"><a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>장단점</h2>\n<h3 id=\"장점\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>장점</h3>\n<ul>\n<li>검색 속도 향상</li>\n<li>시스템의 부하를 줄여, 시스템 전체 성능향상에 기여가 가능합니다.</li>\n</ul>\n<h3 id=\"단점\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단점</h3>\n<ul>\n<li>인덱스를 위한 추가 공간이 필요합니다.</li>\n<li>생성에 시간이 소요 될 수 있습니다.</li>\n<li>생성, 수정, 삭제에 대한 성능이 하락할 수 있습니다.</li>\n</ul>\n<br/>\n<h2 id=\"인덱스가-필요한-경우\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EA%B2%BD%EC%9A%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>인덱스가 필요한 경우</h2>\n<h3 id=\"주의사항\"><a href=\"#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>주의사항</h3>\n<ul>\n<li>무분별한 인덱스는 용량을 차지하고, 옵티마이저의 최적화를 낮추는 결과를 얻게 됩니다.</li>\n<li>특정 컬림들을 조건으로 걸 때, 정렬된 인덱스의 순서와 맞지않는다면 추가적인 비용이 발생합니다.</li>\n</ul>\n<h3 id=\"인덱스가-필요없는-경우\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EA%B0%80-%ED%95%84%EC%9A%94%EC%97%86%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>인덱스가 필요없는 경우</h3>\n<ul>\n<li>데이터가 적은 경우(수천건 미만) 인 경우에는 인덱스가 없는 것이 성능이 좋습니다.</li>\n<li>조회보다 삽입, 수정, 삭제 처리가 많은 테이블인 경우</li>\n<li>조회결과가 전체행의 15% 이상 읽어들일 것으로 예상되는 경우</li>\n</ul>\n<h3 id=\"인덱스가-필요한-경우-1\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EA%B2%BD%EC%9A%B0-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>인덱스가 필요한 경우</h3>\n<ul>\n<li>데이터가 많이 쌓일거라고 예상되거나 많은 경우, 조회속도가 너무 느린 경우</li>\n<li>조회결과가 전체 데이터 수의 3~5% 이상쯤되면 인덱스 스캔이 효율적이고 적은 비용으로 찾을 수 있습니다.</li>\n<li>Access 대상 범위가 전체 범위의 3~5% 이상 쯤 되면 인덱스 스캔보다 풀 스캔이 훨씬 유리합니다.</li>\n</ul>\n<br/>\n<h2 id=\"종류\"><a href=\"#%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>종류</h2>\n<h3 id=\"clusted-index클러스터형-인덱스\"><a href=\"#clusted-index%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%ED%98%95-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Clusted Index(클러스터형 인덱스)</h3>\n<ul>\n<li>테이블당 한 개만 생성이 가능합니다.</li>\n<li>행 데이터를 인덱스로 지정한 열에 맞춰서 자동 정렬합니다.</li>\n<li>primary 키 설정 시 자동으로 생성되며 컬럼은 데이터 변경시, 항상 정렬을 유지합니다.</li>\n</ul>\n<blockquote>\n<p>주의 사항</p>\n</blockquote>\n<ul>\n<li>클러스터 인젝스 사용시 모든 보조 인덱스카 primary 키를 포함합니다.</li>\n<li>primary 키의 크기가 커질수록 보조 인덱스의 크기도 커집니다.</li>\n</ul>\n<h3 id=\"non-clustered-index비클러스터형-인덱스\"><a href=\"#non-clustered-index%EB%B9%84%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%ED%98%95-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Non-Clustered Index(비클러스터형 인덱스)</h3>\n<ul>\n<li>테이블당 여러 개를 생성할 수 있습니다.</li>\n<li>맨뒤의 찾아보기가 있는 일반 책과 같습니다.</li>\n<li>테이블의 페이지를 정렬하지 않고 새로운 공간을 할당하므로, 클러스터 인덱스보다 많은 공간을 차지합니다.</li>\n<li>데이터 행과 분리된 구조를 가집니다.</li>\n</ul>\n<h4 id=\"단일-인덱스\"><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단일 인덱스</h4>\n<ul>\n<li>데이터가 많지 않으며 조건에 걸리는 컬럼이 적은 경우에 주로 사용합니다.</li>\n</ul>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> IDX_SINGLE <span class=\"token punctuation\">(</span>C1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"복합-인덱스\"><a href=\"#%EB%B3%B5%ED%95%A9-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>복합 인덱스</h4>\n<ul>\n<li>테이블 데이터를 기준으로 새로운 인덱스 공간을 생성 및 데이터를 정렬하므로 공간 사용량이 증가합니다.</li>\n</ul>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> IDX_MULTI <span class=\"token punctuation\">(</span>C1<span class=\"token punctuation\">,</span> C2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"커버드-인덱스\"><a href=\"#%EC%BB%A4%EB%B2%84%EB%93%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>커버드 인덱스</h4>\n<ul>\n<li>커버드 쿼리라고도 합니다.</li>\n<li>퀴리가 인덱스 접근으로 인해 테이블 접근이 필요하지 않는 경우 사용됩니다.</li>\n</ul>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> IDX_MULTI <span class=\"token punctuation\">(</span>C1<span class=\"token punctuation\">,</span> C2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> C1<span class=\"token punctuation\">,</span> C2 <span class=\"token keyword\">FROM</span> IDX_MULTI <span class=\"token keyword\">WHERE</span> C1 <span class=\"token operator\">=</span> <span class=\"token string\">'value1'</span> <span class=\"token operator\">and</span> C2 <span class=\"token operator\">=</span> <span class=\"token string\">'value2'</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"column-store-index-열-저장-인덱스\"><a href=\"#column-store-index-%EC%97%B4-%EC%A0%80%EC%9E%A5-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Column store Index (열 저장 인덱스)</h3>\n<ul>\n<li>열 저장소 인덱스는 방대한 데이터 웨어하우징 진리표를 삭제하고 질문하는 것과 관련하여 표준 유형의 인덱스가 있는 SQL 서버의 인덱스 유형 중 하나입니다.</li>\n<li>column-store 인덱스는 작은 인상 안에 정보를 넣을 수 있도록 하여 속도를 높이는데 도움이 됩니다.</li>\n<li>이를 사용하면 클라이언트가 기존의 열 정렬 용량과 달리 조회 실행이 몇 배 높은 IO를 얻을 수 있습니다.</li>\n</ul>\n<h3 id=\"filtered-index-필터링된-인덱스\"><a href=\"#filtered-index-%ED%95%84%ED%84%B0%EB%A7%81%EB%90%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Filtered Index (필터링된 인덱스)</h3>\n<ul>\n<li>필터링된 인덱스는 열에 값의 하위 집합에 대한 질문에 적용 가능한 숫자가 몇 개 없을 때 만들어지는 SQL Server의 인덱스 유형 중 하나입니다.</li>\n<li>테이블이 이기종 데이터 행으로 구성되어 있는 경우, 적어도 한 종류의 데이터에 대해 SQL에 분리된 목록이 만들어집니다.</li>\n</ul>\n<h3 id=\"hash-index-해시-인덱스\"><a href=\"#hash-index-%ED%95%B4%EC%8B%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Hash Index (해시 인덱스)</h3>\n<ul>\n<li>해시 인덱스는 포인터 또는 N 버킷의 배열과 각 슬롯 또는 버킷의 행을 포함하는 슬록에 있는 SQL 서버의 인덱스 유형 중 하나입니다.</li>\n<li>N은 여러 버킷이고 K는 임계값인 해시 함수 F(K, N)을 사용합니다.</li>\n<li>용량은 해시 인덱스의 버킷과 관련된 키를 나타내며 해시 인덱스의 모든 버킷은 8ㅂ이트로 구성되며 기본 섹션의 연결된 런다운 메모리 주소를 저장하는데 사용합니다.</li>\n</ul>\n<h3 id=\"unique-index-고유-인덱스\"><a href=\"#unique-index-%EA%B3%A0%EC%9C%A0-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Unique Index (고유 인덱스)</h3>\n<ul>\n<li>SQL 서버의 고유 인덱스는 인덱스 키에 복사 의존이 포함되어 있지 않는지 확인하고 보장하며 이러한 행을 따라 클라이언트가 테이블의 각 행이 어느쪽이든 예외적인지 검사할 수 있도록 합니다.</li>\n</ul>\n<br/>\n<h2 id=\"인덱스-생성-방법\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>인덱스 생성 방법</h2>\n<h3 id=\"자동-생성과-수동-생성\"><a href=\"#%EC%9E%90%EB%8F%99-%EC%83%9D%EC%84%B1%EA%B3%BC-%EC%88%98%EB%8F%99-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>자동 생성과 수동 생성</h3>\n<ul>\n<li>유일 인덱스는 테이블 정의시 primary key와 unique key 제약 조건을 정의할 때 자동으로 생성됩니다.</li>\n<li>사용자는 행에 대한 액세스 시간을 향상 시키기 위해 열에서 유일하지 않은 인덱스를 생성할 수 있습니다.</li>\n</ul>\n<h3 id=\"상세-생성-방법\"><a href=\"#%EC%83%81%EC%84%B8-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>상세 생성 방법</h3>\n<ul>\n<li>개발 디비에 따라 조금씩 다를 수 있으니 공식 document를 참고하는 것이 좋을 것 같습니다.</li>\n</ul>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://mongyang.tistory.com/75\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SQL, 인덱스(클러스터, 비클러스터) 개념</a></li>\n<li><a href=\"https://tipland.tistory.com/5\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">오라클 인덱스에 대한 정의</a></li>\n<li><a href=\"https://mozi.tistory.com/199\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MySQL, 인덱스 종류 및 고려사항</a></li>\n<li><a href=\"https://www.jigsawacademy.com/blogs/data-science/types-of-indexes-in-sql-server/amp/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">6 Important Types Of Indexes In SQL Server</a></li>\n</ul>\n"}},{"node":{"title":"[DB] Couchbase의 개념과 특징, 아키텍처","path":"/02-db-nosql-couchbase/","date":"20. September 2021","timeToRead":11,"description":"Nosql 중 Couchbase에 대해 좀 더 자세하게 알아봅니다.","content":"<h1 id=\"couchbase를-좀-더-자세하게\"><a href=\"#couchbase%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase를 좀 더 자세하게</h1>\n<p>지난 게시글은 다음과 같습니다.</p>\n<ul>\n<li><a href=\"https://azderica.github.io/00-db-nosql/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL</a></li>\n<li><a href=\"https://azderica.github.io/01-db-nosql-redis/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis</a></li>\n</ul>\n<p>오늘은 Couchbase 개념입니다.</p>\n<h2 id=\"couchbase-개념\"><a href=\"#couchbase-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase 개념</h2>\n<ul>\n<li>카우치 베이스는 Document 기반의 Key-Value 스토어입니다.</li>\n<li>하나의 유니크(Unique)한 키에 값을 저장하는 방식이며, 저장되는 값은 JSON 도큐먼트가 저장됩니다.</li>\n<li>키(key)는 최대 <strong>250 바이트</strong>, 밸류(Value)는 카우치베이스 버킷은 20BMB, Memcached 방식의 버킷의 경우 1MB까지 저장이 됩니다.</li>\n</ul>\n<p>저장할 때, 키와 값 뿐만 아니라 메타데이터도 같이 저장되며 메타 데이터는 <code class=\"language-text\">CAS, TTL, Flag</code> 값 3가지가 저장됩니다.</p>\n<ul>\n<li><code class=\"language-text\">CAS</code> : 데이터에 대한 일종의 타임 스탬프와 같은 개념으로, 여러 클라이언트가 같이 데이터를 접근했을 때 일관성(Consistent) 문제를 해결해줍니다.</li>\n<li><code class=\"language-text\">TTL</code> : <code class=\"language-text\">Time To Live</code>, 데이터의 유효 시간을 정의합니다.</li>\n<li><code class=\"language-text\">FLAG</code> : 카우치베이스 클라이언트에서 사용하는 메타데이터입니다.</li>\n</ul>\n<p>이러한 메타데이터는 하나의 메타데이터(CAS, TTL, Flag)는 60바이트의 메모리를 차지하며, 카우치베이스 서버는 모든 키와 메타데이터를 유지하기 위해 용량을 설계할때, RAM의 사이즈를 결정합니다.</p>\n<h3 id=\"버킷bucket\"><a href=\"#%EB%B2%84%ED%82%B7bucket\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>버킷(Bucket)</h3>\n<ul>\n<li>일종의 RDBMS의 데이터베이스 같은 공간이며 JSON document 들은 이 버킷에 저장됩니다.</li>\n<li>각각의 버킷은 고유의 속성 값을 가지고 있습니다. 버킷별로 사용할 수 있는 메모리 양, 옵션으로 버킷별로 접근할 수 있는 TCP 포트, 접근 비밀번호, 버킷에 들어가는 데이터에 대한 복제본의 수 등을 정할 수 있습니다.</li>\n</ul>\n<h3 id=\"뷰view\"><a href=\"#%EB%B7%B0view\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>뷰(View)</h3>\n<ul>\n<li>카우치 베이스의 강력한 능력이며, 이 뷰를 통해서 <code class=\"language-text\">Indexing, grouping, sorting</code> 등이 가능합니다.</li>\n<li>뷰는 데이터베이스 뷰와 유사한 개념을 가지며 카우치베이스의 뷰는 incremental view라는 컨셉을 가집니다.</li>\n</ul>\n<p>다음의 예시를 보면 뷰의 기능의 동작을 예상할 수 있습니다. Json document 안에 주민번호있고, 80년생 이하만 저장하는 뷰를 만든다고 가정하면 데이터가 버킷에 저장될 때마다 생성된 뷰에 같이 저장됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133991552-ccead205-7fc2-4ed3-bc6a-7832eee5e241.png\" alt=\"couchbase-view-sample\"></p>\n<p>이와 같은 결과로 데이터를 저장하거나 업데이트시 뷰 코드가 매번 수행되고, 뷰코드에 저장된 알고리즘에 따라 뷰에 데이터를 업데이트합니다.</p>\n<p>이를 더 자세하게 보면 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133992279-e17df7a9-9369-459f-9b27-9a840b9edb14.png\" alt=\"Map &#x26; Reduce\"></p>\n<p><a href=\"https://bcho.tistory.com/928?category=534534\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">출처 및 뷰에 대한 상세 개념</a></p>\n<p><code class=\"language-text\">Map Function(Map &amp; Reduce)</code> 함수를 통해서 View를 만듭니다.</p>\n<ul>\n<li>맵함수는 두 개의 인자를 전달받으며 index(id, key, value)를 만들고 리듀스를 통해서 grouping이나 여러 처리를 할 수 있습니다.</li>\n<li>즉, <strong>뷰에는 각 버킷내의 개별 데이터를 반환하는 맵함수와 변환된 개별 데이터를 그룹별로 모아서 처리할 수 있는 리듀스 함수를 가집니다.</strong></li>\n</ul>\n<br/>\n<h2 id=\"couchbase-특징\"><a href=\"#couchbase-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase 특징</h2>\n<h3 id=\"memcached-기반의-level-2-캐쉬를-내장하여-빠릅니다\"><a href=\"#memcached-%EA%B8%B0%EB%B0%98%EC%9D%98-level-2-%EC%BA%90%EC%89%AC%EB%A5%BC-%EB%82%B4%EC%9E%A5%ED%95%98%EC%97%AC-%EB%B9%A0%EB%A6%85%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Memcached 기반의 Level 2 캐쉬를 내장하여 빠릅니다.</h3>\n<ul>\n<li>memcached를 자체적으로 Level 2 캐쉬로 사용합니다.</li>\n<li>자체적으로 메모리 캐쉬 기능을 가지고 있기 때문에 성능이 빠릅니다.</li>\n</ul>\n<p>(다만, 키의 유연성이나 클러스터에서 단점을 가집니다.)</p>\n<h3 id=\"모바일-디바이스와-sync\"><a href=\"#%EB%AA%A8%EB%B0%94%EC%9D%BC-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4%EC%99%80-sync\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>모바일 디바이스와 Sync</h3>\n<ul>\n<li>카우치디비 계열 DB들은 모바일 디바이스에 탑재할 수 있으며, 서버에 설치된 카우치베이스 계열과 Sync가 됩니다.</li>\n</ul>\n<h3 id=\"데이터-센터간-복제-기간\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%84%BC%ED%84%B0%EA%B0%84-%EB%B3%B5%EC%A0%9C-%EA%B8%B0%EA%B0%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>데이터 센터간 복제 기간</h3>\n<ul>\n<li>XDCR(Cross Data Center Replication)의 기능을 이용해서 물리적으로 떨어진 데이터 센터간에 복제가 가능합니다.</li>\n<li><a href=\"https://azderica.github.io/00-db-couchbase-xdcr/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">XDCR의 상세 내용</a></li>\n</ul>\n<h3 id=\"indexing-grouping-ordering-join-가능\"><a href=\"#indexing-grouping-ordering-join-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Indexing, Grouping, Ordering, Join 가능</h3>\n<ul>\n<li>대부분의 NoSQL은 Key/Value Store 형식으로, 개별 필드에 대한 Indexing이나 필드별로 group by를 통한 sum,count 등의 기능, 특정 필드별로의 Sorting이 불가능합니다.</li>\n<li>Indexing을 지원하는 경우도 있기는 하지만, 내부적으로 성능상 문제가 있는 경우가 많으나 카우치베이스는 그러한 문제가 없습니다.</li>\n</ul>\n<h3 id=\"확장이-쉬움\"><a href=\"#%ED%99%95%EC%9E%A5%EC%9D%B4-%EC%89%AC%EC%9B%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>확장이 쉬움</h3>\n<ul>\n<li>분산 구조의 NoSQL의 경우 노드확장이 어렵거나 장애처리가 어려운 경우가 많으나 카우치베이스는 손쉽게 확장을 하고 장애 처리를 합니다.</li>\n<li>이러한 장점은 운영에서 큰 이점이 됩니다.</li>\n</ul>\n<h3 id=\"built-in-관리-도구-제공\"><a href=\"#built-in-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC-%EC%A0%9C%EA%B3%B5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Built in 관리 도구 제공</h3>\n<ul>\n<li>카우치베이스는 웹 기반의 GUI 관리 도구를 기본으로 제공합니다.</li>\n</ul>\n<blockquote>\n<p>Couchbase Web Console</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133992009-871775fb-ac8f-4453-ad35-5ba7ba349d31.png\" alt=\"couchbase-web-console\"></p>\n<p><a href=\"https://soccerda.tistory.com/124\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">출처</a></p>\n<h3 id=\"memcached-프로토콜-지원\"><a href=\"#memcached-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Memcached 프로토콜 지원</h3>\n<ul>\n<li>캐쉬 솔루션으로 유명한 Memcached 르포토콜을 지원하기 때문에 Memcached 인프라를 사용할 수 있습니다.</li>\n</ul>\n<h3 id=\"스키마가-없는-유연한-저장-구조scheme-less\"><a href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88%EA%B0%80-%EC%97%86%EB%8A%94-%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%A0%80%EC%9E%A5-%EA%B5%AC%EC%A1%B0scheme-less\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>스키마가 없는 유연한 저장 구조(Scheme-less)</h3>\n<ul>\n<li>스키마가 없으므로 하나의 테이블에 컬럼 형식이 다른 데이터를 넣을 수 있습니다.</li>\n<li>하나의 데이터 버킷에 데이타 구조가 다른 JSON 문서들을 넣을 수 있습니다.</li>\n<li>데이터 타입이 다름에도 불구하고 공통되는 필드에 대해 Indexing, grouping 등을 제공할 수 있으며 JSON 도큐먼트에 country 라는 앨리먼트가 있는 도큐먼트등을 대상으로 grouping등을 할수 있습니다.</li>\n</ul>\n<br/>\n<h2 id=\"couchbase-architecture\"><a href=\"#couchbase-architecture\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase Architecture</h2>\n<p>Couchbase Server는 모든 노드에 설치된 단일 패키지로 구성됩니다.</p>\n<h3 id=\"노드와-클러스터node--cluster\"><a href=\"#%EB%85%B8%EB%93%9C%EC%99%80-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0node--cluster\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>노드와 클러스터(Node &#x26; Cluster)</h3>\n<ul>\n<li>노드는 물리적인 서버에서 기동하는 하나의 카우치베이스 인스턴스</li>\n<li>카우치베이스는 여러 개의 노드로 이루어진 클러스터로 구성됩니다.</li>\n</ul>\n<h3 id=\"클라이언트-sdkclient-sdk\"><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-sdkclient-sdk\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>클라이언트 SDK(Client SDK)</h3>\n<ul>\n<li>프로그래밍 언어별로 카우치베이스에 접근하기 위한 API(SDK)를 제공합니다.</li>\n<li>SDK를 사용해서 선택한 언어(Java, node.js, .NET 등)으로 애플리케이션을 작성할 수 있습니다.</li>\n</ul>\n<h3 id=\"vbucket\"><a href=\"#vbucket\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>vBucket</h3>\n<ul>\n<li>카우치베이스는 실제 데이터와 물리서버간의 맵핑을 <code class=\"language-text\">vBucket</code>을 통해 관리합니다.</li>\n<li>카우치베이스는 키-밸류 스토어이며, 각 키가 어디있는지는 vBucket이라는 단위로 관리하고, 키에 대한 해쉬값을 계산한 후에 각 해쉬값에 따라서 저장되는 vBucket을 맵핑한다음 각 vBucket을 노드에 맵핑합니다.</li>\n<li><strong>Rebalancing</strong> : 노드가 추가되거나 삭제되었을 때, 물리적으로 데이터가 다른 노드로 다시 분산배치되고 새롭게 배치된 데이터에 따라 vBucket이 노드간에 데이터 맵핑 정보도 업데이트됩니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133996020-9ffb4d3d-9091-4e47-bb22-fdcf93baf961.png\" alt=\"vBucket\"></p>\n<h3 id=\"노드의-구조\"><a href=\"#%EB%85%B8%EB%93%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>노드의 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133996334-1d0c59e5-c7d7-48d9-a8a8-ea87bc0fed64.png\" alt=\"couchbase-node-detail\"></p>\n<ul>\n<li>Couchbase의 노드는 Data Manage과 Cluster Manager로 나눠집니다.</li>\n</ul>\n<h4 id=\"data-manager\"><a href=\"#data-manager\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Manager</h4>\n<ul>\n<li>직접 데이터에 접근하는 부분이며, set/get 메서드를 통한 데이터 저장이나 뷰에 대한 쿼리를 수행할 때 접근합니다.</li>\n<li><code class=\"language-text\">Multi Thread Persistence Engine</code> : 디스크에 데이터를 저장하거나 읽을 때 사용하는 컴포넌트입니다.</li>\n</ul>\n<h4 id=\"cluster-manager\"><a href=\"#cluster-manager\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cluster Manager</h4>\n<ul>\n<li>노드에 대한 상태와 클러스터에 대한 상태, 설정 등을 관리하는 부분이며 <code class=\"language-text\">Erlang/OTP</code>로 구성되어 있습니다.</li>\n<li>카우치베이스 클라이언트 SDK는 8091포트의 REST API를 통해서 vBucket 정보를 가져옵니다.</li>\n<li>다수의 포트 등을 사용합니다. (사용전에 열어야하는 포트들이 있습니다.)</li>\n</ul>\n<h3 id=\"데이터-쓰기와-복제\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%93%B0%EA%B8%B0%EC%99%80-%EB%B3%B5%EC%A0%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>데이터 쓰기와 복제</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133997054-0f325983-d6b6-4a10-b1e7-634de4a7e50b.png\" alt=\"couchbase-data-read/write\"></p>\n<ul>\n<li>클라이언트에서 Client SDK를 통해서 쓰기 요청을 하면, Client SDK는 해쉬 알고리즘에 따라 데이터의 키 값에 맵핑되는 vBucket을 찾아내고 그 해당하는 노드를 찾아 쓰기 요청을 합니다.</li>\n<li>쓰기 요청은 해당 노드의 Listener로 전달되고, 이 Listener는 들어온 데이터를 로컬의 캐쉬에 쓰고 클러스터의 다른 노드로 복제 요청을 보냅니다. 그리고 데이터는 노드의 디스크에 저장됩니다.</li>\n</ul>\n<br/>\n<h2 id=\"couchbase-cluster\"><a href=\"#couchbase-cluster\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase Cluster</h2>\n<ul>\n<li>Couchbase 클러스터는 각각 독립 노드에서 실행되는 하나 이상의 Couchbase Server 인스턴스로 구성됩니다.</li>\n<li>Couchbase Server를 실행하는 각 노드, 클러스터에 여러 노드가 있는 경우 Couchbase 클러스터 관리자는 각 노드에서 실행됩니다.</li>\n<li>클러스터의 전체 또는 일부 노드에서 실행되도록 서비스를 구성할 수 있습니다.</li>\n</ul>\n<h3 id=\"유혀성\"><a href=\"#%EC%9C%A0%ED%98%80%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>유혀성</h3>\n<ul>\n<li>데이터는 Couchbase Server에 의해 클러스터 전체에 자동으로 배포됩니다.</li>\n<li>Couchbase Server는 노드 추가 및 제거, 노드 장애를 자동으로 처리합니다.</li>\n</ul>\n<br/>\n<h2 id=\"couchbase-vs-mongodb\"><a href=\"#couchbase-vs-mongodb\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase VS MongoDB</h2>\n<p>공통점은 다음과 같습니다.</p>\n<ul>\n<li>Document 기반의 NoSQL입니다.</li>\n</ul>\n<p>그러나 차이점이 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>이름</th>\n<th>Couchbase</th>\n<th>MongoDB</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>설명</td>\n<td>Memcached 호환 인터페이스를 사용하여 CouchDB에서 파생된 JSON 기반 문서 저장소</td>\n<td>완전 관리형 클라우드 서비스와 자체 관리형, 인프라에 배포할 수 있는 가장 인기있는 문서 저장소 입니다.</td>\n</tr>\n<tr>\n<td>기본 데이터베이스 모델</td>\n<td>문서 저장소</td>\n<td>문서 저장소</td>\n</tr>\n<tr>\n<td>보조 데이터베이스 모델</td>\n<td>키-값 저장 공간 DBMS</td>\n<td>공간 DBMS</td>\n</tr>\n<tr>\n<td>스키마</td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>파티셔닝</td>\n<td>샤딩</td>\n<td>샤딩</td>\n</tr>\n</tbody>\n</table>\n<p>좀 더 자세한 차이를 알기 위해서는 다음 링크를 참고합니다.</p>\n<p><a href=\"https://db-engines.com/en/system/Couchbase%3BMongoDB\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Couchbase VS MongoDB</a></p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://bcho.tistory.com/924\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase 소개</a></li>\n<li><a href=\"https://bcho.tistory.com/925\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase 개념</a></li>\n<li><a href=\"https://bcho.tistory.com/928\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase view</a></li>\n<li><a href=\"https://bcho.tistory.com/934\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase architecture</a></li>\n<li><a href=\"https://docs.couchbase.com/server/5.0/architecture/architecture-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase architecture detail</a></li>\n<li><a href=\"https://docs.couchbase.com/server/current/learn/clusters-and-availability/clusters-and-availability.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase cluster</a></li>\n<li><a href=\"https://dzone.com/articles/introduction-to-couchbase-for-mongodb-developers-a-1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase vs mongodb</a></li>\n<li><a href=\"https://zepinos.tistory.com/60?category=797689\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">왜 Couchbase을 선택하게 되었는가 - 1</a></li>\n<li><a href=\"https://zepinos.tistory.com/61\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">왜 Couchbase을 선택하게 되었는가 - 2</a></li>\n<li><a href=\"https://docs.couchbase.com/couchbase-manual-2.5/cb-admin/#faqs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Couchbase Docs</a></li>\n</ul>\n"}},{"node":{"title":"[DB] Redis의 개념과 특징, 아키텍처","path":"/01-db-nosql-redis/","date":"17. September 2021","timeToRead":9,"description":"NoSQL 중 Redis에 대해 좀 더 자세하게 알아봅니다.","content":"<h1 id=\"redis를-좀-더-자세하게\"><a href=\"#redis%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis를 좀 더 자세하게.</h1>\n<p>지난번 게시글에서는 <a href=\"https://azderica.github.io/00-db-nosql/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL</a>에 대한 기본 개념과 종류에 대해서 정리했습니다.</p>\n<p>이번에는 더 나아가서 대표적인 NoSQL이 가지는 아키텍처를 정리합니다. 오늘은 Redis에 대해 좀 더 정리하려고합니다.</p>\n<h2 id=\"redis란\"><a href=\"#redis%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis란.</h2>\n<ul>\n<li>고 성능의 키-값 데이터 구조 스토어입니다.</li>\n<li>여러 자료구조를 지원하며 크게 <code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 등의 데이터 형식을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis-특징\"><a href=\"#redis-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 특징</h2>\n<ul>\n<li>\n<p>영속성을 지원하는 인메모리 데이터 저장소</p>\n<ul>\n<li>왜 영속성을 제공하는지는 아래에서 설명합니다.</li>\n</ul>\n</li>\n<li>\n<p>읽기 성능 증대를 위한 서버 측 복제를 지원합니다.</p>\n<ul>\n<li>전체 데이터베이스의 초기 복사본을 받는 마스터/슬레이브 복제를 지원합니다.</li>\n<li>마스터에서 쓰기가 수행되면 슬레이브 데이터 세트를 실시간으로 업데이터하기 위해 연결된 모든 슬레이브로 전송됩니다.</li>\n</ul>\n</li>\n<li>쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding)을 지원합니다.</li>\n<li><code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 과 같은 다양한 데이터형을 지원합니다.</li>\n</ul>\n<blockquote>\n<p>샤딩(Sharding)</p>\n</blockquote>\n<p>파티셔닝과 동일하며, 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미합니다.</p>\n<br/>\n<h2 id=\"redis-특징-1\"><a href=\"#redis-%ED%8A%B9%EC%A7%95-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 특징</h2>\n<h3 id=\"key-value-store\"><a href=\"#key-value-store\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Key-Value Store</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133774329-00ddf3c0-a24e-40b0-9dd8-460616ea5400.png\" alt=\"Redis-is-map\"></p>\n<ul>\n<li>Redis는 거대한 맵(Map) 데이터 저장소입니다.</li>\n<li>Redis는 익히기 쉬우며 직관적입니다. 그러나, 데이터를 레디스 자체 내에서는 처리하기 어렵습니다.</li>\n</ul>\n<h3 id=\"다양한-데이터-타입\"><a href=\"#%EB%8B%A4%EC%96%91%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>다양한 데이터 타입</h3>\n<ul>\n<li><code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 등의 타입을 지원합니다.</li>\n</ul>\n<h3 id=\"persistence\"><a href=\"#persistence\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Persistence</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133775761-c7644499-ae6f-4aa8-bd25-8208780c41e0.png\" alt=\"Redis-Persistence\"></p>\n<ul>\n<li>Redis는 영속성을 가집니다.</li>\n<li>Redis는 데이터를 disk에 저장할 수 있습니다. 따라서 Redis는 서버가 강제 종료되고 재시작하더라도 disk에 저장해놓은 데이터를 다시 읽어서 데이터가 유실되지 않습니다.</li>\n<li>\n<p>redis의 데이터를 disk에 저장하는 방식은 <strong>snapshot, AOF</strong> 방식이 있습니다.</p>\n<ul>\n<li><code class=\"language-text\">Snapshot</code> : RDB와 비슷하게 어떤 특정 시점의 데이터를 Disk에 담는 방식을 뜻합니다. <strong>Blocking</strong> 방식의 <strong>SAVE</strong>와 <strong>Non-blocking</strong> 방식의 <strong><a href=\"http://redisgate.kr/redis/server/bgsave.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">BGSAVE</a></strong> 방식이 있습니다.</li>\n<li><code class=\"language-text\">AOF</code> : Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태입니다. 서버가 재시작 시 write/update를 순차적으로 재실행하고 데이터를 복구합니다.</li>\n<li>가장 좋은 방식은 두 방법을 혼용해서 사용하는 방법으로 주기적으로 snapshot으로 백업을 하고 다음 snapshot까지의 저장을 AOF 방식으로 수행하는 방식입니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ansi-c로-작성\"><a href=\"#ansi-c%EB%A1%9C-%EC%9E%91%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ANSI C로 작성</h3>\n<ul>\n<li>C언어로 작성되어 Java와 같이 가상머신 위에서 동작하는 언어에서 발생하는 성능 문제에서 자유롭습니다.</li>\n</ul>\n<h3 id=\"서버측-복제-및-샤딩-지원\"><a href=\"#%EC%84%9C%EB%B2%84%EC%B8%A1-%EB%B3%B5%EC%A0%9C-%EB%B0%8F-%EC%83%A4%EB%94%A9-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서버측 복제 및 샤딩 지원</h3>\n<ul>\n<li>읽기 성능 증대를 위해 서버 측 복제를 지원합니다.</li>\n<li>쓰기 성능 증대를 위해 클라이언트 측 샤딩을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis의-장점\"><a href=\"#redis%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis의 장점</h2>\n<ul>\n<li>리스트, 배열과 같은 데이터를 처리하는데 유용합니다.</li>\n<li>Message Queue, Shared Memory, Remote Dictionary(RDBMS의 캐시 솔루션 / read 속도가 매우 빠릅니다.) 용도로 사용됩니다.</li>\n<li>메모리를 활용하면서 데이터를 보존합니다.</li>\n<li>Redis Server는 1개의 싱글 쓰레드로 수행되며, 서버 하나에 여러개의 서버를 띄우는 것이 가능합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis-아키텍처-구성\"><a href=\"#redis-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 아키텍처, 구성</h2>\n<ul>\n<li>HA(High Availability) : 무중단 서비스 등</li>\n</ul>\n<h3 id=\"standalone--no-ha-마스터\"><a href=\"#standalone--no-ha-%EB%A7%88%EC%8A%A4%ED%84%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Standalone : No HA, 마스터</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133778042-cf59f712-752a-4c61-8a1a-b9ac435726a1.png\" alt=\"Redis-Standalone\"></p>\n<ul>\n<li>레디스 서버 1대로 구성하며 이를 마스터 노드라고 합니다.</li>\n<li>서버 다운시 AOF 또는 Snapshot 파일을 이용해 재 시작합니다.</li>\n</ul>\n<h3 id=\"replication--half-ha-마스터-슬레이브\"><a href=\"#replication--half-ha-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%AC%EB%A0%88%EC%9D%B4%EB%B8%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Replication : Half HA, 마스터-슬레이브</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133778753-41bfa929-aa5f-48e5-9509-7e4df1379baa.png\" alt=\"Redis-Replication\"></p>\n<ul>\n<li>레디스 서버 2대(마스터-슬레이브)로 구성됩니다. 슬레이브는 마스터의 데이터를 실시간으로 전달받아 보관합니다.</li>\n<li>마스터 다운 시 슬레이브 서버를 통해 서비스를 계속할 수 있습니다. 하지만, 이때는 수동으로 슬레이브 서버를 마스터로 변경해야합니다.</li>\n<li>한 마스터에 슬레이브를 여러 대 구성할 수 도 있습니다.</li>\n</ul>\n<h3 id=\"이중화--센티널sentinel--ha-무중단-서비스-가능\"><a href=\"#%EC%9D%B4%EC%A4%91%ED%99%94--%EC%84%BC%ED%8B%B0%EB%84%90sentinel--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>이중화 + 센티널(Sentinel) : HA, 무중단 서비스 가능</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133779960-5c97207f-75d7-405c-a4ea-730bba593e2d.png\" alt=\"image\"></p>\n<ul>\n<li>마스터-슬레이브 구성에 <strong>센티널</strong>을 추가해서 각 서버를 감시하도록하며, 센티널은 마스터 서버를 감시하고 있다가 다운되면 슬레이브를 마스터로 승격시킵니다.</li>\n<li>다운된 마스터가 다시 시작되면 센티널이 슬레이브로 전환시킵니다.</li>\n<li>레디스 마스터 노드가 모든 데이터를 가지고 있으며 슬레이브는 마스터에 대한 복제본을 유지하고 있으며, 데이터를 분산하지 않습니다.</li>\n<li>일반적으로 레디스 센티널은 레디스 서버마다 하나씩 설치하며, 레디스 서버와 분리된 프로세스이며 다른 포트를 사용합니다. (데이터를 처리하지 않습니다.)</li>\n<li>레디스 센티널은 높은 가용성과 자동 fail over 을 해결하지만 <strong>데이터 분산 문제를 해결하지 못합니다.</strong></li>\n</ul>\n<p><a href=\"https://hub.docker.com/r/erichsu/redis-sentinel/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Sentinel Docker</a></p>\n<h3 id=\"레디스-클러스터cluster--ha-무중단-서비스-가능\"><a href=\"#%EB%A0%88%EB%94%94%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0cluster--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>레디스 클러스터(Cluster) : HA, 무중단 서비스 가능</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133781464-16c21b85-1ca2-4e0f-8028-5acf9a37a2f8.png\" alt=\"Redis-Cluster-Type-1\"></p>\n<p>머신 하나가 죽었을 시 해결이 됩니다. 다만 두개가 죽으면 해결이 안됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133782017-fe094509-ed9a-419c-9739-35a766b4e334.png\" alt=\"Redis-Cluster-Type-2\"></p>\n<p>위의 문제를 해결하는 방법입니다.</p>\n<ul>\n<li>\n<p><strong>샤딩</strong></p>\n<ul>\n<li>클라스터는 <strong>샤딩</strong>(sharding, 대량의 데이터를 처리하기 위해 여러 개의 데이터베이스에 분할하는 기술) 방법을 제공하는 방법입니다.</li>\n<li>100개의 데이터를 1번 마스터에 33개, 2번 마스터 33개, 3번 마스터에 나머지 34개가 저장되는 방식입니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>Hash 함수</strong></p>\n<ul>\n<li>데이터를 나누는 방식은 키에 hash 함수를 적용해서 값을 추출하고, 이 값을 각 마스터 서버에 할당합니다.</li>\n<li>클러스터 구성시 해쉬 함수를 통해서 1~33까지를 1번 서버, 34~ 66번까지를 2번 서버, 3번 서버는 또 다르게 할당됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>해시 슬록(16384 슬롯)</strong></p>\n<ul>\n<li>레디스에서 hash 값의 개수는 16384(0~16383)이고 슬롯(slot)이라고 합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>해시 태그</strong></p>\n<ul>\n<li>다중 키 작업을 진행하려면 동일 노드에 저장될 모든 키가 필요합니다. 해시 태그는 레디스 클러스터에서 다중키를 사용할 수 있는 유일한 방법입니다.</li>\n<li>해시 함수를 적용해 동일한 해시 슬롯에 여러 개의 키 이름을 저장할 수 있도록 사용됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>레디스 클라이언트</strong></p>\n<ul>\n<li>클라이언트는 서버와 동일한 hash 함수를 가지고 있으며 마스터 서버에 접속해서 각 서버에 할당된 슬롯 정보를 가지고 있습니다.</li>\n<li>키가 입력되면 hash 함수를 적용해서 어느 마스터에 저장할지 판단해서 해당 마스터에 저장합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>데이터 서버 + 센티널</strong></p>\n<ul>\n<li>각 마스터 서버는 데이터의 처리와 센티널의 역할을 같이수행합니다.</li>\n<li>1번 마스터 서버가 다운되면 나머지 살아있는 마스터들 중에서 리더를 선출해서 리더가 1번 마스터의 슬레이브를 마스터로 승격시킵니다.</li>\n</ul>\n</li>\n<li>\n<p>최소 3대</p>\n<ul>\n<li>마스터 서버는 최소 3대로 구성하고 각각은 슬레이브를 가질 수 있습니다.</li>\n</ul>\n</li>\n<li>마스터를 관리하는 마스터는 없습니다. 이는 또 하나의 장애점입니다.</li>\n<li>레디스가 사용하는 포트는 2개이며 하나는 클라이언트 하나는 노드 간의 통신을 위한 버스로 사용됩니다.</li>\n</ul>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jyejye9201.medium.com/%EB%A0%88%EB%94%94%EC%8A%A4-redis-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-2b7af75fa818\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis란 무엇인가</a></li>\n<li><a href=\"https://docs.redis.com/latest/rs/concepts/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Concept</a></li>\n<li><a href=\"http://redisgate.kr/redis/configuration/redis_overview.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Architecture Overview</a></li>\n<li><a href=\"https://cla9.tistory.com/101\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis 구조</a></li>\n<li><a href=\"https://engkimbs.tistory.com/869\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">레디스 소개 및 아키텍처, 주의할 점</a></li>\n<li><a href=\"https://coding-start.tistory.com/128\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis - Cluster &#x26; Sentinel</a></li>\n<li><a href=\"https://redis.io/commands\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Command</a></li>\n<li><a href=\"https://redis.com/redis-enterprise/technology/redis-enterprise-cluster-architecture/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Enterprise Cluster Architecture</a></li>\n</ul>\n"}},{"node":{"title":"[DB] INDEX SEEK 정리","path":"/00-db-index-seek/","date":"14. July 2021","timeToRead":2,"description":"INDEX SEEK와 SCAN에 대해 정리합니다.","content":"<h1 id=\"db-mssql-index-seek\"><a href=\"#db-mssql-index-seek\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>[DB] MSSQL Index Seek</h1>\n<h2 id=\"index-seek란\"><a href=\"#index-seek%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Index Seek란?</h2>\n<p>일종의 Non-Clustered Index를 인덱스 트리를 타고 원하는 데이터로 바로 접근한 경우입니다.</p>\n<p>일반적으로 Non-Clustered Index는 Dense Index이고, Secondary Index입니다.</p>\n<ul>\n<li>*Index : 검색의 효율성을 높이기 위한 물리적인 데이터 구조</li>\n<li>*Sparse Index : 해당 레코드 존재 페이지를 가리키는 포인터를 저장합니다.</li>\n<li>*Dense Index(Secondary Index) : 해당 레코드를 가리키는 포인터를 저장합니다.</li>\n</ul>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> TableA\n<span class=\"token keyword\">where</span> colA <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'B105'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'C101'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- colA에 Non-Clustered Index가 생성됩니다.</span>\n<span class=\"token comment\">-- Clustered Index는 생성되지 않습니다.</span>\n<span class=\"token comment\">-- 이 쿼리는 실제 실행에서 Index Seek를 한다고 가정합니다.</span></code></pre>\n<p>이 쿼리문을 처리하는 과정은 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/125635036-f05263f7-f7f2-4dcc-9d11-a20b10247b6d.png\" alt=\"image\"></p>\n<p>SQL Server는 'B105'를 찾기위해서 동작하고 이 동작을 Index Seek라고 부릅니다.</p>\n<ul>\n<li>Root Page를 통해서 Index Page를 찾습니다.</li>\n<li>Index Path에서 Data Page를 찾아, 해당 Row를 읽습니다.</li>\n</ul>\n<p>다만 이 경우 Unique Index인지, Non-Unique Index인지에 따라 페이지를 읽은 수가 다릅니다.</p>\n<ul>\n<li>Unique Index 인 경우, 3Page를 읽습니다.(Index Page = 2, Data Page = 1)</li>\n<li>Non-Unique Index 인 경우, 한 페이지를 더 읽어야합니다. ('B105' 다음이 있는지 확인해야 마지막인 것을 확인할 수 있으므로)</li>\n</ul>\n<p>다만, <strong>핵심 중 하나는 적은 Row 수를 가지는 경우</strong>에서는 Index를 생성하지 않는 것이 좋습니다. 그 이유는 CPU 비용이 Index Seek 보다 Full Scan이 더 적기 때문입니다. (Index Seek 보다는 Data Page를 처음부터 끝까지 읽어서 필요한 부분을 읽는 것이 더 좋습니다.)</p>\n<h2 id=\"index-scan과-index-seek-의-차이\"><a href=\"#index-scan%EA%B3%BC-index-seek-%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Index Scan과 Index Seek 의 차이</h2>\n<ul>\n<li>Index Scan : 해당 테이블의 컬럼을 모두 찾습니다.</li>\n<li>Index Seek : 해당 인덱스를 바로 찾아갑니다.</li>\n</ul>\n<p>이와 같이 Seek가 일반적으로 Scan보다 비용(cost)이 적게 드는 것을 확인할 수 있습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"http://databaser.net/moniwiki/wiki.php/Index\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Index</a></li>\n<li><a href=\"http://databaser.net/moniwiki/wiki.php/IndexSeek\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">IndexSeek</a></li>\n<li><a href=\"https://psawesome.tistory.com/14\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Index Seek, Index Scan</a></li>\n<li><a href=\"https://blog.naver.com/PostView.nhn?blogId=waws01&#x26;logNo=60181424769\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">인덱스 SCAN과 SEEK의 차이</a></li>\n</ul>\n"}},{"node":{"title":"[DB] ORM에 대해 정리하기","path":"/00-db-orm/","date":"3. April 2021","timeToRead":5,"description":"ORM에 대해 정리합니다. ","content":"<h1 id=\"orm에-대해\"><a href=\"#orm%EC%97%90-%EB%8C%80%ED%95%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ORM에 대해</h1>\n<p>지난 게시글에서는 jpa에 대해서 정리하면서 ORM에 대한 개념을 언급했는데 오늘은 ORM에 대한 상세 내용을 정리합니다.</p>\n<ul>\n<li><a href=\"https://azderica.github.io/00-java-jpa/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JPA 정리글</a></li>\n</ul>\n<br/>\n<h2 id=\"영속성persistence\"><a href=\"#%EC%98%81%EC%86%8D%EC%84%B1persistence\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>영속성(Persistence)</h2>\n<p>먼저 ORM에 들어가기전에 영속성에 대한 개념을 정리합니다.</p>\n<p>영속성은 다음을 의미합니다.</p>\n<ul>\n<li>데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터 특성</li>\n<li>영속성이 없는 데이터는 단지 메모리에서만 존재하므로, 프로그램 종료 시 모두 잃어버립니다.</li>\n<li>\n<p><strong>Object Persistence(영구적인 객체)</strong></p>\n<ul>\n<li>메모리 상의 데이터를 File이나 DB를 활용해서 영속성을 부여합니다.</li>\n</ul>\n</li>\n</ul>\n<p>자바에서 데이터를 저장하는 방법은 다음과 같습니다.</p>\n<ul>\n<li>JDBC</li>\n<li>Spring JDBC</li>\n<li><strong>Persistence Framework</strong>(Hibernate, Mybatis...)</li>\n</ul>\n<blockquote>\n<p>Persistence Framework</p>\n</blockquote>\n<p>Persistence Layer</p>\n<ul>\n<li>데이터베이스에서 데이터를 읽어(Read) 객체화하거나, 데이터 베이스에 데이터를 저장(Create), 수정(Update), 삭제(Delete)하는 역할</li>\n</ul>\n<p><strong>Persistence Framework</strong></p>\n<ul>\n<li>JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와연동되는 시스템을 빠르게 개발할 수 있습니다.</li>\n<li>\n<p>일반적으로 SQL Mapper와 ORM으로 나눠집니다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">SQL Mapper</code></p>\n<ul>\n<li>SQL &#x3C;-> SQL Mapper &#x3C;-> Object 필드</li>\n<li>SQL 문장으로 직접 데이터베이스 데이터를 다룬다.</li>\n<li>SQL을 직접 작성합니다.</li>\n<li><strong>Mybatis, JdbcTemplates(Spring)</strong></li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">ORM</code></p>\n<ul>\n<li>Database data &#x3C;-> ORM &#x3C;-> Object 필드</li>\n<li>객체를 통해서 간접적으로 데이터베이스 데이터를 다룹니다.</li>\n<li>객체와 관계형 데이터베이스의 데이터를 자동으로 맵핑시켜줍니다.</li>\n<li><strong>JPA, Hibernate</strong> 등이 있습니다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"orm의-정의\"><a href=\"#orm%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ORM의 정의</h2>\n<p>ORM(Object-relational mapping)은 <strong>객체(클래스)와 관계(RDB, Relational Database)와의 설정</strong>을 의미합니다.</p>\n<p>객체 지향 프로그래밍은 클래스를 사용하고 관계형 데이터 베이스는 테이블을 사용합니다. 여기서 객체 모델과 관계형 모델간에 불일치가 발생하게 되는데, ORM은 이러한 <strong>불일치를 객체간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결</strong>합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/111995242-0ca00d80-8b5c-11eb-9662-7f60f1dfc0c7.png\" alt=\"ORM\"></p>\n<p>해당 그림처럼, Object와 DB 데이터 사이에서 매핑을 합니다.</p>\n<br/>\n<h2 id=\"orm의-장단점\"><a href=\"#orm%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ORM의 장단점</h2>\n<h3 id=\"orm-장점\"><a href=\"#orm-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ORM 장점</h3>\n<ul>\n<li>\n<p>객체 지향적 코드를 사용함으로서 직관적이보 비지니스 로직에 집중할 수 있도록 도와줍니다.</p>\n<ul>\n<li>CRUD를 위한 SQL문을 작성할 필요는 없습니다. (쿼리 작성은 필요)</li>\n<li>각 객체(Model) 별로 코드를 작성하므로 가독성이 높아집니다.</li>\n</ul>\n</li>\n<li>\n<p>재사용 및 유지 보수의 편리성이 증가합니다.</p>\n<ul>\n<li>ORM은 독립적으로 작성이 되어 있고 해당 객체들은 재사용이 가능합니다.</li>\n</ul>\n</li>\n<li>\n<p>DBMS에 대한 종속성이 줄어듭니다.</p>\n<ul>\n<li>대부분의 ORM은 DB에 비종속적입니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"orm-단점\"><a href=\"#orm-%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ORM 단점</h3>\n<ul>\n<li>\n<p>완벽한 ORM만으로는 구현하기가 어렵습니다.</p>\n<ul>\n<li>사용하기는 편하지만 설계는 신중해야합니다.</li>\n<li>프로젝트의 복잡성이 높아질 경우, 난이도가 높아집니다.</li>\n<li>잘못 구현하는 경우 속도 저하 및 심한 경우, 일관성이 무너질 수도 있습니다.</li>\n</ul>\n</li>\n<li>프로시저가 많은 시스템에서는 ORM의 객체 지향적인 장점을 활용하기가 어렵습니다.</li>\n</ul>\n<br/>\n<h2 id=\"orm의-종류\"><a href=\"#orm%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ORM의 종류</h2>\n<p>앞서 이야기한 것외에도 다양한 ORM이 존재합니다.</p>\n<ul>\n<li>Flask : SQLAlchemy</li>\n<li>Django : 내장 ORM</li>\n<li><strong>Node.js : Sequalize</strong></li>\n<li><strong>Java : Hybernate, JPA</strong></li>\n<li>GraphQL : Prisma</li>\n</ul>\n<p>해당 ORM에 대해서는 직접 사용해보면서 차이를 느껴보고 개념을 이해하는 것을 추천합니다. (개인적으로 사용해본 것은 Sequalize와 Hybernate, JPA이지만, 실무에서는 따로 환경이 안나와서 써보지 못했습니다...)</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>핵심적인 내용은 정리르 했으나, 개인적으로 알고 싶은 내용인 queryDsl과 Jooq에 대해서는 따로 정리를 하지 못했습니다. 해당 글은 좀 더 개념을 잡아 정리하겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://velog.io/@alskt0419/ORM%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C...-iek4f0o3fg\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ORM이란?</a></li>\n<li><a href=\"https://changrea.io/jpa/orm/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ORM</a></li>\n<li><a href=\"https://velog.io/@alskt0419/ORM%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C...-iek4f0o3fg\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ORM에 대해서</a></li>\n<li><a href=\"https://gmlwjd9405.github.io/2019/02/01/orm.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DB, ORM이란</a></li>\n</ul>\n"}},{"node":{"title":"[Database] Couchbase XDCR","path":"/00-db-couchbase-xdcr/","date":"2. April 2021","timeToRead":4,"description":"Couchbase XDCR에 대해 정리합니다.","content":"<h1 id=\"couchbase-xdcr\"><a href=\"#couchbase-xdcr\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase XDCR</h1>\n<ul>\n<li>최근 진행해야하는 작업 중 하나가, 기존 Couchbase 서버가 있는 데이터 센터에서 서버 부하 해결 및 안정성을 위해 다른 데이터 센터에 데이터를 복제를 해야할 필요성이 존재합니다.</li>\n<li>회사에서 작업하는 주 목적은 데이터 서버에 있는 Couchbase 서버가 모두 죽었을 때, 정상적으로 작동하도록 구성하는 것이 목표입니다.</li>\n<li>이를 위해서 Cross Data Center Replication (약어, XDCR)에 대해 정리합니다.</li>\n</ul>\n<h2 id=\"xdcr이란\"><a href=\"#xdcr%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>XDCR이란.</h2>\n<ul>\n<li>XDCR(Cross Data Center Replication)은 클러스터 간의 데이터를 복제하며, 데이터 센터 장애에 대한 보호 기능과 고성능 데이터 액세스 기능을 제공합니다.</li>\n<li>XDCR은 source 클러스터의 특정 버킷에서 대상 클러스터의 특정 버킷으로 데이터를 복제합니다. XDCR agent를 통해 Database Change Protocol을 사용하여 버킷에서 다른 타켓 버킷으로 데이터를 넘길 수 있습니다.</li>\n</ul>\n<br/>\n<h2 id=\"xdcr과-클러스터-내부-복제와의-차이\"><a href=\"#xdcr%EA%B3%BC-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EB%82%B4%EB%B6%80-%EB%B3%B5%EC%A0%9C%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>XDCR과 클러스터 내부 복제와의 차이</h2>\n<ul>\n<li>클러스터 내부 복제의 경우, 클로스터 노드 전체에 데이터를 복제하나 XDCR의 경우 다른 데이터센터에 있는 여러 클러스터에 데이터를 복제합니다.</li>\n<li>클러스터 내부 복제의 경우, 단일 버킷에 대해 수행되지만 XDCR은 복제를 위해 두 개의 버킷이 필요합니다. (하나는 복제 데이터 제공 소스 클러스터 버킷, 다른 하나는 수신 받을 대상의 클러스터)</li>\n<li>클러스터 내 복제는 버킷 생성에서 구성되지만, XDCR은 소스 버킷과 대상 버킷을 모두 생성 후에 구성됩니다.</li>\n</ul>\n<blockquote>\n<p>클러스터(cluster)</p>\n</blockquote>\n<ul>\n<li>여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하는 컴퓨터들의 집합, 해당 위에서는 서버들의 집합</li>\n</ul>\n<blockquote>\n<p>버킷(bucket)</p>\n</blockquote>\n<ul>\n<li>일반적으로 데이터가 영역으로 분할되는 document 유형입니다.</li>\n</ul>\n<br/>\n<h2 id=\"xdcr-절차\"><a href=\"#xdcr-%EC%A0%88%EC%B0%A8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>XDCR 절차</h2>\n<p>사전 작업</p>\n<ul>\n<li>\n<p>XDCR의 대상이 될 원격 클러스터에 대한 References를 정의합니다.</p>\n<ul>\n<li><a href=\"https://docs.couchbase.com/server/current/manage/manage-xdcr/create-xdcr-reference.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Document</a></li>\n</ul>\n</li>\n<li>\n<p>소스 버킷에서 지장된 대상 버킷으로 변경내용을 전송하는 복제를 정의하고 시작합니다.</p>\n<ul>\n<li><a href=\"https://docs.couchbase.com/server/current/learn/clusters-and-availability/xdcr-overview.html#manage:manage-xdcr/create-xdcr-replication\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Document</a></li>\n</ul>\n</li>\n<li>복제를 모니터링합니다.</li>\n</ul>\n<p>다음의 옵션을 사용할 수 있습니다.</p>\n<ul>\n<li>Couchbase Web Console</li>\n<li>CLI</li>\n<li>REST API(Web Console, CLI)</li>\n</ul>\n<br/>\n<h2 id=\"xdcr-direction-topology\"><a href=\"#xdcr-direction-topology\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>XDCR Direction, Topology</h2>\n<ul>\n<li>크게 전략은 단방향(Unidirectionally)와 양방향(Bidirectionally)로 구성됩니다.</li>\n<li>향후 진행할 작업은 양방향 XDCR을 구성할 방향이다.</li>\n</ul>\n<h3 id=\"unidirectionally\"><a href=\"#unidirectionally\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Unidirectionally</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/113409137-a2089080-93eb-11eb-9fdc-15f325939633.png\" alt=\"Unidirectionally\"></p>\n<ul>\n<li>지정된 소스 버킷에 포함된 데이터가 지정된 대상 버킷에 복제되며, 일반적으로 <strong>백업 용도로 사용</strong>됩니다.</li>\n</ul>\n<h3 id=\"bidirectionally\"><a href=\"#bidirectionally\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Bidirectionally</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/113409142-a5038100-93eb-11eb-8e01-c23ce981dfd5.png\" alt=\"Bidirectionally\"></p>\n<ul>\n<li>지정된 소스 버킷에 포함된 데이터는 대상 버킷에 복제되고, 반대의 방향의 경우에도 적용됩니다. 해당 두 버킷을 모두 데이터 서비스용으로 사용할 수 있으며, <strong>사용자에 좀 더 빠른 데이터 액세스를 제공</strong>할 수 있습니다.</li>\n<li>이러한 양방향 XDCR은 두 데이터 센터 이상으로도 작업할 수 있습니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/113409371-1d6a4200-93ec-11eb-8ff6-0a2205b62be6.png\" alt=\"image\"></p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간략하게, XDCR에 대해 작성했습니다. 향후, 해당 작업 완료 후 추가적인 게시글을 작성할 예정입니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://docs.couchbase.com/server/current/learn/clusters-and-availability/xdcr-overview.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Couchbase XDCR Doc</a></li>\n</ul>\n"}},{"node":{"title":"[DB] NoSQL 데이터베이스 정리","path":"/00-db-nosql/","date":"1. April 2021","timeToRead":8,"description":"NoSQL에 대해 소개하고 특징에 대해 정리합니다.","content":"<h1 id=\"nosql\"><a href=\"#nosql\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NoSQL</h1>\n<p>해당 게시글은 NoSQL에 대한 내용을 간략하게 정리하고, 여러가지 NoSQL Database를 특징별로 정리합니다.</p>\n<br/>\n<h2 id=\"rdb와의-차이\"><a href=\"#rdb%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>RDB와의 차이</h2>\n<p>대부분 RDB와 NoSQL의 차이를 인지하고 있는데 이를 표로 간략하게 정리하면 다음과 같습니다.</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>RDB</th>\n<th>NoSQL</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>데이터모델</td>\n<td>고정 행과 열이 있는 테이블</td>\n<td>document-Json, key value, ...</td>\n</tr>\n<tr>\n<td>예시</td>\n<td>Oracle, MySQL, MSSQL, PostgreSQL</td>\n<td>MongoDB, Redis, Hbase, Neo4j</td>\n</tr>\n<tr>\n<td>목적</td>\n<td>범용</td>\n<td>범용, 대량의 데이터 추출, 관계 분석, 탐색 등</td>\n</tr>\n<tr>\n<td>스키마</td>\n<td>엄격</td>\n<td>유연</td>\n</tr>\n<tr>\n<td>확장성</td>\n<td>수직</td>\n<td>수형성</td>\n</tr>\n<tr>\n<td>ACID 트랜잭션</td>\n<td>지원</td>\n<td>대부분 지원하지 않음</td>\n</tr>\n<tr>\n<td>ORM</td>\n<td>ORM 필요</td>\n<td>대부분 ORM이 필요없음</td>\n</tr>\n</tbody>\n</table>\n<br/>\n<h2 id=\"nosql의-장단점\"><a href=\"#nosql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NoSQL의 장단점</h2>\n<h3 id=\"nosql의-장점\"><a href=\"#nosql%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NoSQL의 장점</h3>\n<p>NoSQL은 다음의 장점을 가집니다.</p>\n<ul>\n<li>\n<p>유연한 데이터 모델</p>\n<ul>\n<li>유연한 스키마를 가지므로, 요구 사항이 변경되었을 때 데이터베이스를 쉽게 변경할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>수평적 확장</p>\n<ul>\n<li>일반적으로 RDB의 경우에는 용량 초과시 <strong>수직적 확장</strong>(크고 비싼 서버)가 필요하지만, NoSQL의 경우는 수평적 확장이 가능합니다. (제한은 존재함)</li>\n</ul>\n</li>\n<li>\n<p>빠른 쿼리</p>\n<ul>\n<li>일반적으로 RDB의 경우, 여러 테이블을 Join해서 쿼리를 사용하지만, NoSQL의 경우는 쿼리에 최적화되어 저장합니다.</li>\n</ul>\n</li>\n<li>\n<p>개발자에 친화적</p>\n<ul>\n<li>NoSQL은 데이터 구조를 일반적인 프로그래밍 언어의 데이터 구조에 매핑합니다.</li>\n<li>적은 코드를 작성하면서, 개발 시간을 단축하고 버그를 줄일 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"nosql의-단점\"><a href=\"#nosql%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NoSQL의 단점</h3>\n<p>NoSQL에서 이야기되는 가장 큰 단점으로는 ACID 트랜잭션을 지원하지 않는 것입니다. 물론 적절한 스키마 디자인을 제공하면 단일 레코드의 원자화는 가능합니다.</p>\n<blockquote>\n<p>ACID</p>\n</blockquote>\n<ul>\n<li>A : atomicity, 원자성</li>\n<li>C : consistency, 일관성</li>\n<li>I : isolation, 고립성</li>\n<li>D : durability, 지속성</li>\n</ul>\n<br/>\n<h2 id=\"nosql-데이터베이스-별-특징\"><a href=\"#nosql-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%B3%84-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NoSQL 데이터베이스 별 특징</h2>\n<p>NoSQL 데이터베이스의 특성을 크게 다음과 같이 4가지로 나눌 수 있습니다.</p>\n<ul>\n<li>Key-Value Database</li>\n<li>Document Database</li>\n<li>Column Family Database</li>\n<li>Graph Database</li>\n</ul>\n<h3 id=\"key-value-database\"><a href=\"#key-value-database\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Key-Value Database</h3>\n<p>Key와 Value로 이루어졌으며, <strong>저장과 조회</strong>이란 원칙에 가장 충실합니다.</p>\n<p>Key-Value Database는 다음의 특징을 가집니다.</p>\n<ul>\n<li>Key 값은 unique한 고유값으로 유지되어야합니다.</li>\n<li>테이블간 join을 고려하지 않으므로 RDB의 외부키 등이 필요없습니다.</li>\n<li>Value에 모든 데이터 타입을 허용하며 이에 따라 검증 로직을 잘 구성하는 것이 중요합니다.</li>\n</ul>\n<p>Key-Value Database는 다음과 같은 종류들이 있습니다.</p>\n<ul>\n<li><strong>Redis</strong></li>\n<li><strong>AWS DynamoDB</strong></li>\n<li>Oracle Berkely</li>\n<li>Riak</li>\n</ul>\n<p>Key-Value Database는 일반적으로 아래의 경우에서 많이 사용합니다.</p>\n<ul>\n<li><strong>성능 향상을 위해 데이터베이스 데이터 캐싱</strong></li>\n<li>웰 어플리케이션에서 일시적인 속성 추적</li>\n<li>\n<p>모바일 애플리케이션용 사용자 데이터 정보와 구성 정보 저장</p>\n<ul>\n<li>다만 개인정보 등은 NoSQL에 저장하는 것은 지양해야함.</li>\n</ul>\n</li>\n<li>\n<p>이미지나 오디오 파일 같은 대용량 객체 저장</p>\n<ul>\n<li>일반적으로 NAS를 사용하기는 함.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"document-database\"><a href=\"#document-database\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Document Database</h3>\n<p>Key-Value Database와 마찬가지로 데이터 저장시에는 Key-Value Type을 사용하지만, 가장 큰 차이는 <strong>Document 타입으로 저장</strong>됩니다. (Ex. JSON, XML)</p>\n<p>Document Database는 다음의 특징을 가집니다.</p>\n<ul>\n<li>값을 문서(semi-structured entity)로 저장합니다. (일반적으로 JSON, XML)</li>\n<li>값을 저장하기 전에 schema를 별도로 정의하지 않으며, document가 schema가 됩니다.</li>\n<li>\n<p>각 문서별로 다른 필드를 가질 수 있기 때문에 개발자는 입력시 <strong>컬럼과 필드에 대한 관리</strong>를 제대로 해야합니다.</p>\n<ul>\n<li>필도 속성에 대한 관리가 필요합니다.</li>\n</ul>\n</li>\n</ul>\n<p>Document Database는 다음과 같은 종류가 있습니다.</p>\n<ul>\n<li><strong>MongoDB</strong></li>\n<li>CouchDB</li>\n<li>Couchbase</li>\n</ul>\n<p>Document Database는 일반적으로 아래의 경우에서 많이 사용합니다.</p>\n<ul>\n<li>대용량 데이터를 읽고 쓰는 웹사이트 백엔드 지원</li>\n<li>제품처럼 다양한 속성이 있는 데이터 관리</li>\n<li>다양한 유형의 메타데이터 추적</li>\n<li>Json 데이터 구조를 사용하는 어플리케이션</li>\n<li>비정규화된 중첩 구조의 데이터를 사용하는 애플리케이션</li>\n</ul>\n<blockquote>\n<p>CouchDB와 Couchbase의 차이.</p>\n</blockquote>\n<ul>\n<li>Couchbase는 JSON용 SQL과 같은 쿼리 언어 N1QL이 있으나, CouchDB는 없습니다.</li>\n<li>Couchbase는 기업용이 있으나, CouchDB는 오픈소스만 있습니다.</li>\n<li>Couchbase는 pessimistic lock이 있으나, CouchDB는 MVCC 개념을 사용하므로 없습니다.</li>\n<li>Couchbase의 topology는 분산되어 있으나, CouchDB는 master-master 복제 개념입니다.</li>\n</ul>\n<h3 id=\"column-family-database\"><a href=\"#column-family-database\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Column Family Database</h3>\n<p>Column Family Database는 대용량 데이터, 읽기와 쓰기 성능, 고가용성을 위해 설계되었습니다. (Ex. 구글의 Big Table, 페이스북의 Cassandra)</p>\n<p>Column Family Database는 다음의 특징을 가집니다.</p>\n<ul>\n<li>\n<p>RDB와 같이 Column과 Row를 사용해서 스키마를 정의합니다.</p>\n<ul>\n<li>컬럼 수가 많으면 관련된 컬럼들을 컬렉션으로 묶을 수 있습니다. (이를 <strong>Column Family</strong>라고 합니다.)</li>\n</ul>\n</li>\n<li>Document Database와 같이 미리 정의된 스키마를 사용하지 않으므로 원하는 시점에 컬럼을 추가가능합니다.</li>\n<li>테이블간 조인을 지원하지 않습니다.</li>\n</ul>\n<p>즉, 다음과 같은 모습으로 구성되어 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/113298137-76779e80-9336-11eb-9ed1-cb287417ad04.png\" alt=\"Hbase Column Families\"></p>\n<p>Column Family Database는 다음과 같은 종류가 있습니다.</p>\n<ul>\n<li><strong>Hbase</strong></li>\n<li><strong>Cassandra</strong></li>\n<li>GCP(Google Cloud Platform) BigTable</li>\n<li>MS Azure Cosmos DB</li>\n</ul>\n<p>Column Family Database는 일반적으로 아래의 경우에서 많이 사용합니다.</p>\n<ul>\n<li>데이터베이스에 쓰기 작업이 많은 애플리케이션</li>\n<li>지리적으로 여러 데이터 센터에 분산되어 있는 애플리케이션</li>\n<li>복제본 데이터가 단기적으로 불일치해도 큰 문제가 없는 애플리케이션</li>\n<li>동적 필드를 처리하는 애플리케이션</li>\n<li>수백만 테라바이트 정도의 대용량 데이터를 처리할 수 있는 애플리케이션</li>\n</ul>\n<p>다음은 Column Family Database의 성능 표입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/113298465-d40beb00-9336-11eb-8c64-8752cb98d1eb.png\" alt=\"Column Family Database Trend Chart\"></p>\n<p>일반적으로 Hbase와 Cassandra가 많이 쓰입니다. 다만, Hbase는 성능이 높으나 시스켐 복잡도와 Learning Curve의 문제로 인해 Cassandra가 더 보편적으로 선호됩니다.</p>\n<h3 id=\"graph-database\"><a href=\"#graph-database\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Graph Database</h3>\n<p>Graph Database는 Graph 이론을 활용한 것이며, Node(노드)들과 Relationship(관계)로 구성된 개념입니다. 노드는 Key-Value 값을 가지고 있고 노드는 하나 이상의 레이블을 구성할 수 있습니다.</p>\n<p>Graph Database는 다음의 특징을 가집니다.</p>\n<ul>\n<li>간단하고 직관적인 데이터 모델을 가집니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/113299571-fb16ec80-9337-11eb-9b17-b42ce16c51d0.png\" alt=\"image\"></p>\n<p>Graph Database는 다음과 같은 종류가 있습니다.</p>\n<ul>\n<li><strong>Neo4j</strong></li>\n<li>Titan</li>\n<li>AllegroGraph</li>\n</ul>\n<p>Graph Database는 일반적으로 아래의 경우에서 많이 사용합니다.</p>\n<ul>\n<li>지식 그래프나 소셜 그래프</li>\n<li>자격 증명 그래프</li>\n<li>사기 탐지 및 추천 엔진</li>\n<li>생명 과학 분야</li>\n</ul>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jaemunbro.medium.com/nosql-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B9%EC%84%B1-%EB%B9%84%EA%B5%90-c9abe1b2838c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL 데이터베이스별 특징</a></li>\n<li><a href=\"https://velog.io/@hanblueblue/%EB%B2%88%EC%97%AD-NoSQL-vs-Relational-Databases\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL vs Relational Database</a></li>\n<li><a href=\"https://velog.io/@hanblueblue/%EB%B2%88%EC%97%AD-NoSQL-vs-Relational-Databases\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DB, RDBMS VS NoSQL</a></li>\n<li><a href=\"https://blogs.perficient.com/2017/07/18/to-know-more-about-nosql-counchdb-vs-couchbase/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Couchbase VS CouchDB</a></li>\n<li><a href=\"https://couplewith.tistory.com/entry/Graph-DB-%EC%99%80-RDBMS-%ED%8A%B8%EB%9E%9C%EB%93%9C-3%EB%B6%80-%EA%B7%B8%EB%9E%98%ED%94%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%A2%85%EB%A5%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GraphDB</a></li>\n</ul>\n"}},{"node":{"title":"[Database] CAP 정리","path":"/00-db-cap/","date":"9. February 2021","timeToRead":4,"description":"CAP 이론에 대해 정리합니다.","content":"<h1 id=\"cap-정리\"><a href=\"#cap-%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CAP 정리</h1>\n<p>DB에 대해 공부하다 보면, CAP 이론에 대해 듣게 됩니다. 비록 이야기가 조금 있기는 하지만 그래도 CAP에 대해 개념을 정리합니다.</p>\n<br/>\n<h2 id=\"cap-란\"><a href=\"#cap-%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CAP 란.</h2>\n<p>CAP이론(Brewer's theorem)은 Network로 연결된 분산된 데이터베이스 시스템은 일관성(Consistency), 가용성(Availability), 분할 내구성(Partition Tolerance)의 3가지 특성 중 2가지 특성만을 충족할 수 있고 3가지를 모두 충족할 수는 없다는 이론입니다.</p>\n<h3 id=\"c일관성-consistency\"><a href=\"#c%EC%9D%BC%EA%B4%80%EC%84%B1-consistency\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>C(<strong>일관성</strong>, Consistency)</h3>\n<ul>\n<li>일관성을 가진다는 것은 모든 데이터를 요청할 때 응답으로 가장 최신의 변경된 데이터를 리턴 또는 실패를 리턴합니다.</li>\n<li>모든 읽기에 대해서 DB노드가 항상 동일한 데이터를 가지고 있어야한다는 의미입니다.</li>\n</ul>\n<h3 id=\"a가용성-availability\"><a href=\"#a%EA%B0%80%EC%9A%A9%EC%84%B1-availability\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>A(<strong>가용성</strong>, Availability)</h3>\n<ul>\n<li>가용성은 모든 요청에 대해서 정상적인 응답을 합니다.</li>\n<li>클러스터의 노드 일부에서 장애가 발생해도 READ나 WRITE 등의 동작은 항상 성공적으로 리턴되어야합니다.</li>\n</ul>\n<h3 id=\"p분할내성-partition-tolerance\"><a href=\"#p%EB%B6%84%ED%95%A0%EB%82%B4%EC%84%B1-partition-tolerance\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>P(<strong>분할내성</strong>, Partition tolerance)</h3>\n<ul>\n<li>메시지 전달이 실패하는 시스템 일부가 망가져도 시스템이 계속 동작할 수 있습니다.</li>\n<li>분할 내구성이란 Node간의 통신 장애가 발생하더라도 동작해야합니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107368608-19285380-6b24-11eb-95b2-846fea107c43.png\" alt=\"image\"></p>\n<p>다만, 현재의 DB와는 문제가 있다는 이야기는 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107371626-d1a3c680-6b27-11eb-9d32-1edebb653aed.png\" alt=\"image\"></p>\n<br/>\n<h2 id=\"일반적으로\"><a href=\"#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9C%BC%EB%A1%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>일반적으로</h2>\n<h3 id=\"cpconsistency--partition-tolerance\"><a href=\"#cpconsistency--partition-tolerance\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CP(Consistency &#x26; Partition Tolerance)</h3>\n<ul>\n<li>어떤 상황에서도 안정적으로 시스템은 운영되지만 Consistency가 보장되지 않는다면 Error를 반환합니다.</li>\n<li><strong>매 순간 Read / Write 에 따른 정합성이 일치할 필요가 있는 경우 적합한 형태입니다.</strong></li>\n</ul>\n<h3 id=\"apavailability--partition-tolerance\"><a href=\"#apavailability--partition-tolerance\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>AP(Availability &#x26; Partition Tolerance)</h3>\n<ul>\n<li>어떤 상황에서도 안정적으로 시스템은 운영됩니다.</li>\n<li>데이터와 상관없이 안정적인 응답을 받을 수 있습니다.</li>\n<li>다만 데이터의 정합성에 대한 보장은 불가능합니다.</li>\n<li><strong>결과적으로 일관성이 보장되는 Eventual Consistency를 보장할 수 있는 시스템에 알맞는 형태입니다.</strong></li>\n</ul>\n<h3 id=\"대부분은\"><a href=\"#%EB%8C%80%EB%B6%80%EB%B6%84%EC%9D%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>대부분은...</h3>\n<ul>\n<li>사실 대부분 CP, AP 시스템은 없고 대부분 CP와 AP의 어느 중간 쯤에 존재합니다.</li>\n<li>예제에 봤듯이 configuration에 따라 변하기도 하고, 이론 자체에서 한계점도 존재합니다.</li>\n<li>가장 큰 문제는 P에 대한 명확한 정의가 부족합니다.</li>\n<li>기존의 문제를 해결하기 위해 PACELC 이론이 등장하였습니다.</li>\n</ul>\n<br/>\n<h2 id=\"pacelc-이론\"><a href=\"#pacelc-%EC%9D%B4%EB%A1%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PACELC 이론</h2>\n<p>다음과 같은 요소로 표현됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107372209-7faf7080-6b28-11eb-897d-461cc4b64a86.png\" alt=\"pacelc\"></p>\n<h3 id=\"pacelc-구성\"><a href=\"#pacelc-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PACELC 구성</h3>\n<p>PACELC는 크게 4가지로 구성됩니다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>구성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Partition</td>\n<td>Availability</td>\n<td>가용성</td>\n</tr>\n<tr>\n<td></td>\n<td>Consistency</td>\n<td>일관성</td>\n</tr>\n<tr>\n<td>Else</td>\n<td>Latency</td>\n<td>시간 지연</td>\n</tr>\n<tr>\n<td></td>\n<td>Consistency</td>\n<td>일관성</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"pacelc-대입\"><a href=\"#pacelc-%EB%8C%80%EC%9E%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PACELC 대입</h3>\n<p>이를 기존의 DB에 대입시키면 다음과 같이 볼 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107372699-0bc19800-6b29-11eb-96f0-957e59da40b8.png\" alt=\"pacelc-db\"></p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>CAP 이론과 PACELC 이론에 대한 개념을 잡았습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jins-dev.tistory.com/entry/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%98%EA%B2%BD-Distributed-System-%EC%97%90%EC%84%9C-BASE-%EC%9B%90%EC%B9%99%EA%B3%BC-CAP-%EC%A0%95%EB%A6%AC\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://jins-dev.tistory.com/entry/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%98%EA%B2%BD-Distributed-System-%EC%97%90%EC%84%9C-BASE-%EC%9B%90%EC%B9%99%EA%B3%BC-CAP-%EC%A0%95%EB%A6%AC</a></li>\n<li><a href=\"https://sabarada.tistory.com/91\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://sabarada.tistory.com/91</a></li>\n<li><a href=\"https://m.blog.naver.com/PostView.nhn?blogId=windfalcon1&#x26;logNo=220402574806&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.blog.naver.com/PostView.nhn?blogId=windfalcon1&#x26;logNo=220402574806&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F</a></li>\n</ul>\n"}}]}}},"context":{}}