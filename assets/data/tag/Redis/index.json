{"hash":"4d08d5d9909bc52ba8ae53ab8b5e8ea790bc2d53","data":{"tag":{"title":"Redis","belongsTo":{"edges":[{"node":{"title":"[DB] Couchbase의 개념과 특징, 아키텍처","path":"/02-db-nosql-couchbase/","date":"20. September 2021","timeToRead":4,"description":"Nosql 중 Couchbase에 대해 좀 더 자세하게 알아봅니다.","content":"<h1 id=\"couchbase를-좀-더-자세하게\"><a href=\"#couchbase%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase를 좀 더 자세하게</h1>\n<p>지난 게시글은 다음과 같습니다.</p>\n<ul>\n<li><a href=\"https://azderica.github.io/00-db-nosql/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL</a></li>\n<li><a href=\"https://azderica.github.io/01-db-nosql-redis/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis</a></li>\n</ul>\n<p>오늘은 Couchbase 개념입니다.</p>\n<h2 id=\"couchbase-개념\"><a href=\"#couchbase-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase 개념</h2>\n<ul>\n<li>카우치 베이스는 Document 기반의 Key-Value 스토어입니다.</li>\n<li>하나의 유니크(Unique)한 키에 값을 저장하는 방식이며, 저장되는 값은 JSON 도큐먼트가 저장됩니다.</li>\n<li>키(key)는 최대 <strong>250 바이트</strong>, 밸류(Value)는 카우치베이스 버킷은 20BMB, Memcached 방식의 버킷의 경우 1MB까지 저장이 됩니다.</li>\n</ul>\n<p>저장할 때, 키와 값 뿐만 아니라 메타데이터도 같이 저장되며 메타 데이터는 <code class=\"language-text\">CAS, TTL, Flag</code> 값 3가지가 저장됩니다.</p>\n<ul>\n<li><code class=\"language-text\">CAS</code> : 데이터에 대한 일종의 타임 스탬프와 같은 개념으로, 여러 클라이언트가 같이 데이터를 접근했을 때 일관성(Consistent) 문제를 해결해줍니다.</li>\n<li><code class=\"language-text\">TTL</code> : <code class=\"language-text\">Time To Live</code>, 데이터의 유효 시간을 정의합니다.</li>\n<li><code class=\"language-text\">FLAG</code> : 카우치베이스 클라이언트에서 사용하는 메타데이터입니다.</li>\n</ul>\n<p>이러한 메타데이터는 하나의 메타데이터(CAS, TTL, Flag)는 60바이트의 메모리를 차지하며, 카우치베이스 서버는 모든 키와 메타데이터를 유지하기 위해 용량을 설계할때, RAM의 사이즈를 결정합니다.</p>\n<h3 id=\"버킷bucket\"><a href=\"#%EB%B2%84%ED%82%B7bucket\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>버킷(Bucket)</h3>\n<h3 id=\"뷰view\"><a href=\"#%EB%B7%B0view\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>뷰(View)</h3>\n<br/>\n<h2 id=\"couchbase-특징\"><a href=\"#couchbase-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase 특징</h2>\n<h3 id=\"memcached-기반의-level-2-캐쉬를-내장하여-빠릅니다\"><a href=\"#memcached-%EA%B8%B0%EB%B0%98%EC%9D%98-level-2-%EC%BA%90%EC%89%AC%EB%A5%BC-%EB%82%B4%EC%9E%A5%ED%95%98%EC%97%AC-%EB%B9%A0%EB%A6%85%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Memcached 기반의 Level 2 캐쉬를 내장하여 빠릅니다.</h3>\n<ul>\n<li>memcached를 자체적으로 Level 2 캐쉬로 사용합니다.</li>\n<li>자체적으로 메모리 캐쉬 기능을 가지고 있기 때문에 성능이 빠릅니다.</li>\n</ul>\n<p>(다만, 키의 유연성이나 클러스터에서 단점을 가집니다.)</p>\n<h3 id=\"모바일-디바이스와-sync\"><a href=\"#%EB%AA%A8%EB%B0%94%EC%9D%BC-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4%EC%99%80-sync\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>모바일 디바이스와 Sync</h3>\n<ul>\n<li>카우치디비 계열 DB들은 모바일 디바이스에 탑재할 수 있으며, 서버에 설치된 카우치베이스 계열과 Sync가 됩니다.</li>\n</ul>\n<h3 id=\"데이터-센터간-복제-기간\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%84%BC%ED%84%B0%EA%B0%84-%EB%B3%B5%EC%A0%9C-%EA%B8%B0%EA%B0%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>데이터 센터간 복제 기간</h3>\n<ul>\n<li>XDCR(Cross Data Center Replication)의 기능을 이용해서 물리적으로 떨어진 데이터 센터간에 복제가 가능합니다.</li>\n<li><a href=\"https://azderica.github.io/00-db-couchbase-xdcr/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">XDCR의 상세 내용</a></li>\n</ul>\n<h3 id=\"indexing-grouping-ordering-join-가능\"><a href=\"#indexing-grouping-ordering-join-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Indexing, Grouping, Ordering, Join 가능</h3>\n<ul>\n<li>대부분의 NoSQL은 Key/Value Store 형식으로, 개별 필드에 대한 Indexing이나 필드별로 group by를 통한 sum,count 등의 기능, 특정 필드별로의 Sorting이 불가능합니다.</li>\n<li>Indexing을 지원하는 경우도 있기는 하지만, 내부적으로 성능상 문제가 있는 경우가 많으나 카우치베이스는 그러한 문제가 없습니다.</li>\n</ul>\n<h3 id=\"확장이-쉬움\"><a href=\"#%ED%99%95%EC%9E%A5%EC%9D%B4-%EC%89%AC%EC%9B%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>확장이 쉬움</h3>\n<ul>\n<li>분산 구조의 NoSQL의 경우 노드확장이 어렵거나 장애처리가 어려운 경우가 많으나 카우치베이스는 손쉽게 확장을 하고 장애 처리를 합니다.</li>\n<li>이러한 장점은 운영에서 큰 이점이 됩니다.</li>\n</ul>\n<h3 id=\"built-in-관리-도구-제공\"><a href=\"#built-in-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC-%EC%A0%9C%EA%B3%B5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Built in 관리 도구 제공</h3>\n<ul>\n<li>카우치베이스는 웹 기반의 GUI 관리 도구를 기본으로 제공합니다.</li>\n</ul>\n<h3 id=\"memcached-프로토콜-지원\"><a href=\"#memcached-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Memcached 프로토콜 지원</h3>\n<ul>\n<li>캐쉬 솔루션으로 유명한 Memcached 르포토콜을 지원하기 때문에 Memcached 인프라를 사용할 수 있습니다.</li>\n</ul>\n<h3 id=\"스키마가-없는-유연한-저장-구조scheme-less\"><a href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88%EA%B0%80-%EC%97%86%EB%8A%94-%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%A0%80%EC%9E%A5-%EA%B5%AC%EC%A1%B0scheme-less\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>스키마가 없는 유연한 저장 구조(Scheme-less)</h3>\n<ul>\n<li>스키마가 없으므로 하나의 테이블에 컬럼 형식이 다른 데이터를 넣을 수 있습니다.</li>\n<li>하나의 데이터 버켐ㅅ에 데이타 구조가 다른 JSON 문서들을 넣을 수 있습니다.</li>\n<li>데이터 타입이 다름에도 불구하고 공통되는 필드에 대해 Indexing, grouping 등을 제공할 수 있으며 JSON 도큐먼트에 country 라는 앨리먼트가 있는 도큐먼트등을 대상으로 grouping등을 할수 있습니다.</li>\n</ul>\n<br/>\n<h2 id=\"couchbase-architecture\"><a href=\"#couchbase-architecture\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase Architecture</h2>\n<br/>\n<h2 id=\"couchbase-cluster\"><a href=\"#couchbase-cluster\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase Cluster</h2>\n<br/>\n<h2 id=\"couchbase-vs-mongodb\"><a href=\"#couchbase-vs-mongodb\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase VS MongoDB</h2>\n<hr>\n<ul>\n<li><a href=\"https://bcho.tistory.com/924\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase 소개</a></li>\n<li><a href=\"https://bcho.tistory.com/925\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase 개념</a></li>\n<li><a href=\"https://bcho.tistory.com/928\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase view</a></li>\n<li><a href=\"https://bcho.tistory.com/934\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase architecture</a></li>\n<li><a href=\"https://docs.couchbase.com/server/5.0/architecture/architecture-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase architecture detail</a></li>\n<li><a href=\"https://docs.couchbase.com/server/current/learn/clusters-and-availability/clusters-and-availability.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase cluster</a></li>\n<li><a href=\"https://dzone.com/articles/introduction-to-couchbase-for-mongodb-developers-a-1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase vs mongodb</a></li>\n<li><a href=\"https://zepinos.tistory.com/60?category=797689\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">왜 Couchbase을 선택하게 되었는가 - 1</a></li>\n<li><a href=\"https://zepinos.tistory.com/61\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">왜 Couchbase을 선택하게 되었는가 - 2</a></li>\n</ul>\n"}},{"node":{"title":"[DB] Redis의 개념과 특징, 아키텍처","path":"/01-db-nosql-redis/","date":"17. September 2021","timeToRead":9,"description":"Nosql 중 Redis에 대해 좀 더 자세하게 알아봅니다.","content":"<h1 id=\"redis를-좀-더-자세하게\"><a href=\"#redis%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis를 좀 더 자세하게.</h1>\n<p>지난번 게시글에서는 <a href=\"https://azderica.github.io/00-db-nosql/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL</a>에 대한 기본 개념과 종류에 대해서 정리했습니다.</p>\n<p>이번에는 더 나아가서 대표적인 NoSQL이 가지는 아키텍처를 정리합니다. 오늘은 Redis에 대해 좀 더 정리하려고합니다.</p>\n<h2 id=\"redis란\"><a href=\"#redis%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis란.</h2>\n<ul>\n<li>고 성능의 키-값 데이터 구조 스토어입니다.</li>\n<li>여러 자료구조를 지원하며 크게 <code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 등의 데이터 형식을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis-특징\"><a href=\"#redis-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 특징</h2>\n<ul>\n<li>\n<p>영속성을 지원하는 인메모리 데이터 저장소</p>\n<ul>\n<li>왜 영속성을 제공하는지는 아래에서 설명합니다.</li>\n</ul>\n</li>\n<li>\n<p>읽기 성능 증대를 위한 서버 측 복제를 지원합니다.</p>\n<ul>\n<li>전체 데이터베이스의 초기 복사본을 받는 마스터/슬레이브 복제를 지원합니다.</li>\n<li>마스터에서 쓰기가 수행되면 슬레이브 데이터 세트를 실시간으로 업데이터하기 위해 연결된 모든 슬레이브로 전송됩니다.</li>\n</ul>\n</li>\n<li>쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding)을 지원합니다.</li>\n<li><code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 과 같은 다양한 데이터형을 지원합니다.</li>\n</ul>\n<blockquote>\n<p>샤딩(Sharding)</p>\n</blockquote>\n<p>파티셔닝과 동일하며, 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미합니다.</p>\n<br/>\n<h2 id=\"redis-특징-1\"><a href=\"#redis-%ED%8A%B9%EC%A7%95-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 특징</h2>\n<h3 id=\"key-value-store\"><a href=\"#key-value-store\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Key-Value Store</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133774329-00ddf3c0-a24e-40b0-9dd8-460616ea5400.png\" alt=\"Redis-is-map\"></p>\n<ul>\n<li>Redis는 거대한 맵(Map) 데이터 저장소입니다.</li>\n<li>Redis는 익히기 쉬우며 직관적입니다. 그러나, 데이터를 레디스 자체 내에서는 처리하기 어렵습니다.</li>\n</ul>\n<h3 id=\"다양한-데이터-타입\"><a href=\"#%EB%8B%A4%EC%96%91%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>다양한 데이터 타입</h3>\n<ul>\n<li><code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 등의 타입을 지원합니다.</li>\n</ul>\n<h3 id=\"persistence\"><a href=\"#persistence\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Persistence</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133775761-c7644499-ae6f-4aa8-bd25-8208780c41e0.png\" alt=\"Redis-Persistence\"></p>\n<ul>\n<li>Redis는 영속성을 가집니다.</li>\n<li>Redis는 데이터를 disk에 저장할 수 있습니다. 따라서 Redis는 서버가 강제 종료되고 재시작하더라도 disk에 저장해놓은 데이터를 다시 읽어서 데이터가 유실되지 않습니다.</li>\n<li>\n<p>redis의 데이터를 disk에 저장하는 방식은 <strong>snapshot, AOF</strong> 방식이 있습니다.</p>\n<ul>\n<li><code class=\"language-text\">Snapshot</code> : RDB와 비슷하게 어떤 특정 시점의 데이터를 Disk에 담는 방식을 뜻합니다. <strong>Blocking</strong> 방식의 <strong>SAVE</strong>와 <strong>Non-blocking</strong> 방식의 <strong><a href=\"http://redisgate.kr/redis/server/bgsave.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">BGSAVE</a></strong> 방식이 있습니다.</li>\n<li><code class=\"language-text\">AOF</code> : Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태입니다. 서버가 재시작 시 write/update를 순차적으로 재실행하고 데이터를 복구합니다.</li>\n<li>가장 좋은 방식은 두 방법을 혼용해서 사용하는 방법으로 주기적으로 snapshot으로 백업을 하고 다음 snapshot까지의 저장을 AOF 방식으로 수행하는 방식입니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ansi-c로-작성\"><a href=\"#ansi-c%EB%A1%9C-%EC%9E%91%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ANSI C로 작성</h3>\n<ul>\n<li>C언어로 작성되어 Java와 같이 가상머신 위에서 동작하는 언어에서 발생하는 성능 문제에서 자유롭습니다.</li>\n</ul>\n<h3 id=\"서버측-복제-및-샤딩-지원\"><a href=\"#%EC%84%9C%EB%B2%84%EC%B8%A1-%EB%B3%B5%EC%A0%9C-%EB%B0%8F-%EC%83%A4%EB%94%A9-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서버측 복제 및 샤딩 지원</h3>\n<ul>\n<li>읽기 성능 증대를 위해 서버 측 복제를 지원합니다.</li>\n<li>쓰기 성능 증대를 위해 클라이언트 측 샤딩을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis의-장점\"><a href=\"#redis%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis의 장점</h2>\n<ul>\n<li>리스트, 배열과 같은 데이터를 처리하는데 유용합니다.</li>\n<li>Message Queue, Shared Memory, Remote Dictionary(RDBMS의 캐시 솔루션 / read 속도가 매우 빠릅니다.) 용도로 사용됩니다.</li>\n<li>메모리를 활용하면서 데이터를 보존합니다.</li>\n<li>Redis Server는 1개의 싱글 쓰레드로 수행되며, 서버 하나에 여러개의 서버를 띄우는 것이 가능합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis-아키텍처-구성\"><a href=\"#redis-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 아키텍처, 구성</h2>\n<ul>\n<li>HA(High Availability) : 무중단 서비스 등</li>\n</ul>\n<h3 id=\"standalone--no-ha-마스터\"><a href=\"#standalone--no-ha-%EB%A7%88%EC%8A%A4%ED%84%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Standalone : No HA, 마스터</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133778042-cf59f712-752a-4c61-8a1a-b9ac435726a1.png\" alt=\"Redis-Standalone\"></p>\n<ul>\n<li>레디스 서버 1대로 구성하며 이를 마스터 노드라고 합니다.</li>\n<li>서버 다운시 AOF 또는 Snapshot 파일을 이용해 재 시작합니다.</li>\n</ul>\n<h3 id=\"replication--half-ha-마스터-슬레이브\"><a href=\"#replication--half-ha-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%AC%EB%A0%88%EC%9D%B4%EB%B8%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Replication : Half HA, 마스터-슬레이브</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133778753-41bfa929-aa5f-48e5-9509-7e4df1379baa.png\" alt=\"Redis-Replication\"></p>\n<ul>\n<li>레디스 서버 2대(마스터-슬레이브)로 구성됩니다. 슬레이브는 마스터의 데이터를 실시간으로 전달받아 보관합니다.</li>\n<li>마스터 다운 시 슬레이브 서버를 통해 서비스를 계속할 수 있습니다. 하지만, 이때는 수동으로 슬레이브 서버를 마스터로 변경해야합니다.</li>\n<li>한 마스터에 슬레이브를 여러 대 구성할 수 도 있습니다.</li>\n</ul>\n<h3 id=\"이중화--센티널sentinel--ha-무중단-서비스-가능\"><a href=\"#%EC%9D%B4%EC%A4%91%ED%99%94--%EC%84%BC%ED%8B%B0%EB%84%90sentinel--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>이중화 + 센티널(Sentinel) : HA, 무중단 서비스 가능</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133779960-5c97207f-75d7-405c-a4ea-730bba593e2d.png\" alt=\"image\"></p>\n<ul>\n<li>마스터-슬레이브 구성에 <strong>센티널</strong>을 추가해서 각 서버를 감시하도록하며, 센티널은 마스터 서버를 감시하고 있다가 다운되면 슬레이브를 마스터로 승격시킵니다.</li>\n<li>다운된 마스터가 다시 시작되면 센티널이 슬레이브로 전환시킵니다.</li>\n<li>레디스 마스터 노드가 모든 데이터를 가지고 있으며 슬레이브는 마스터에 대한 복제본을 유지하고 있으며, 데이터를 분산하지 않습니다.</li>\n<li>일반적으로 레디스 센티널은 레디스 서버마다 하나씩 설치하며, 레디스 서버와 분리된 프로세스이며 다른 포트를 사용합니다. (데이터를 처리하지 않습니다.)</li>\n<li>레디스 센티널은 높은 가용성과 자동 fail over 을 해결하지만 <strong>데이터 분산 문제를 해결하지 못합니다.</strong></li>\n</ul>\n<p><a href=\"https://hub.docker.com/r/erichsu/redis-sentinel/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Sentinel Docker</a></p>\n<h3 id=\"레디스-클러스터cluster--ha-무중단-서비스-가능\"><a href=\"#%EB%A0%88%EB%94%94%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0cluster--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>레디스 클러스터(Cluster) : HA, 무중단 서비스 가능</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133781464-16c21b85-1ca2-4e0f-8028-5acf9a37a2f8.png\" alt=\"Redis-Cluster-Type-1\"></p>\n<p>머신 하나가 죽었을 시 해결이 됩니다. 다만 두개가 죽으면 해결이 안됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133782017-fe094509-ed9a-419c-9739-35a766b4e334.png\" alt=\"Redis-Cluster-Type-2\"></p>\n<p>위의 문제를 해결하는 방법입니다.</p>\n<ul>\n<li>\n<p><strong>샤딩</strong></p>\n<ul>\n<li>클라스터는 <strong>샤딩</strong>(sharding, 대량의 데이터를 처리하기 위해 여러 개의 데이터베이스에 분할하는 기술) 방법을 제공하는 방법입니다.</li>\n<li>100개의 데이터를 1번 마스터에 33개, 2번 마스터 33개, 3번 마스터에 나머지 34개가 저장되는 방식입니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>Hash 함수</strong></p>\n<ul>\n<li>데이터를 나누는 방식은 키에 hash 함수를 적용해서 값을 추출하고, 이 값을 각 마스터 서버에 할당합니다.</li>\n<li>클러스터 구성시 해쉬 함수를 통해서 1~33까지를 1번 서버, 34~ 66번까지를 2번 서버, 3번 서버는 또 다르게 할당됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>해시 슬록(16384 슬롯)</strong></p>\n<ul>\n<li>레디스에서 hash 값의 개수는 16384(0~16383)이고 슬롯(slot)이라고 합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>해시 태그</strong></p>\n<ul>\n<li>다중 키 작업을 진행하려면 동일 노드에 저장될 모든 키가 필요합니다. 해시 태그는 레디스 클러스터에서 다중키를 사용할 수 있는 유일한 방법입니다.</li>\n<li>해시 함수를 적용해 동일한 해시 슬롯에 여러 개의 키 이름을 저장할 수 있도록 사용됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>레디스 클라이언트</strong></p>\n<ul>\n<li>클라이언트는 서버와 동일한 hash 함수를 가지고 있으며 마스터 서버에 접속해서 각 서버에 할당된 슬롯 정보를 가지고 있습니다.</li>\n<li>키가 입력되면 hash 함수를 적용해서 어느 마스터에 저장할지 판단해서 해당 마스터에 저장합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>데이터 서버 + 센티널</strong></p>\n<ul>\n<li>각 마스터 서버는 데이터의 처리와 센티널의 역할을 같이수행합니다.</li>\n<li>1번 마스터 서버가 다운되면 나머지 살아있는 마스터들 중에서 리더를 선출해서 리더가 1번 마스터의 슬레이브를 마스터로 승격시킵니다.</li>\n</ul>\n</li>\n<li>\n<p>최소 3대</p>\n<ul>\n<li>마스터 서버는 최소 3대로 구성하고 각각은 슬레이브를 가질 수 있습니다.</li>\n</ul>\n</li>\n<li>마스터를 관리하는 마스터는 없습니다. 이는 또 하나의 장애점입니다.</li>\n<li>레디스가 사용하는 포트는 2개이며 하나는 클라이언트 하나는 노드 간의 통신을 위한 버스로 사용됩니다.</li>\n</ul>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jyejye9201.medium.com/%EB%A0%88%EB%94%94%EC%8A%A4-redis-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-2b7af75fa818\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis란 무엇인가</a></li>\n<li><a href=\"https://docs.redis.com/latest/rs/concepts/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Concept</a></li>\n<li><a href=\"http://redisgate.kr/redis/configuration/redis_overview.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Architecture Overview</a></li>\n<li><a href=\"https://cla9.tistory.com/101\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis 구조</a></li>\n<li><a href=\"https://engkimbs.tistory.com/869\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">레디스 소개 및 아키텍처, 주의할 점</a></li>\n<li><a href=\"https://coding-start.tistory.com/128\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis - Cluster &#x26; Sentinel</a></li>\n<li><a href=\"https://redis.io/commands\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Command</a></li>\n<li><a href=\"https://redis.com/redis-enterprise/technology/redis-enterprise-cluster-architecture/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Enterprise Cluster Architecture</a></li>\n</ul>\n"}},{"node":{"title":"[SpringBoot Redis] Redis에 커스텀 객체 저장 시 오류","path":"/00-redis-troubleshooting/","date":"4. June 2021","timeToRead":3,"description":"Redis에 커스텀 데이터 객체 저장시 발생하는 오류와 그에 따른 해결책","content":"<h1 id=\"redis-hashvalue-에-커스텀-객체-저장-시-오류-발생점\"><a href=\"#redis-hashvalue-%EC%97%90-%EC%BB%A4%EC%8A%A4%ED%85%80-%EA%B0%9D%EC%B2%B4-%EC%A0%80%EC%9E%A5-%EC%8B%9C-%EC%98%A4%EB%A5%98-%EB%B0%9C%EC%83%9D%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis HashValue 에 커스텀 객체 저장 시 오류 발생점.</h1>\n<p>스프링으로 개발을 진행하던 중, Redis HashValue에 커스텀 데이터 객체를 저장할 때 발생하는 문제가 발생했다. 이에 대한 해결과정을 정리했습니다.</p>\n<h2 id=\"원인\"><a href=\"#%EC%9B%90%EC%9D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>원인.</h2>\n<p>에러 메세지는 다음과 같다.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to <span class=\"token punctuation\">..</span>.</code></pre>\n<p>일반적으로 spring 프로젝트에서 redis에 데이터를 저장하는 방법으로는 redisTemplate를 상속받아서 쓰는데, 코드는 다음과 같습니다. (생략해서 변경했습니다.)</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RequiredArgsConstructor</span>\n<span class=\"token annotation punctuation\">@ToString</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Data</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Integer</span> data1<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Long</span> data2<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> data3<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> redisKey <span class=\"token operator\">=</span> <span class=\"token string\">\"key:study\"</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> redisHashKey <span class=\"token operator\">=</span> <span class=\"token string\">\"unique:key\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> redisHashValue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Data</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1L</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token annotation punctuation\">@Autowired</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">RedisTemplate</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> redisTemplate\n\n  redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">opsForHash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>redisKey<span class=\"token punctuation\">,</span> redisHashKey<span class=\"token punctuation\">,</span> redisHashValue<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// 에러 발생 코드, 캐스팅 에러 발생</span>\n  <span class=\"token class-name\">Data</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Data</span><span class=\"token punctuation\">)</span> redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">opsForHash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>redisKey<span class=\"token punctuation\">,</span> redisHashKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>에러 발생으로 인해 생각하는 원인은 다음과 같습니다.</p>\n<p>Value로 저장되는 값이 이후에 데이터를 받아와서 캐스팅을 할때, 이를 객체로 보는 것이 아니라 <code class=\"language-text\">LinkedHashMap</code>으로 인식하는 것으로 보입니다.</p>\n<br/>\n<h2 id=\"생각한-해결책\"><a href=\"#%EC%83%9D%EA%B0%81%ED%95%9C-%ED%95%B4%EA%B2%B0%EC%B1%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>생각한 해결책.</h2>\n<ol>\n<li><code class=\"language-text\">JSONObject</code>을 통해서 데이터를 파싱해서 <code class=\"language-text\">Data</code> 객체에 넣어주는 방법</li>\n<li>RedisTemplate을 상속받아서 저장을 하는 방법</li>\n<li><code class=\"language-text\">ToString</code>을 오버라이딩해서, 특정 형태로 저장 이후 파싱해서 객체에 이후 넣어 주는 방법</li>\n<li><code class=\"language-text\">LinkedHashMap</code> 형태로 만들어줘서 넣고 사용하기</li>\n</ol>\n<p>이외에도 여러 방법이 있겠지만 저는 이중에서 1번과 4번을 선택했습니다. (1번 방법으로 해봤는데 똑같은 에러가 발생했습니다.)</p>\n<p>4번의 경우로 한 이유는 다음과 같습니다.</p>\n<ul>\n<li>이후에 데이터를 다시 돌리기 편하기 때문에</li>\n<li>기본적으로 공식적인 객체이기 때문에 없을 것으로 판단했기 때문에</li>\n<li>코드를 최대한 SRP(단일 책임) 형태로 구성했기 때문에 클래스 하나로만 변경하면 되기 때문에.</li>\n</ul>\n<br/>\n<h2 id=\"마무리-및-도움이-되는-정보\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC-%EB%B0%8F-%EB%8F%84%EC%9B%80%EC%9D%B4-%EB%90%98%EB%8A%94-%EC%A0%95%EB%B3%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리 및 도움이 되는 정보.</h2>\n<p>이외에도 다른 방법이 있겠지만 해당 방법에 대해 좋은 방법을 찾으면 좋을 것 같습니다. 아래는 관련해서 참고하면 좋은 글입니다.</p>\n<ul>\n<li><a href=\"https://deepweller.tistory.com/38\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RedisTemplate, serialization</a></li>\n<li><a href=\"https://stackoverflow.com/questions/38532754/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">stackoverflow, redis serializer</a></li>\n<li><a href=\"https://www.javatpoint.com/how-to-convert-string-to-json-object-in-java\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Convert String to JSON Object</a></li>\n<li><a href=\"https://stackoverflow.com/questions/22358872/how-to-convert-linkedhashmap-to-custom-java-object/22359030\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">stackoverflow, convert linkedHashMap to Custom java object</a></li>\n<li><a href=\"https://www.baeldung.com/jackson-linkedhashmap-cannot-be-cast\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Jackson, java.util.LinkedHashMap cannot be cast to X</a></li>\n</ul>\n"}}]}}},"context":{}}