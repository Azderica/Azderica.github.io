{"hash":"c252e7650a6691103be74bcadb51dd243a8d98c2","data":{"tag":{"title":"Cluster","belongsTo":{"edges":[{"node":{"title":"[DB] DB의 INDEX 개념정리","path":"/00-db-index/","date":"27. October 2021","timeToRead":7,"description":"DB의 INDEX에 대해 정리합니다.","content":"<h1 id=\"db-index-개념-정리\"><a href=\"#db-index-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>[DB] Index 개념 정리</h1>\n<h2 id=\"개념\"><a href=\"#%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>개념</h2>\n<ul>\n<li>일종의 책 뒤의 찾아보기나 책 앞의 목차의 개념으로 이해하면 됩니다.</li>\n<li>주로 쿼리의 성능을 높이기 위해 사용됩니다.</li>\n</ul>\n<br/>\n<h2 id=\"장단점\"><a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>장단점</h2>\n<h3 id=\"장점\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>장점</h3>\n<ul>\n<li>검색 속도 향상</li>\n<li>시스템의 부하를 줄여, 시스템 전체 성능향상에 기여가 가능합니다.</li>\n</ul>\n<h3 id=\"단점\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단점</h3>\n<ul>\n<li>인덱스를 위한 추가 공간이 필요합니다.</li>\n<li>생성에 시간이 소요 될 수 있습니다.</li>\n<li>생성, 수정, 삭제에 대한 성능이 하락할 수 있습니다.</li>\n</ul>\n<br/>\n<h2 id=\"인덱스가-필요한-경우\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EA%B2%BD%EC%9A%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>인덱스가 필요한 경우</h2>\n<h3 id=\"주의사항\"><a href=\"#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>주의사항</h3>\n<ul>\n<li>무분별한 인덱스는 용량을 차지하고, 옵티마이저의 최적화를 낮추는 결과를 얻게 됩니다.</li>\n<li>특정 컬림들을 조건으로 걸 때, 정렬된 인덱스의 순서와 맞지않는다면 추가적인 비용이 발생합니다.</li>\n</ul>\n<h3 id=\"인덱스가-필요없는-경우\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EA%B0%80-%ED%95%84%EC%9A%94%EC%97%86%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>인덱스가 필요없는 경우</h3>\n<ul>\n<li>데이터가 적은 경우(수천건 미만) 인 경우에는 인덱스가 없는 것이 성능이 좋습니다.</li>\n<li>조회보다 삽입, 수정, 삭제 처리가 많은 테이블인 경우</li>\n<li>조회결과가 전체행의 15% 이상 읽어들일 것으로 예상되는 경우</li>\n</ul>\n<h3 id=\"인덱스가-필요한-경우-1\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EA%B2%BD%EC%9A%B0-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>인덱스가 필요한 경우</h3>\n<ul>\n<li>데이터가 많이 쌓일거라고 예상되거나 많은 경우, 조회속도가 너무 느린 경우</li>\n<li>조회결과가 전체 데이터 수의 3~5% 이상쯤되면 인덱스 스캔이 효율적이고 적은 비용으로 찾을 수 있습니다.</li>\n<li>Access 대상 범위가 전체 범위의 3~5% 이상 쯤 되면 인덱스 스캔보다 풀 스캔이 훨씬 유리합니다.</li>\n</ul>\n<br/>\n<h2 id=\"종류\"><a href=\"#%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>종류</h2>\n<h3 id=\"clusted-index클러스터형-인덱스\"><a href=\"#clusted-index%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%ED%98%95-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Clusted Index(클러스터형 인덱스)</h3>\n<ul>\n<li>테이블당 한 개만 생성이 가능합니다.</li>\n<li>행 데이터를 인덱스로 지정한 열에 맞춰서 자동 정렬합니다.</li>\n<li>primary 키 설정 시 자동으로 생성되며 컬럼은 데이터 변경시, 항상 정렬을 유지합니다.</li>\n</ul>\n<blockquote>\n<p>주의 사항</p>\n</blockquote>\n<ul>\n<li>클러스터 인젝스 사용시 모든 보조 인덱스카 primary 키를 포함합니다.</li>\n<li>primary 키의 크기가 커질수록 보조 인덱스의 크기도 커집니다.</li>\n</ul>\n<h3 id=\"non-clustered-index비클러스터형-인덱스\"><a href=\"#non-clustered-index%EB%B9%84%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%ED%98%95-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Non-Clustered Index(비클러스터형 인덱스)</h3>\n<ul>\n<li>테이블당 여러 개를 생성할 수 있습니다.</li>\n<li>맨뒤의 찾아보기가 있는 일반 책과 같습니다.</li>\n<li>테이블의 페이지를 정렬하지 않고 새로운 공간을 할당하므로, 클러스터 인덱스보다 많은 공간을 차지합니다.</li>\n<li>데이터 행과 분리된 구조를 가집니다.</li>\n</ul>\n<h4 id=\"단일-인덱스\"><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단일 인덱스</h4>\n<ul>\n<li>데이터가 많지 않으며 조건에 걸리는 컬럼이 적은 경우에 주로 사용합니다.</li>\n</ul>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> IDX_SINGLE <span class=\"token punctuation\">(</span>C1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"복합-인덱스\"><a href=\"#%EB%B3%B5%ED%95%A9-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>복합 인덱스</h4>\n<ul>\n<li>테이블 데이터를 기준으로 새로운 인덱스 공간을 생성 및 데이터를 정렬하므로 공간 사용량이 증가합니다.</li>\n</ul>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> IDX_MULTI <span class=\"token punctuation\">(</span>C1<span class=\"token punctuation\">,</span> C2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"커버드-인덱스\"><a href=\"#%EC%BB%A4%EB%B2%84%EB%93%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>커버드 인덱스</h4>\n<ul>\n<li>커버드 쿼리라고도 합니다.</li>\n<li>퀴리가 인덱스 접근으로 인해 테이블 접근이 필요하지 않는 경우 사용됩니다.</li>\n</ul>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> IDX_MULTI <span class=\"token punctuation\">(</span>C1<span class=\"token punctuation\">,</span> C2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> C1<span class=\"token punctuation\">,</span> C2 <span class=\"token keyword\">FROM</span> IDX_MULTI <span class=\"token keyword\">WHERE</span> C1 <span class=\"token operator\">=</span> <span class=\"token string\">'value1'</span> <span class=\"token operator\">and</span> C2 <span class=\"token operator\">=</span> <span class=\"token string\">'value2'</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"column-store-index-열-저장-인덱스\"><a href=\"#column-store-index-%EC%97%B4-%EC%A0%80%EC%9E%A5-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Column store Index (열 저장 인덱스)</h3>\n<ul>\n<li>열 저장소 인덱스는 방대한 데이터 웨어하우징 진리표를 삭제하고 질문하는 것과 관련하여 표준 유형의 인덱스가 있는 SQL 서버의 인덱스 유형 중 하나입니다.</li>\n<li>column-store 인덱스는 작은 인상 안에 정보를 넣을 수 있도록 하여 속도를 높이는데 도움이 됩니다.</li>\n<li>이를 사용하면 클라이언트가 기존의 열 정렬 용량과 달리 조회 실행이 몇 배 높은 IO를 얻을 수 있습니다.</li>\n</ul>\n<h3 id=\"filtered-index-필터링된-인덱스\"><a href=\"#filtered-index-%ED%95%84%ED%84%B0%EB%A7%81%EB%90%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Filtered Index (필터링된 인덱스)</h3>\n<ul>\n<li>필터링된 인덱스는 열에 값의 하위 집합에 대한 질문에 적용 가능한 숫자가 몇 개 없을 때 만들어지는 SQL Server의 인덱스 유형 중 하나입니다.</li>\n<li>테이블이 이기종 데이터 행으로 구성되어 있는 경우, 적어도 한 종류의 데이터에 대해 SQL에 분리된 목록이 만들어집니다.</li>\n</ul>\n<h3 id=\"hash-index-해시-인덱스\"><a href=\"#hash-index-%ED%95%B4%EC%8B%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Hash Index (해시 인덱스)</h3>\n<ul>\n<li>해시 인덱스는 포인터 또는 N 버킷의 배열과 각 슬롯 또는 버킷의 행을 포함하는 슬록에 있는 SQL 서버의 인덱스 유형 중 하나입니다.</li>\n<li>N은 여러 버킷이고 K는 임계값인 해시 함수 F(K, N)을 사용합니다.</li>\n<li>용량은 해시 인덱스의 버킷과 관련된 키를 나타내며 해시 인덱스의 모든 버킷은 8ㅂ이트로 구성되며 기본 섹션의 연결된 런다운 메모리 주소를 저장하는데 사용합니다.</li>\n</ul>\n<h3 id=\"unique-index-고유-인덱스\"><a href=\"#unique-index-%EA%B3%A0%EC%9C%A0-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Unique Index (고유 인덱스)</h3>\n<ul>\n<li>SQL 서버의 고유 인덱스는 인덱스 키에 복사 의존이 포함되어 있지 않는지 확인하고 보장하며 이러한 행을 따라 클라이언트가 테이블의 각 행이 어느쪽이든 예외적인지 검사할 수 있도록 합니다.</li>\n</ul>\n<br/>\n<h2 id=\"인덱스-생성-방법\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>인덱스 생성 방법</h2>\n<h3 id=\"자동-생성과-수동-생성\"><a href=\"#%EC%9E%90%EB%8F%99-%EC%83%9D%EC%84%B1%EA%B3%BC-%EC%88%98%EB%8F%99-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>자동 생성과 수동 생성</h3>\n<ul>\n<li>유일 인덱스는 테이블 정의시 primary key와 unique key 제약 조건을 정의할 때 자동으로 생성됩니다.</li>\n<li>사용자는 행에 대한 액세스 시간을 향상 시키기 위해 열에서 유일하지 않은 인덱스를 생성할 수 있습니다.</li>\n</ul>\n<h3 id=\"상세-생성-방법\"><a href=\"#%EC%83%81%EC%84%B8-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>상세 생성 방법</h3>\n<ul>\n<li>개발 디비에 따라 조금씩 다를 수 있으니 공식 document를 참고하는 것이 좋을 것 같습니다.</li>\n</ul>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://mongyang.tistory.com/75\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SQL, 인덱스(클러스터, 비클러스터) 개념</a></li>\n<li><a href=\"https://tipland.tistory.com/5\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">오라클 인덱스에 대한 정의</a></li>\n<li><a href=\"https://mozi.tistory.com/199\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MySQL, 인덱스 종류 및 고려사항</a></li>\n<li><a href=\"https://www.jigsawacademy.com/blogs/data-science/types-of-indexes-in-sql-server/amp/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">6 Important Types Of Indexes In SQL Server</a></li>\n</ul>\n"}},{"node":{"title":"[DB] Couchbase의 개념과 특징, 아키텍처","path":"/02-db-nosql-couchbase/","date":"20. September 2021","timeToRead":11,"description":"Nosql 중 Couchbase에 대해 좀 더 자세하게 알아봅니다.","content":"<h1 id=\"couchbase를-좀-더-자세하게\"><a href=\"#couchbase%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase를 좀 더 자세하게</h1>\n<p>지난 게시글은 다음과 같습니다.</p>\n<ul>\n<li><a href=\"https://azderica.github.io/00-db-nosql/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL</a></li>\n<li><a href=\"https://azderica.github.io/01-db-nosql-redis/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis</a></li>\n</ul>\n<p>오늘은 Couchbase 개념입니다.</p>\n<h2 id=\"couchbase-개념\"><a href=\"#couchbase-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase 개념</h2>\n<ul>\n<li>카우치 베이스는 Document 기반의 Key-Value 스토어입니다.</li>\n<li>하나의 유니크(Unique)한 키에 값을 저장하는 방식이며, 저장되는 값은 JSON 도큐먼트가 저장됩니다.</li>\n<li>키(key)는 최대 <strong>250 바이트</strong>, 밸류(Value)는 카우치베이스 버킷은 20BMB, Memcached 방식의 버킷의 경우 1MB까지 저장이 됩니다.</li>\n</ul>\n<p>저장할 때, 키와 값 뿐만 아니라 메타데이터도 같이 저장되며 메타 데이터는 <code class=\"language-text\">CAS, TTL, Flag</code> 값 3가지가 저장됩니다.</p>\n<ul>\n<li><code class=\"language-text\">CAS</code> : 데이터에 대한 일종의 타임 스탬프와 같은 개념으로, 여러 클라이언트가 같이 데이터를 접근했을 때 일관성(Consistent) 문제를 해결해줍니다.</li>\n<li><code class=\"language-text\">TTL</code> : <code class=\"language-text\">Time To Live</code>, 데이터의 유효 시간을 정의합니다.</li>\n<li><code class=\"language-text\">FLAG</code> : 카우치베이스 클라이언트에서 사용하는 메타데이터입니다.</li>\n</ul>\n<p>이러한 메타데이터는 하나의 메타데이터(CAS, TTL, Flag)는 60바이트의 메모리를 차지하며, 카우치베이스 서버는 모든 키와 메타데이터를 유지하기 위해 용량을 설계할때, RAM의 사이즈를 결정합니다.</p>\n<h3 id=\"버킷bucket\"><a href=\"#%EB%B2%84%ED%82%B7bucket\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>버킷(Bucket)</h3>\n<ul>\n<li>일종의 RDBMS의 데이터베이스 같은 공간이며 JSON document 들은 이 버킷에 저장됩니다.</li>\n<li>각각의 버킷은 고유의 속성 값을 가지고 있습니다. 버킷별로 사용할 수 있는 메모리 양, 옵션으로 버킷별로 접근할 수 있는 TCP 포트, 접근 비밀번호, 버킷에 들어가는 데이터에 대한 복제본의 수 등을 정할 수 있습니다.</li>\n</ul>\n<h3 id=\"뷰view\"><a href=\"#%EB%B7%B0view\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>뷰(View)</h3>\n<ul>\n<li>카우치 베이스의 강력한 능력이며, 이 뷰를 통해서 <code class=\"language-text\">Indexing, grouping, sorting</code> 등이 가능합니다.</li>\n<li>뷰는 데이터베이스 뷰와 유사한 개념을 가지며 카우치베이스의 뷰는 incremental view라는 컨셉을 가집니다.</li>\n</ul>\n<p>다음의 예시를 보면 뷰의 기능의 동작을 예상할 수 있습니다. Json document 안에 주민번호있고, 80년생 이하만 저장하는 뷰를 만든다고 가정하면 데이터가 버킷에 저장될 때마다 생성된 뷰에 같이 저장됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133991552-ccead205-7fc2-4ed3-bc6a-7832eee5e241.png\" alt=\"couchbase-view-sample\"></p>\n<p>이와 같은 결과로 데이터를 저장하거나 업데이트시 뷰 코드가 매번 수행되고, 뷰코드에 저장된 알고리즘에 따라 뷰에 데이터를 업데이트합니다.</p>\n<p>이를 더 자세하게 보면 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133992279-e17df7a9-9369-459f-9b27-9a840b9edb14.png\" alt=\"Map &#x26; Reduce\"></p>\n<p><a href=\"https://bcho.tistory.com/928?category=534534\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">출처 및 뷰에 대한 상세 개념</a></p>\n<p><code class=\"language-text\">Map Function(Map &amp; Reduce)</code> 함수를 통해서 View를 만듭니다.</p>\n<ul>\n<li>맵함수는 두 개의 인자를 전달받으며 index(id, key, value)를 만들고 리듀스를 통해서 grouping이나 여러 처리를 할 수 있습니다.</li>\n<li>즉, <strong>뷰에는 각 버킷내의 개별 데이터를 반환하는 맵함수와 변환된 개별 데이터를 그룹별로 모아서 처리할 수 있는 리듀스 함수를 가집니다.</strong></li>\n</ul>\n<br/>\n<h2 id=\"couchbase-특징\"><a href=\"#couchbase-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase 특징</h2>\n<h3 id=\"memcached-기반의-level-2-캐쉬를-내장하여-빠릅니다\"><a href=\"#memcached-%EA%B8%B0%EB%B0%98%EC%9D%98-level-2-%EC%BA%90%EC%89%AC%EB%A5%BC-%EB%82%B4%EC%9E%A5%ED%95%98%EC%97%AC-%EB%B9%A0%EB%A6%85%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Memcached 기반의 Level 2 캐쉬를 내장하여 빠릅니다.</h3>\n<ul>\n<li>memcached를 자체적으로 Level 2 캐쉬로 사용합니다.</li>\n<li>자체적으로 메모리 캐쉬 기능을 가지고 있기 때문에 성능이 빠릅니다.</li>\n</ul>\n<p>(다만, 키의 유연성이나 클러스터에서 단점을 가집니다.)</p>\n<h3 id=\"모바일-디바이스와-sync\"><a href=\"#%EB%AA%A8%EB%B0%94%EC%9D%BC-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4%EC%99%80-sync\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>모바일 디바이스와 Sync</h3>\n<ul>\n<li>카우치디비 계열 DB들은 모바일 디바이스에 탑재할 수 있으며, 서버에 설치된 카우치베이스 계열과 Sync가 됩니다.</li>\n</ul>\n<h3 id=\"데이터-센터간-복제-기간\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%84%BC%ED%84%B0%EA%B0%84-%EB%B3%B5%EC%A0%9C-%EA%B8%B0%EA%B0%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>데이터 센터간 복제 기간</h3>\n<ul>\n<li>XDCR(Cross Data Center Replication)의 기능을 이용해서 물리적으로 떨어진 데이터 센터간에 복제가 가능합니다.</li>\n<li><a href=\"https://azderica.github.io/00-db-couchbase-xdcr/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">XDCR의 상세 내용</a></li>\n</ul>\n<h3 id=\"indexing-grouping-ordering-join-가능\"><a href=\"#indexing-grouping-ordering-join-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Indexing, Grouping, Ordering, Join 가능</h3>\n<ul>\n<li>대부분의 NoSQL은 Key/Value Store 형식으로, 개별 필드에 대한 Indexing이나 필드별로 group by를 통한 sum,count 등의 기능, 특정 필드별로의 Sorting이 불가능합니다.</li>\n<li>Indexing을 지원하는 경우도 있기는 하지만, 내부적으로 성능상 문제가 있는 경우가 많으나 카우치베이스는 그러한 문제가 없습니다.</li>\n</ul>\n<h3 id=\"확장이-쉬움\"><a href=\"#%ED%99%95%EC%9E%A5%EC%9D%B4-%EC%89%AC%EC%9B%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>확장이 쉬움</h3>\n<ul>\n<li>분산 구조의 NoSQL의 경우 노드확장이 어렵거나 장애처리가 어려운 경우가 많으나 카우치베이스는 손쉽게 확장을 하고 장애 처리를 합니다.</li>\n<li>이러한 장점은 운영에서 큰 이점이 됩니다.</li>\n</ul>\n<h3 id=\"built-in-관리-도구-제공\"><a href=\"#built-in-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC-%EC%A0%9C%EA%B3%B5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Built in 관리 도구 제공</h3>\n<ul>\n<li>카우치베이스는 웹 기반의 GUI 관리 도구를 기본으로 제공합니다.</li>\n</ul>\n<blockquote>\n<p>Couchbase Web Console</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133992009-871775fb-ac8f-4453-ad35-5ba7ba349d31.png\" alt=\"couchbase-web-console\"></p>\n<p><a href=\"https://soccerda.tistory.com/124\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">출처</a></p>\n<h3 id=\"memcached-프로토콜-지원\"><a href=\"#memcached-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Memcached 프로토콜 지원</h3>\n<ul>\n<li>캐쉬 솔루션으로 유명한 Memcached 르포토콜을 지원하기 때문에 Memcached 인프라를 사용할 수 있습니다.</li>\n</ul>\n<h3 id=\"스키마가-없는-유연한-저장-구조scheme-less\"><a href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88%EA%B0%80-%EC%97%86%EB%8A%94-%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%A0%80%EC%9E%A5-%EA%B5%AC%EC%A1%B0scheme-less\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>스키마가 없는 유연한 저장 구조(Scheme-less)</h3>\n<ul>\n<li>스키마가 없으므로 하나의 테이블에 컬럼 형식이 다른 데이터를 넣을 수 있습니다.</li>\n<li>하나의 데이터 버킷에 데이타 구조가 다른 JSON 문서들을 넣을 수 있습니다.</li>\n<li>데이터 타입이 다름에도 불구하고 공통되는 필드에 대해 Indexing, grouping 등을 제공할 수 있으며 JSON 도큐먼트에 country 라는 앨리먼트가 있는 도큐먼트등을 대상으로 grouping등을 할수 있습니다.</li>\n</ul>\n<br/>\n<h2 id=\"couchbase-architecture\"><a href=\"#couchbase-architecture\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase Architecture</h2>\n<p>Couchbase Server는 모든 노드에 설치된 단일 패키지로 구성됩니다.</p>\n<h3 id=\"노드와-클러스터node--cluster\"><a href=\"#%EB%85%B8%EB%93%9C%EC%99%80-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0node--cluster\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>노드와 클러스터(Node &#x26; Cluster)</h3>\n<ul>\n<li>노드는 물리적인 서버에서 기동하는 하나의 카우치베이스 인스턴스</li>\n<li>카우치베이스는 여러 개의 노드로 이루어진 클러스터로 구성됩니다.</li>\n</ul>\n<h3 id=\"클라이언트-sdkclient-sdk\"><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-sdkclient-sdk\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>클라이언트 SDK(Client SDK)</h3>\n<ul>\n<li>프로그래밍 언어별로 카우치베이스에 접근하기 위한 API(SDK)를 제공합니다.</li>\n<li>SDK를 사용해서 선택한 언어(Java, node.js, .NET 등)으로 애플리케이션을 작성할 수 있습니다.</li>\n</ul>\n<h3 id=\"vbucket\"><a href=\"#vbucket\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>vBucket</h3>\n<ul>\n<li>카우치베이스는 실제 데이터와 물리서버간의 맵핑을 <code class=\"language-text\">vBucket</code>을 통해 관리합니다.</li>\n<li>카우치베이스는 키-밸류 스토어이며, 각 키가 어디있는지는 vBucket이라는 단위로 관리하고, 키에 대한 해쉬값을 계산한 후에 각 해쉬값에 따라서 저장되는 vBucket을 맵핑한다음 각 vBucket을 노드에 맵핑합니다.</li>\n<li><strong>Rebalancing</strong> : 노드가 추가되거나 삭제되었을 때, 물리적으로 데이터가 다른 노드로 다시 분산배치되고 새롭게 배치된 데이터에 따라 vBucket이 노드간에 데이터 맵핑 정보도 업데이트됩니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133996020-9ffb4d3d-9091-4e47-bb22-fdcf93baf961.png\" alt=\"vBucket\"></p>\n<h3 id=\"노드의-구조\"><a href=\"#%EB%85%B8%EB%93%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>노드의 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133996334-1d0c59e5-c7d7-48d9-a8a8-ea87bc0fed64.png\" alt=\"couchbase-node-detail\"></p>\n<ul>\n<li>Couchbase의 노드는 Data Manage과 Cluster Manager로 나눠집니다.</li>\n</ul>\n<h4 id=\"data-manager\"><a href=\"#data-manager\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Manager</h4>\n<ul>\n<li>직접 데이터에 접근하는 부분이며, set/get 메서드를 통한 데이터 저장이나 뷰에 대한 쿼리를 수행할 때 접근합니다.</li>\n<li><code class=\"language-text\">Multi Thread Persistence Engine</code> : 디스크에 데이터를 저장하거나 읽을 때 사용하는 컴포넌트입니다.</li>\n</ul>\n<h4 id=\"cluster-manager\"><a href=\"#cluster-manager\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cluster Manager</h4>\n<ul>\n<li>노드에 대한 상태와 클러스터에 대한 상태, 설정 등을 관리하는 부분이며 <code class=\"language-text\">Erlang/OTP</code>로 구성되어 있습니다.</li>\n<li>카우치베이스 클라이언트 SDK는 8091포트의 REST API를 통해서 vBucket 정보를 가져옵니다.</li>\n<li>다수의 포트 등을 사용합니다. (사용전에 열어야하는 포트들이 있습니다.)</li>\n</ul>\n<h3 id=\"데이터-쓰기와-복제\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%93%B0%EA%B8%B0%EC%99%80-%EB%B3%B5%EC%A0%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>데이터 쓰기와 복제</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133997054-0f325983-d6b6-4a10-b1e7-634de4a7e50b.png\" alt=\"couchbase-data-read/write\"></p>\n<ul>\n<li>클라이언트에서 Client SDK를 통해서 쓰기 요청을 하면, Client SDK는 해쉬 알고리즘에 따라 데이터의 키 값에 맵핑되는 vBucket을 찾아내고 그 해당하는 노드를 찾아 쓰기 요청을 합니다.</li>\n<li>쓰기 요청은 해당 노드의 Listener로 전달되고, 이 Listener는 들어온 데이터를 로컬의 캐쉬에 쓰고 클러스터의 다른 노드로 복제 요청을 보냅니다. 그리고 데이터는 노드의 디스크에 저장됩니다.</li>\n</ul>\n<br/>\n<h2 id=\"couchbase-cluster\"><a href=\"#couchbase-cluster\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase Cluster</h2>\n<ul>\n<li>Couchbase 클러스터는 각각 독립 노드에서 실행되는 하나 이상의 Couchbase Server 인스턴스로 구성됩니다.</li>\n<li>Couchbase Server를 실행하는 각 노드, 클러스터에 여러 노드가 있는 경우 Couchbase 클러스터 관리자는 각 노드에서 실행됩니다.</li>\n<li>클러스터의 전체 또는 일부 노드에서 실행되도록 서비스를 구성할 수 있습니다.</li>\n</ul>\n<h3 id=\"유혀성\"><a href=\"#%EC%9C%A0%ED%98%80%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>유혀성</h3>\n<ul>\n<li>데이터는 Couchbase Server에 의해 클러스터 전체에 자동으로 배포됩니다.</li>\n<li>Couchbase Server는 노드 추가 및 제거, 노드 장애를 자동으로 처리합니다.</li>\n</ul>\n<br/>\n<h2 id=\"couchbase-vs-mongodb\"><a href=\"#couchbase-vs-mongodb\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase VS MongoDB</h2>\n<p>공통점은 다음과 같습니다.</p>\n<ul>\n<li>Document 기반의 NoSQL입니다.</li>\n</ul>\n<p>그러나 차이점이 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>이름</th>\n<th>Couchbase</th>\n<th>MongoDB</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>설명</td>\n<td>Memcached 호환 인터페이스를 사용하여 CouchDB에서 파생된 JSON 기반 문서 저장소</td>\n<td>완전 관리형 클라우드 서비스와 자체 관리형, 인프라에 배포할 수 있는 가장 인기있는 문서 저장소 입니다.</td>\n</tr>\n<tr>\n<td>기본 데이터베이스 모델</td>\n<td>문서 저장소</td>\n<td>문서 저장소</td>\n</tr>\n<tr>\n<td>보조 데이터베이스 모델</td>\n<td>키-값 저장 공간 DBMS</td>\n<td>공간 DBMS</td>\n</tr>\n<tr>\n<td>스키마</td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>파티셔닝</td>\n<td>샤딩</td>\n<td>샤딩</td>\n</tr>\n</tbody>\n</table>\n<p>좀 더 자세한 차이를 알기 위해서는 다음 링크를 참고합니다.</p>\n<p><a href=\"https://db-engines.com/en/system/Couchbase%3BMongoDB\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Couchbase VS MongoDB</a></p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://bcho.tistory.com/924\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase 소개</a></li>\n<li><a href=\"https://bcho.tistory.com/925\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase 개념</a></li>\n<li><a href=\"https://bcho.tistory.com/928\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase view</a></li>\n<li><a href=\"https://bcho.tistory.com/934\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase architecture</a></li>\n<li><a href=\"https://docs.couchbase.com/server/5.0/architecture/architecture-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase architecture detail</a></li>\n<li><a href=\"https://docs.couchbase.com/server/current/learn/clusters-and-availability/clusters-and-availability.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase cluster</a></li>\n<li><a href=\"https://dzone.com/articles/introduction-to-couchbase-for-mongodb-developers-a-1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase vs mongodb</a></li>\n<li><a href=\"https://zepinos.tistory.com/60?category=797689\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">왜 Couchbase을 선택하게 되었는가 - 1</a></li>\n<li><a href=\"https://zepinos.tistory.com/61\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">왜 Couchbase을 선택하게 되었는가 - 2</a></li>\n<li><a href=\"https://docs.couchbase.com/couchbase-manual-2.5/cb-admin/#faqs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Couchbase Docs</a></li>\n</ul>\n"}},{"node":{"title":"[DB] Redis의 개념과 특징, 아키텍처","path":"/01-db-nosql-redis/","date":"17. September 2021","timeToRead":9,"description":"NoSQL 중 Redis에 대해 좀 더 자세하게 알아봅니다.","content":"<h1 id=\"redis를-좀-더-자세하게\"><a href=\"#redis%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis를 좀 더 자세하게.</h1>\n<p>지난번 게시글에서는 <a href=\"https://azderica.github.io/00-db-nosql/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL</a>에 대한 기본 개념과 종류에 대해서 정리했습니다.</p>\n<p>이번에는 더 나아가서 대표적인 NoSQL이 가지는 아키텍처를 정리합니다. 오늘은 Redis에 대해 좀 더 정리하려고합니다.</p>\n<h2 id=\"redis란\"><a href=\"#redis%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis란.</h2>\n<ul>\n<li>고 성능의 키-값 데이터 구조 스토어입니다.</li>\n<li>여러 자료구조를 지원하며 크게 <code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 등의 데이터 형식을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis-특징\"><a href=\"#redis-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 특징</h2>\n<ul>\n<li>\n<p>영속성을 지원하는 인메모리 데이터 저장소</p>\n<ul>\n<li>왜 영속성을 제공하는지는 아래에서 설명합니다.</li>\n</ul>\n</li>\n<li>\n<p>읽기 성능 증대를 위한 서버 측 복제를 지원합니다.</p>\n<ul>\n<li>전체 데이터베이스의 초기 복사본을 받는 마스터/슬레이브 복제를 지원합니다.</li>\n<li>마스터에서 쓰기가 수행되면 슬레이브 데이터 세트를 실시간으로 업데이터하기 위해 연결된 모든 슬레이브로 전송됩니다.</li>\n</ul>\n</li>\n<li>쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding)을 지원합니다.</li>\n<li><code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 과 같은 다양한 데이터형을 지원합니다.</li>\n</ul>\n<blockquote>\n<p>샤딩(Sharding)</p>\n</blockquote>\n<p>파티셔닝과 동일하며, 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미합니다.</p>\n<br/>\n<h2 id=\"redis-특징-1\"><a href=\"#redis-%ED%8A%B9%EC%A7%95-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 특징</h2>\n<h3 id=\"key-value-store\"><a href=\"#key-value-store\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Key-Value Store</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133774329-00ddf3c0-a24e-40b0-9dd8-460616ea5400.png\" alt=\"Redis-is-map\"></p>\n<ul>\n<li>Redis는 거대한 맵(Map) 데이터 저장소입니다.</li>\n<li>Redis는 익히기 쉬우며 직관적입니다. 그러나, 데이터를 레디스 자체 내에서는 처리하기 어렵습니다.</li>\n</ul>\n<h3 id=\"다양한-데이터-타입\"><a href=\"#%EB%8B%A4%EC%96%91%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>다양한 데이터 타입</h3>\n<ul>\n<li><code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 등의 타입을 지원합니다.</li>\n</ul>\n<h3 id=\"persistence\"><a href=\"#persistence\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Persistence</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133775761-c7644499-ae6f-4aa8-bd25-8208780c41e0.png\" alt=\"Redis-Persistence\"></p>\n<ul>\n<li>Redis는 영속성을 가집니다.</li>\n<li>Redis는 데이터를 disk에 저장할 수 있습니다. 따라서 Redis는 서버가 강제 종료되고 재시작하더라도 disk에 저장해놓은 데이터를 다시 읽어서 데이터가 유실되지 않습니다.</li>\n<li>\n<p>redis의 데이터를 disk에 저장하는 방식은 <strong>snapshot, AOF</strong> 방식이 있습니다.</p>\n<ul>\n<li><code class=\"language-text\">Snapshot</code> : RDB와 비슷하게 어떤 특정 시점의 데이터를 Disk에 담는 방식을 뜻합니다. <strong>Blocking</strong> 방식의 <strong>SAVE</strong>와 <strong>Non-blocking</strong> 방식의 <strong><a href=\"http://redisgate.kr/redis/server/bgsave.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">BGSAVE</a></strong> 방식이 있습니다.</li>\n<li><code class=\"language-text\">AOF</code> : Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태입니다. 서버가 재시작 시 write/update를 순차적으로 재실행하고 데이터를 복구합니다.</li>\n<li>가장 좋은 방식은 두 방법을 혼용해서 사용하는 방법으로 주기적으로 snapshot으로 백업을 하고 다음 snapshot까지의 저장을 AOF 방식으로 수행하는 방식입니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ansi-c로-작성\"><a href=\"#ansi-c%EB%A1%9C-%EC%9E%91%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ANSI C로 작성</h3>\n<ul>\n<li>C언어로 작성되어 Java와 같이 가상머신 위에서 동작하는 언어에서 발생하는 성능 문제에서 자유롭습니다.</li>\n</ul>\n<h3 id=\"서버측-복제-및-샤딩-지원\"><a href=\"#%EC%84%9C%EB%B2%84%EC%B8%A1-%EB%B3%B5%EC%A0%9C-%EB%B0%8F-%EC%83%A4%EB%94%A9-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서버측 복제 및 샤딩 지원</h3>\n<ul>\n<li>읽기 성능 증대를 위해 서버 측 복제를 지원합니다.</li>\n<li>쓰기 성능 증대를 위해 클라이언트 측 샤딩을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis의-장점\"><a href=\"#redis%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis의 장점</h2>\n<ul>\n<li>리스트, 배열과 같은 데이터를 처리하는데 유용합니다.</li>\n<li>Message Queue, Shared Memory, Remote Dictionary(RDBMS의 캐시 솔루션 / read 속도가 매우 빠릅니다.) 용도로 사용됩니다.</li>\n<li>메모리를 활용하면서 데이터를 보존합니다.</li>\n<li>Redis Server는 1개의 싱글 쓰레드로 수행되며, 서버 하나에 여러개의 서버를 띄우는 것이 가능합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis-아키텍처-구성\"><a href=\"#redis-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 아키텍처, 구성</h2>\n<ul>\n<li>HA(High Availability) : 무중단 서비스 등</li>\n</ul>\n<h3 id=\"standalone--no-ha-마스터\"><a href=\"#standalone--no-ha-%EB%A7%88%EC%8A%A4%ED%84%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Standalone : No HA, 마스터</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133778042-cf59f712-752a-4c61-8a1a-b9ac435726a1.png\" alt=\"Redis-Standalone\"></p>\n<ul>\n<li>레디스 서버 1대로 구성하며 이를 마스터 노드라고 합니다.</li>\n<li>서버 다운시 AOF 또는 Snapshot 파일을 이용해 재 시작합니다.</li>\n</ul>\n<h3 id=\"replication--half-ha-마스터-슬레이브\"><a href=\"#replication--half-ha-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%AC%EB%A0%88%EC%9D%B4%EB%B8%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Replication : Half HA, 마스터-슬레이브</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133778753-41bfa929-aa5f-48e5-9509-7e4df1379baa.png\" alt=\"Redis-Replication\"></p>\n<ul>\n<li>레디스 서버 2대(마스터-슬레이브)로 구성됩니다. 슬레이브는 마스터의 데이터를 실시간으로 전달받아 보관합니다.</li>\n<li>마스터 다운 시 슬레이브 서버를 통해 서비스를 계속할 수 있습니다. 하지만, 이때는 수동으로 슬레이브 서버를 마스터로 변경해야합니다.</li>\n<li>한 마스터에 슬레이브를 여러 대 구성할 수 도 있습니다.</li>\n</ul>\n<h3 id=\"이중화--센티널sentinel--ha-무중단-서비스-가능\"><a href=\"#%EC%9D%B4%EC%A4%91%ED%99%94--%EC%84%BC%ED%8B%B0%EB%84%90sentinel--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>이중화 + 센티널(Sentinel) : HA, 무중단 서비스 가능</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133779960-5c97207f-75d7-405c-a4ea-730bba593e2d.png\" alt=\"image\"></p>\n<ul>\n<li>마스터-슬레이브 구성에 <strong>센티널</strong>을 추가해서 각 서버를 감시하도록하며, 센티널은 마스터 서버를 감시하고 있다가 다운되면 슬레이브를 마스터로 승격시킵니다.</li>\n<li>다운된 마스터가 다시 시작되면 센티널이 슬레이브로 전환시킵니다.</li>\n<li>레디스 마스터 노드가 모든 데이터를 가지고 있으며 슬레이브는 마스터에 대한 복제본을 유지하고 있으며, 데이터를 분산하지 않습니다.</li>\n<li>일반적으로 레디스 센티널은 레디스 서버마다 하나씩 설치하며, 레디스 서버와 분리된 프로세스이며 다른 포트를 사용합니다. (데이터를 처리하지 않습니다.)</li>\n<li>레디스 센티널은 높은 가용성과 자동 fail over 을 해결하지만 <strong>데이터 분산 문제를 해결하지 못합니다.</strong></li>\n</ul>\n<p><a href=\"https://hub.docker.com/r/erichsu/redis-sentinel/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Sentinel Docker</a></p>\n<h3 id=\"레디스-클러스터cluster--ha-무중단-서비스-가능\"><a href=\"#%EB%A0%88%EB%94%94%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0cluster--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>레디스 클러스터(Cluster) : HA, 무중단 서비스 가능</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133781464-16c21b85-1ca2-4e0f-8028-5acf9a37a2f8.png\" alt=\"Redis-Cluster-Type-1\"></p>\n<p>머신 하나가 죽었을 시 해결이 됩니다. 다만 두개가 죽으면 해결이 안됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133782017-fe094509-ed9a-419c-9739-35a766b4e334.png\" alt=\"Redis-Cluster-Type-2\"></p>\n<p>위의 문제를 해결하는 방법입니다.</p>\n<ul>\n<li>\n<p><strong>샤딩</strong></p>\n<ul>\n<li>클라스터는 <strong>샤딩</strong>(sharding, 대량의 데이터를 처리하기 위해 여러 개의 데이터베이스에 분할하는 기술) 방법을 제공하는 방법입니다.</li>\n<li>100개의 데이터를 1번 마스터에 33개, 2번 마스터 33개, 3번 마스터에 나머지 34개가 저장되는 방식입니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>Hash 함수</strong></p>\n<ul>\n<li>데이터를 나누는 방식은 키에 hash 함수를 적용해서 값을 추출하고, 이 값을 각 마스터 서버에 할당합니다.</li>\n<li>클러스터 구성시 해쉬 함수를 통해서 1~33까지를 1번 서버, 34~ 66번까지를 2번 서버, 3번 서버는 또 다르게 할당됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>해시 슬록(16384 슬롯)</strong></p>\n<ul>\n<li>레디스에서 hash 값의 개수는 16384(0~16383)이고 슬롯(slot)이라고 합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>해시 태그</strong></p>\n<ul>\n<li>다중 키 작업을 진행하려면 동일 노드에 저장될 모든 키가 필요합니다. 해시 태그는 레디스 클러스터에서 다중키를 사용할 수 있는 유일한 방법입니다.</li>\n<li>해시 함수를 적용해 동일한 해시 슬롯에 여러 개의 키 이름을 저장할 수 있도록 사용됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>레디스 클라이언트</strong></p>\n<ul>\n<li>클라이언트는 서버와 동일한 hash 함수를 가지고 있으며 마스터 서버에 접속해서 각 서버에 할당된 슬롯 정보를 가지고 있습니다.</li>\n<li>키가 입력되면 hash 함수를 적용해서 어느 마스터에 저장할지 판단해서 해당 마스터에 저장합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>데이터 서버 + 센티널</strong></p>\n<ul>\n<li>각 마스터 서버는 데이터의 처리와 센티널의 역할을 같이수행합니다.</li>\n<li>1번 마스터 서버가 다운되면 나머지 살아있는 마스터들 중에서 리더를 선출해서 리더가 1번 마스터의 슬레이브를 마스터로 승격시킵니다.</li>\n</ul>\n</li>\n<li>\n<p>최소 3대</p>\n<ul>\n<li>마스터 서버는 최소 3대로 구성하고 각각은 슬레이브를 가질 수 있습니다.</li>\n</ul>\n</li>\n<li>마스터를 관리하는 마스터는 없습니다. 이는 또 하나의 장애점입니다.</li>\n<li>레디스가 사용하는 포트는 2개이며 하나는 클라이언트 하나는 노드 간의 통신을 위한 버스로 사용됩니다.</li>\n</ul>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jyejye9201.medium.com/%EB%A0%88%EB%94%94%EC%8A%A4-redis-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-2b7af75fa818\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis란 무엇인가</a></li>\n<li><a href=\"https://docs.redis.com/latest/rs/concepts/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Concept</a></li>\n<li><a href=\"http://redisgate.kr/redis/configuration/redis_overview.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Architecture Overview</a></li>\n<li><a href=\"https://cla9.tistory.com/101\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis 구조</a></li>\n<li><a href=\"https://engkimbs.tistory.com/869\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">레디스 소개 및 아키텍처, 주의할 점</a></li>\n<li><a href=\"https://coding-start.tistory.com/128\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis - Cluster &#x26; Sentinel</a></li>\n<li><a href=\"https://redis.io/commands\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Command</a></li>\n<li><a href=\"https://redis.com/redis-enterprise/technology/redis-enterprise-cluster-architecture/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Enterprise Cluster Architecture</a></li>\n</ul>\n"}}]}}},"context":{}}