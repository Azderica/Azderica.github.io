{"hash":"4d08d5d9909bc52ba8ae53ab8b5e8ea790bc2d53","data":{"tag":{"title":"Cluster","belongsTo":{"edges":[{"node":{"title":"[DB] Redis의 개념과 특징, 아키텍처","path":"/01-db-nosql-redis/","date":"15. September 2021","timeToRead":9,"description":"Nosql 중 Redis에 대해 좀 더 자세하게 알아봅니다.","content":"<h1 id=\"redis를-좀-더-자세하게\"><a href=\"#redis%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis를 좀 더 자세하게.</h1>\n<p>지난번 게시글에서는 <a href=\"https://azderica.github.io/00-db-nosql/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL</a>에 대한 기본 개념과 종류에 대해서 정리했습니다.</p>\n<p>이번에는 더 나아가서 대표적인 NoSQL이 가지는 아키텍처를 정리합니다. 오늘은 Redis에 대해 좀 더 정리하려고합니다.</p>\n<h2 id=\"redis란\"><a href=\"#redis%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis란.</h2>\n<ul>\n<li>고 성능의 키-값 데이터 구조 스토어입니다.</li>\n<li>여러 자료구조를 지원하며 크게 <code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 등의 데이터 형식을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis-특징\"><a href=\"#redis-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 특징</h2>\n<ul>\n<li>\n<p>영속성을 지원하는 인메모리 데이터 저장소</p>\n<ul>\n<li>왜 영속성을 제공하는지는 아래에서 설명합니다.</li>\n</ul>\n</li>\n<li>\n<p>읽기 성능 증대를 위한 서버 측 복제를 지원합니다.</p>\n<ul>\n<li>전체 데이터베이스의 초기 복사본을 받는 마스터/슬레이브 복제를 지원합니다.</li>\n<li>마스터에서 쓰기가 수행되면 슬레이브 데이터 세트를 실시간으로 업데이터하기 위해 연결된 모든 슬레이브로 전송됩니다.</li>\n</ul>\n</li>\n<li>쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding)을 지원합니다.</li>\n<li><code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 과 같은 다양한 데이터형을 지원합니다.</li>\n</ul>\n<blockquote>\n<p>샤딩(Sharding)</p>\n</blockquote>\n<p>파티셔닝과 동일하며, 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미합니다.</p>\n<br/>\n<h2 id=\"redis-특징-1\"><a href=\"#redis-%ED%8A%B9%EC%A7%95-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 특징</h2>\n<h3 id=\"key-value-store\"><a href=\"#key-value-store\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Key-Value Store</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133774329-00ddf3c0-a24e-40b0-9dd8-460616ea5400.png\" alt=\"Redis-is-map\"></p>\n<ul>\n<li>Redis는 거대한 맵(Map) 데이터 저장소입니다.</li>\n<li>Redis는 익히기 쉬우며 직관적입니다. 그러나, 데이터를 레디스 자체 내에서는 처리하기 어렵습니다.</li>\n</ul>\n<h3 id=\"다양한-데이터-타입\"><a href=\"#%EB%8B%A4%EC%96%91%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>다양한 데이터 타입</h3>\n<ul>\n<li><code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 등의 타입을 지원합니다.</li>\n</ul>\n<h3 id=\"persistence\"><a href=\"#persistence\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Persistence</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133775761-c7644499-ae6f-4aa8-bd25-8208780c41e0.png\" alt=\"Redis-Persistence\"></p>\n<ul>\n<li>Redis는 영속성을 가집니다.</li>\n<li>Redis는 데이터를 disk에 저장할 수 있습니다. 따라서 Redis는 서버가 강제 종료되고 재시작하더라도 disk에 저장해놓은 데이터를 다시 읽어서 데이터가 유실되지 않습니다.</li>\n<li>\n<p>redis의 데이터를 disk에 저장하는 방식은 <strong>snapshot, AOF</strong> 방식이 있습니다.</p>\n<ul>\n<li><code class=\"language-text\">Snapshot</code> : RDB와 비슷하게 어떤 특정 시점의 데이터를 Disk에 담는 방식을 뜻합니다. <strong>Blocking</strong> 방식의 <strong>SAVE</strong>와 <strong>Non-blocking</strong> 방식의 <strong><a href=\"http://redisgate.kr/redis/server/bgsave.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">BGSAVE</a></strong> 방식이 있습니다.</li>\n<li><code class=\"language-text\">AOF</code> : Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태입니다. 서버가 재시작 시 write/update를 순차적으로 재실행하고 데이터를 복구합니다.</li>\n<li>가장 좋은 방식은 두 방법을 혼용해서 사용하는 방법으로 주기적으로 snapshot으로 백업을 하고 다음 snapshot까지의 저장을 AOF 방식으로 수행하는 방식입니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ansi-c로-작성\"><a href=\"#ansi-c%EB%A1%9C-%EC%9E%91%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ANSI C로 작성</h3>\n<ul>\n<li>C언어로 작성되어 Java와 같이 가상머신 위에서 동작하는 언어에서 발생하는 성능 문제에서 자유롭습니다.</li>\n</ul>\n<h3 id=\"서버측-복제-및-샤딩-지원\"><a href=\"#%EC%84%9C%EB%B2%84%EC%B8%A1-%EB%B3%B5%EC%A0%9C-%EB%B0%8F-%EC%83%A4%EB%94%A9-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서버측 복제 및 샤딩 지원</h3>\n<ul>\n<li>읽기 성능 증대를 위해 서버 측 복제를 지원합니다.</li>\n<li>쓰기 성능 증대를 위해 클라이언트 측 샤딩을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis의-장점\"><a href=\"#redis%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis의 장점</h2>\n<ul>\n<li>리스트, 배열과 같은 데이터를 처리하는데 유용합니다.</li>\n<li>Message Queue, Shared Memory, Remote Dictionary(RDBMS의 캐시 솔루션 / read 속도가 매우 빠릅니다.) 용도로 사용됩니다.</li>\n<li>메모리를 활용하면서 데이터를 보존합니다.</li>\n<li>Redis Server는 1개의 싱글 쓰레드로 수행되며, 서버 하나에 여러개의 서버를 띄우는 것이 가능합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis-아키텍처-구성\"><a href=\"#redis-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 아키텍처, 구성</h2>\n<ul>\n<li>HA(High Availability) : 무중단 서비스 등</li>\n</ul>\n<h3 id=\"standalone--no-ha-마스터\"><a href=\"#standalone--no-ha-%EB%A7%88%EC%8A%A4%ED%84%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Standalone : No HA, 마스터</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133778042-cf59f712-752a-4c61-8a1a-b9ac435726a1.png\" alt=\"Redis-Standalone\"></p>\n<ul>\n<li>레디스 서버 1대로 구성하며 이를 마스터 노드라고 합니다.</li>\n<li>서버 다운시 AOF 또는 Snapshot 파일을 이용해 재 시작합니다.</li>\n</ul>\n<h3 id=\"replication--half-ha-마스터-슬레이브\"><a href=\"#replication--half-ha-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%AC%EB%A0%88%EC%9D%B4%EB%B8%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Replication : Half HA, 마스터-슬레이브</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133778753-41bfa929-aa5f-48e5-9509-7e4df1379baa.png\" alt=\"Redis-Replication\"></p>\n<ul>\n<li>레디스 서버 2대(마스터-슬레이브)로 구성됩니다. 슬레이브는 마스터의 데이터를 실시간으로 전달받아 보관합니다.</li>\n<li>마스터 다운 시 슬레이브 서버를 통해 서비스를 계속할 수 있습니다. 하지만, 이때는 수동으로 슬레이브 서버를 마스터로 변경해야합니다.</li>\n<li>한 마스터에 슬레이브를 여러 대 구성할 수 도 있습니다.</li>\n</ul>\n<h3 id=\"이중화--센티널sentinel--ha-무중단-서비스-가능\"><a href=\"#%EC%9D%B4%EC%A4%91%ED%99%94--%EC%84%BC%ED%8B%B0%EB%84%90sentinel--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>이중화 + 센티널(Sentinel) : HA, 무중단 서비스 가능</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133779960-5c97207f-75d7-405c-a4ea-730bba593e2d.png\" alt=\"image\"></p>\n<ul>\n<li>마스터-슬레이브 구성에 <strong>센티널</strong>을 추가해서 각 서버를 감시하도록하며, 센티널은 마스터 서버를 감시하고 있다가 다운되면 슬레이브를 마스터로 승격시킵니다.</li>\n<li>다운된 마스터가 다시 시작되면 센티널이 슬레이브로 전환시킵니다.</li>\n<li>레디스 마스터 노드가 모든 데이터를 가지고 있으며 슬레이브는 마스터에 대한 복제본을 유지하고 있으며, 데이터를 분산하지 않습니다.</li>\n<li>일반적으로 레디스 센티널은 레디스 서버마다 하나씩 설치하며, 레디스 서버와 분리된 프로세스이며 다른 포트를 사용합니다. (데이터를 처리하지 않습니다.)</li>\n<li>레디스 센티널은 높은 가용성과 자동 fail over 을 해결하지만 <strong>데이터 분산 문제를 해결하지 못합니다.</strong></li>\n</ul>\n<p><a href=\"https://hub.docker.com/r/erichsu/redis-sentinel/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Sentinel Docker</a></p>\n<h3 id=\"레디스-클러스터cluster--ha-무중단-서비스-가능\"><a href=\"#%EB%A0%88%EB%94%94%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0cluster--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>레디스 클러스터(Cluster) : HA, 무중단 서비스 가능</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133781464-16c21b85-1ca2-4e0f-8028-5acf9a37a2f8.png\" alt=\"Redis-Cluster-Type-1\"></p>\n<p>머신 하나가 죽었을 시 해결이 됩니다. 다만 두개가 죽으면 해결이 안됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133782017-fe094509-ed9a-419c-9739-35a766b4e334.png\" alt=\"Redis-Cluster-Type-2\"></p>\n<p>위의 문제를 해결하는 방법입니다.</p>\n<ul>\n<li>\n<p><strong>샤딩</strong></p>\n<ul>\n<li>클라스터는 <strong>샤딩</strong>(sharding, 대량의 데이터를 처리하기 위해 여러 개의 데이터베이스에 분할하는 기술) 방법을 제공하는 방법입니다.</li>\n<li>100개의 데이터를 1번 마스터에 33개, 2번 마스터 33개, 3번 마스터에 나머지 34개가 저장되는 방식입니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>Hash 함수</strong></p>\n<ul>\n<li>데이터를 나누는 방식은 키에 hash 함수를 적용해서 값을 추출하고, 이 값을 각 마스터 서버에 할당합니다.</li>\n<li>클러스터 구성시 해쉬 함수를 통해서 1~33까지를 1번 서버, 34~ 66번까지를 2번 서버, 3번 서버는 또 다르게 할당됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>해시 슬록(16384 슬롯)</strong></p>\n<ul>\n<li>레디스에서 hash 값의 개수는 16384(0~16383)이고 슬롯(slot)이라고 합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>해시 태그</strong></p>\n<ul>\n<li>다중 키 작업을 진행하려면 동일 노드에 저장될 모든 키가 필요합니다. 해시 태그는 레디스 클러스터에서 다중키를 사용할 수 있는 유일한 방법입니다.</li>\n<li>해시 함수를 적용해 동일한 해시 슬롯에 여러 개의 키 이름을 저장할 수 있도록 사용됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>레디스 클라이언트</strong></p>\n<ul>\n<li>클라이언트는 서버와 동일한 hash 함수를 가지고 있으며 마스터 서버에 접속해서 각 서버에 할당된 슬롯 정보를 가지고 있습니다.</li>\n<li>키가 입력되면 hash 함수를 적용해서 어느 마스터에 저장할지 판단해서 해당 마스터에 저장합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>데이터 서버 + 센티널</strong></p>\n<ul>\n<li>각 마스터 서버는 데이터의 처리와 센티널의 역할을 같이수행합니다.</li>\n<li>1번 마스터 서버가 다운되면 나머지 살아있는 마스터들 중에서 리더를 선출해서 리더가 1번 마스터의 슬레이브를 마스터로 승격시킵니다.</li>\n</ul>\n</li>\n<li>\n<p>최소 3대</p>\n<ul>\n<li>마스터 서버는 최소 3대로 구성하고 각각은 슬레이브를 가질 수 있습니다.</li>\n</ul>\n</li>\n<li>마스터를 관리하는 마스터는 없습니다. 이는 또 하나의 장애점입니다.</li>\n<li>레디스가 사용하는 포트는 2개이며 하나는 클라이언트 하나는 노드 간의 통신을 위한 버스로 사용됩니다.</li>\n</ul>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jyejye9201.medium.com/%EB%A0%88%EB%94%94%EC%8A%A4-redis-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-2b7af75fa818\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis란 무엇인가</a></li>\n<li><a href=\"https://docs.redis.com/latest/rs/concepts/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Concept</a></li>\n<li><a href=\"http://redisgate.kr/redis/configuration/redis_overview.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Architecture Overview</a></li>\n<li><a href=\"https://cla9.tistory.com/101\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis 구조</a></li>\n<li><a href=\"https://engkimbs.tistory.com/869\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">레디스 소개 및 아키텍처, 주의할 점</a></li>\n<li><a href=\"https://coding-start.tistory.com/128\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis - Cluster &#x26; Sentinel</a></li>\n<li><a href=\"https://redis.io/commands\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Command</a></li>\n<li><a href=\"https://redis.com/redis-enterprise/technology/redis-enterprise-cluster-architecture/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Enterprise Cluster Architecture</a></li>\n</ul>\n"}}]}}},"context":{}}