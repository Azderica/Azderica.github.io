{"hash":"409256f0cf4ba53e53b5c32326d49aab3f1f64f3","data":{"tag":{"title":"Architecture","belongsTo":{"edges":[{"node":{"title":"[Architecture] MSA : SAGA 패턴이란","path":"/01-architecture-msa/","date":"22. December 2020","timeToRead":7,"description":" SAGA 패턴에 대해 정리합니다.","content":"<h1 id=\"msa--saga-패턴의-정의과-종류\"><a href=\"#msa--saga-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A0%95%EC%9D%98%EA%B3%BC-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA : SAGA 패턴의 정의과 종류</h1>\n<p>이전에 MSA 개념에 대해 잡아보았습니다. 오늘은 MSA를 듣다보면 꼭 듣게 되는 SAGA 패턴에 대해 공부해보겠습니다.</p>\n<ul>\n<li><a href=\"https://azderica.github.io/00-architecture-msa/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MSA 개념 잡기</a></li>\n</ul>\n<br/>\n<h2 id=\"들어가기-앞서서\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%95%9E%EC%84%9C%EC%84%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>들어가기 앞서서.</h2>\n<p>기존의 Monolithic와 MSA 아키텍처에 대해서는 이전 게시글에서 정리했습니다. 오늘은 좀 더 MSA에 대해 이야기할려고 합니다. MSA 아키텍처를 구성하기 어려운 이유 중 하나는 <strong>트랜적션</strong> 의 문제입니다.</p>\n<p>기존의 Monolithic 환경에서는 DBMS가 기본적으로 제공해주는 트랜잭선 기능을 통해서 데이터 commit이나 rollback을 통해서 일관성있게 관리하였습니다. 그러나 Applcation 과 DB가 분산되면서 해당 트랜잭션 처리를 단일 DBMS에서 제공하는 기능으로는 해결할 수 없습니다.</p>\n<h3 id=\"대안--two-phase-commit\"><a href=\"#%EB%8C%80%EC%95%88--two-phase-commit\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>대안 : Two-Phase Commit?</h3>\n<p>여러 서비스 간에 데이터 일관성을 유지하기 위해서 전통적인 방법인 Two-Phase commit 과 같은 방법을 사용했습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102893652-4f8f0e00-44a5-11eb-9f1a-f4d3508e6c97.png\" alt=\"two-phase commit\"></p>\n<p>다만 이 방법은 하나의 서비스가 장애가 있는 경우나 각각의 서비스에 동시에 Rocking이 걸리게 되면 성능의 문제가 발생하기 때문에 비효율적입니다. 더나아가 각각의 서비스가 다른 instance에 있기 때문에 이를 통제하는데 어려움이 있습니다.</p>\n<blockquote>\n<p>트랜잭션이란?</p>\n</blockquote>\n<p>트랜잭션이란 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위를 의미합니다. 트랜잭션은 4가지의 특성(원자성, 일관성, 독립성, 지속성)을 지켜야합니다. 이에 대해 상세하게 다루기에는 주제에 너무 벗어난 주제이기 때문에 다른 게시글로 정리하겠습니다.</p>\n<br/>\n<h2 id=\"saga-패턴의-정의\"><a href=\"#saga-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>SAGA 패턴의 정의</h2>\n<p>위의 문제를 해결하기 위해서 SAGA 패턴이 등장했습니다.</p>\n<p>SAGA 패턴이란 <strong>마이크로서비스들끼리 이벤트를 주고 받아 특정 마이크로서비스에서의 작업이 실패하면 이전까지의 작업이 완료된 마이크서비스들에게 보상 (complemetary) 이벤트를 소싱함으로써 분산 환경에서 원자성(atomicity)을 보장</strong>하는 패턴입니다.</p>\n<p>이를 그림으로 표현하면 다음과 같습니다. SAGA 패턴의 이벤트 성공 시는 다음과 같이 동작합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102894284-33d83780-44a6-11eb-9cb0-1c526edd5642.png\" alt=\"saga-pattern-success\"></p>\n<p>SAGA 패턴의 이벤트 실패 시는 다음과 같이 실패 이벤트를 주어 처리합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102894291-35a1fb00-44a6-11eb-93bf-2371f322c99c.png\" alt=\"saga-pattern-fail\"></p>\n<p>해당 SAGA 패턴의 핵심은 <strong>트랜잭션의 관리주체가 DBMS에 있는 것이 아닌 Application</strong>에 있습니다. Application이 분산되어 있을때는 각 Applicatin은 하위에 존재하는 DB는 local 트랜잭션만 담당합니다.</p>\n<p>즉, 각각의 Application의 트랜잭션 요청의 실패로 인한 Rollback 처리(보상 트랜잭션)은 Application에서 구현합니다. </p>\n<p>이러한 과정을 통해서 순차적으로 트랜잭션이 처리되며, 마지막 트랜잭션이 끝났을 때 데이터가 완전히 영속되었음을 확인하고 종료합니다. 이 방법을 통해서 최종 일관성(Eventually Consistency)를 달성할 수 있습니다.</p>\n<br/>\n<h2 id=\"saga-패턴의-종류\"><a href=\"#saga-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>SAGA 패턴의 종류</h2>\n<p>일반적으로 SAGA 패턴은 크게 2가지로 나누어집니다. 하나는 <strong>Choreography based SAGA pattern</strong>이고 다른 하나는 <strong>Orchestration based SAGA pattern</strong>입니다.</p>\n<h3 id=\"choreography-based-saga-pattern\"><a href=\"#choreography-based-saga-pattern\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Choreography based SAGA pattern</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102895303-ccbb8280-44a7-11eb-8b80-8b87630db5f5.png\" alt=\"Choreography-Based Saga Success\"></p>\n<p>Choreography-based Saga 패턴은 보유한 서비스 내의 Local 트랜잭션을 관리하며 트랜잭션이 종료하게 되면 완료 Event를 발행합니다. 만약 그 다음 수행해야할 트랜잭션이 있으면 해당 트랜잭션을 수행해야하는 App으로 이벤트를 보내고, 해당 App은 완료 Event를 수신받고 다음 작업을 진행합니다. 이를 순차적으로 수행합니다. 이때 Event는 Kafka와 같은 메시지 큐를 통해서 비동기 방식으로 전달할 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102895310-cf1ddc80-44a7-11eb-9941-de72656dd3a8.png\" alt=\"Choreography-Based Saga Fail\"></p>\n<p>Choreography-base Saga 패턴에서는 각 App별로 트랜잭션을 관리하는 로직이 있습니다. 이를 통해서 중간에 트랜잭션이 실패하면 해당 트랜잭션 취소 처리를 실패한 App에서 보상 Event를 발행해서 Rollback 처리를 시도합니다.</p>\n<h4 id=\"장점\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>장점</h4>\n<ul>\n<li>구성하기 편합니다.</li>\n</ul>\n<h4 id=\"단점\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단점</h4>\n<ul>\n<li>운영자 입장에서 트랜잭션의 현재 상태를 확인하기 어렵습니다.</li>\n</ul>\n<h3 id=\"orchestration-based-saga-pattern\"><a href=\"#orchestration-based-saga-pattern\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Orchestration based SAGA pattern</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102895290-c927fb80-44a7-11eb-88ee-8f08ec4b2c21.png\" alt=\"Orchestration-Based Saga Success\"></p>\n<p>Orchestration-Based Saga 패턴은 트랜잭션 처리를 위해 Saga 인스턴스(Manager)가 별도로 존재합니다. 트랜잭션에 관여하는 모든 App은 Manager에 의해 점진적으로 트랜잭션을 수행하며 결과를 Manager에게 전달하게 되고, 비지니스 로직상 마지막 트랜잭션이 끝나면 Manager를 종료해서 전체 트랜잭션 처리를 종료합니다. 만약 중간에 실패하게 되면 Manager에서 보상 트랜잭션을 발동하여 일관성을 유지합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102895323-d47b2700-44a7-11eb-9bc1-2c46cf517c06.png\" alt=\"Orchestration-Based Saga Fail\"></p>\n<p>해당 Orchestration-Based Saga 패턴은 모든 관리를 Manager가 호출하기 때문에 분산트랜잭션의 중앙 집중화가 이루어집니다.</p>\n<h4 id=\"장점-1\"><a href=\"#%EC%9E%A5%EC%A0%90-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>장점</h4>\n<ul>\n<li>서비스간의 복잡성이 줄어들어서 구현 및 테스트가 쉬워집니다.</li>\n<li>트랜잭션의 현재 상태를 Manager가 알고 있으므로 롤백을 하기 쉽습니다.</li>\n</ul>\n<h4 id=\"단점-1\"><a href=\"#%EB%8B%A8%EC%A0%90-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단점</h4>\n<ul>\n<li>관리를 해야하는 Orchestrator 서비스가 추가되어야하기 때문에 인프라 구현이 복잡해집니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리</h2>\n<p>MSA 아키텍처 중 가장 유명한 SAGA 패턴에 대해 알아보았습니다. 다만 항상 SAGA 패턴이 좋다고는 볼 수 없습니다. 비지니스 로직상 트랜잭션 처리가 반드시 필요한 경우에만 사용하는 것이 좋습니다. 그렇지 않으면 여러곳에서 트랜잭션 처리 지옥을 경험할 수 있기 때문에 필요한 곳에서만 사용할 수 있도록 비지니스 로직을 설계하고 사용하는 것이 좋습니다.</p>\n<p>다음 게시글에서는 CQRS 패턴에 대해서 정리해보겠습니다. 감사합니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jjeongil.tistory.com/1100\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://jjeongil.tistory.com/1100</a></li>\n<li><a href=\"https://cla9.tistory.com/22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cla9.tistory.com/22</a></li>\n<li><a href=\"https://velog.io/@dvmflstm/SAGA-pattern%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@dvmflstm/SAGA-pattern%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0</a></li>\n<li><a href=\"https://ichi.pro/ko/maikeulo-seobiseu-akitegcheo-saga-paeteon-ilan-mueos-imyeo-eolmana-jung-yohabnikka-94512583990635\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ichi.pro/ko/maikeulo-seobiseu-akitegcheo-saga-paeteon-ilan-mueos-imyeo-eolmana-jung-yohabnikka-94512583990635</a></li>\n</ul>\n"}},{"node":{"title":"[Architecture] MSA 개념 잡기","path":"/00-architecture-msa/","date":"21. December 2020","timeToRead":4,"description":" 마이크로 서비스 아키텍처에 대한 개념을 정리합니다 ","content":"<h1 id=\"microservice-architecture\"><a href=\"#microservice-architecture\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Microservice Architecture</h1>\n<p>크게 아키텍처는 Monolithic Architecture과 Microservice Architecture 등으로 구성됩니다. 그러나 많은 회사들이 Monolithic 아키텍처의 단점으로 인해 MSA 아키텍처로 넘어가기 위해 노력하려고 합니다. 오늘은 그 차이에 대해 정리하고, 그 개념에 대해 정리해볼려고 합니다.</p>\n<br/>\n<h2 id=\"msa의-등장\"><a href=\"#msa%EC%9D%98-%EB%93%B1%EC%9E%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 등장</h2>\n<p>MSA는 microservice architecture의 약자로서, <strong>하나의 큰 어플리케이션을 여러개의 작은 어플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처</strong> 입니다.</p>\n<h3 id=\"기존-monolithic의-한계\"><a href=\"#%EA%B8%B0%EC%A1%B4-monolithic%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>기존 Monolithic의 한계</h3>\n<blockquote>\n<p>왜 필요할까요?</p>\n</blockquote>\n<p>기존의 서비스는 Monolithic Architecture의 구조를 가지고 있었습니다. </p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102787038-cebc0d80-43e3-11eb-9a67-829adb6ebe51.png\" alt=\"monolithic-vs-msa\"></p>\n<p>Monolithic Architecture은 소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어 있는 서비스입니다. 현재 많은 회사들의 소프트웨어가 <strong>레거시</strong> 또는 필요로 인해서 Monolithic 형태로 구현되어 있습니다.</p>\n<p>소규모의 프로젝트에서는 Monolithic 형태는 간단하며, 유지보수가 편하기 때문에 선호됩니다.</p>\n<p>그러나 일정 규모 이상을 넘어가면 Monolithic은 많은 한계점에 봉착합니다.</p>\n<ul>\n<li>전체 시스템 구조 파악의 문제</li>\n<li>빌드 시간 및 테스트, 배포 시간의 급증</li>\n<li>서비스의 특정 부분만 scale-out을 하기 어렵습니다.</li>\n<li><strong>부분의 장애가 전체 서비스의 장애로 이어질 수도 있습니다.</strong></li>\n</ul>\n<p>이러한 이유로 인해서, MSA가 등장하게 되었습니다.</p>\n<br/>\n<h2 id=\"msa의-정의\"><a href=\"#msa%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 정의</h2>\n<p>MSA의 핵심은 <strong>small services, each running in its own process</strong> + <strong>independently deployable</strong> 으로 표현할 수 있습니다.</p>\n<p>이를 번역한다면, <strong>스스로 돌아갈 수 있는 서비스</strong>와 <strong>독립적인 배포 기능</strong>입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102787740-e8118980-43e4-11eb-8760-c52424630810.png\" alt=\"architecture-diff\"></p>\n<p>soa를 추가해서 좀 더 자세하게 보자면.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102787984-4474a900-43e5-11eb-8a27-4e60f3aecfca.png\" alt=\"architecture-diff-2\"></p>\n<p>다음과 같이 구성됩니다.</p>\n<br/>\n<h2 id=\"msa의-장단점\"><a href=\"#msa%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 장단점</h2>\n<h3 id=\"msa의-장점\"><a href=\"#msa%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 장점</h3>\n<h4 id=\"1-배포\"><a href=\"#1-%EB%B0%B0%ED%8F%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 배포</h4>\n<ul>\n<li>서비스 별 개별 배포가 가능합니다. (배포 시 전체 서비스의 중단이 없습니다.)</li>\n<li>요구사항을 반영하여 빠르게 배포 가능합니다.</li>\n</ul>\n<h4 id=\"2-확장\"><a href=\"#2-%ED%99%95%EC%9E%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 확장</h4>\n<ul>\n<li>특정 서비스에 대한 확장성이 유리합니다. (scale-out)</li>\n<li>클라우드 사용 시 적합합니다.</li>\n</ul>\n<h4 id=\"3-장애-해결error-handling\"><a href=\"#3-%EC%9E%A5%EC%95%A0-%ED%95%B4%EA%B2%B0error-handling\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 장애 해결(Error Handling)</h4>\n<ul>\n<li>일부 장애가 전체 서비스로 확장될 가능성이 적습니다.</li>\n<li>부분적으로 발생하는 장애에 대해 격리가 수월합니다.</li>\n</ul>\n<h4 id=\"4-그-외\"><a href=\"#4-%EA%B7%B8-%EC%99%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>4. 그 외</h4>\n<ul>\n<li>새로운 기술을 적용하기 유연합니다.</li>\n<li>서비스를 polyglot(여러 언어를 사용하여)하게 개발 및 운영할 수 있습니다.</li>\n</ul>\n<h3 id=\"msa의-단점\"><a href=\"#msa%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 단점</h3>\n<h4 id=\"1-성능-이슈\"><a href=\"#1-%EC%84%B1%EB%8A%A5-%EC%9D%B4%EC%8A%88\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 성능 이슈</h4>\n<ul>\n<li>서비스 간 호출 시 API를 사용하므로, 통신 비용이나 Latency에 대해 이슈가 존재합니다. 다만 일반적으로 Monolithic에서 MSA로 넘어오는 이유가 Monolithic으로 더이상 성능적인 한계에 봉착했을 때 넘어오는 느낌이 있습니다...</li>\n<li>최근 우아한 테크 컨퍼런스에서는 이벤트 발행을 통해서 해당 부분을 해결했다고 했는데 이부분은 한번 참고해서 보면 좋을 듯 합니다.</li>\n</ul>\n<h4 id=\"2-테스트--트랜잭션\"><a href=\"#2-%ED%85%8C%EC%8A%A4%ED%8A%B8--%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 테스트 / 트랜잭션</h4>\n<ul>\n<li>서비스가 분리되어 있어 테스트와 트랜잭션의 복잡도가 증가합니다.</li>\n<li>많은 자원이 필요합니다.</li>\n</ul>\n<h4 id=\"3-데이터-관리\"><a href=\"#3-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 데이터 관리</h4>\n<ul>\n<li>데이터가 여러서비스에 분산되어 조회하기 어렵습니다.</li>\n<li>데이터를 관리하기 어렵습니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간단하게 MSA에 대해 개념을 잡았습니다. 다음에는 이 MSA에 대한 개념을 바탕으로 SAGA 패턴과 CQRS 패턴에 대해 작성하겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e</a></li>\n<li><a href=\"https://www.samsungsds.com/kr/insights/msa.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.samsungsds.com/kr/insights/msa.html</a></li>\n</ul>\n"}},{"node":{"title":"[Architeture] 서버리스 아키텍처에 대한 기초 지식","path":"/00-architecture-serverless/","date":"25. November 2020","timeToRead":13,"description":" 서버리스와 서버 아키텍처에 대한 기본 내용을 정리한 글입니다. ","content":"<h1 id=\"서버리스-아키텍처에-대하여\"><a href=\"#%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서버리스 아키텍처에 대하여</h1>\n<p>회사에서 개발과 관련해서 이야기를 하는데, CaaS, FaaS, BaaS 등에 대한 이야기를 듣게 되었다. 생각해보니 이름만 들어보고 한 번도 제대로 알아본적이 없어서 이번기회에 정리합니다.</p>\n<p>서버리스(Serverless)란 말 그대로 서버가 없다는 의미는 아닙니다. 다만, 특정 작업을 수행하기 위해서 컴퓨터 혹은 가상머신에 서버를 설정할 필요없이 다른 서비스(BaaS, FaaS) 등에 의존해서 작업을 처리합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100229273-5474a680-2f67-11eb-8a3a-467c9f409a72.png\" alt=\"image\"></p>\n<blockquote>\n<p>들어가기에 앞서서 간단한 발전 과정은 다음과 같습니다.</p>\n</blockquote>\n<p><br/>></p>\n<h2 id=\"기존-애플리케이션\"><a href=\"#%EA%B8%B0%EC%A1%B4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>기존 애플리케이션</h2>\n<h3 id=\"1-자체-설계\"><a href=\"#1-%EC%9E%90%EC%B2%B4-%EC%84%A4%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 자체 설계</h3>\n<p>시스템에서 필요한 모든 인프라를 직접 관리합니다. 기존의 <strong>전산실</strong>로 이해하면 됩니다.</p>\n<ul>\n<li>필요한 모든 인프라를 직접 관리. 예를 들어 기업 전산실에서 서버 및 하드웨어, 네트워크, 운영체제 등을 갖추어 모두 직접 처리해야합니다.</li>\n<li>시스템이 커질 수록 유지할 관리자가 필요하고, 이에 따른 비용이 발생합니다.</li>\n</ul>\n<h3 id=\"2-iaasinfrastructure-as-a-service\"><a href=\"#2-iaasinfrastructure-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. IaaS(Infrastructure as a Service)</h3>\n<p>AWS, Azure 등의 서비스에서 제공하는 서비스입니다. 서버자원, 네트워크, 전력 등의 인프라를 직접 구축할 필요없이 이러한 <strong>인프라를 가상화</strong>하여 관리하기 쉽게 해주는 서비스를 제공합니다.</p>\n<p>사용자는 해당 서비스를 통해서 관리자패널에서 인프라를 구성하면 됩니다. 사용자는 가상머신을 만들고 네트워크를 설정하고, 하드웨어를 설정하고, 운영체제를 설치해서 애플리케이션을 구동합니다.</p>\n<h3 id=\"3-paasplatform-as-a-service\"><a href=\"#3-paasplatform-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. PaaS(Platform as a Service)</h3>\n<p>IaaS에서 좀 더 추상화된 모델입니다. 네트워크, OS, 런타임을 제공합니다. 사용자는 애플리케이션만 배포하면 바로 구동할 수 있습니다. 또한 Auto Scaling 및 Load Balacing도 손쉽게 적용가능합니다.</p>\n<p>예시로는 다음과 같습니다.</p>\n<ul>\n<li>AWS Elastic Beanstalk, Azure App Servies 등등</li>\n</ul>\n<br/>\n<h2 id=\"servless\"><a href=\"#servless\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Servless</h2>\n<ul>\n<li>서버리스는 애플리케이션 개발자가 서버를 프로비저닝하거나 애플리케이션의 확장을 관리할 필요가 없습니다.</li>\n</ul>\n<blockquote>\n<p>프로비저닝(Provisioning) : 사용자의 요구에 맞게 시스템을 할당하고 배치, 배포한 이후 필요시에 시스템을 즉시 사용할 수 있는 상태로 미리 준비해놓는 것입니다.</p>\n</blockquote>\n<ul>\n<li>서버가 없다는 뜻은 아니며, 작업을 처리하는 서버는 있지만 서버를 관리할 필요가 없습니다.</li>\n<li>대표적으로 <strong>BaaS</strong> 와 <strong>FaaS</strong>로 나눠집니다.</li>\n</ul>\n<h3 id=\"1-baasbackend-as-a-service\"><a href=\"#1-baasbackend-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. BaaS(Backend as a Service)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100353200-82beb880-3031-11eb-89d9-5a361d5f88c4.png\" alt=\"image\"></p>\n<ul>\n<li>애플리케이션에서 일반 사용자가 보는 영역은 프론트엔드, 관리자가 보는 영역은 백엔드로 불립니다. <strong>이때 BaaS는 백엔드인 관리자 영역을 모듈화하여 서비스</strong>로 제공합니다.</li>\n<li>백엔드 개발(데이터 저장, 다른 기기로 접근, 파일 공유 등)이 필요한 경우, 개발자가 이러한 모든 서비스를 구축하기 어려워서, BaaS를 통해서 개발 시간을 단축합니다.</li>\n<li>IaaS, PaaS가 서버 인프라를 대체하는 정도였다면, <strong>BaaS와 FaaS는 서버 운영까지 맡기는 서비스</strong>입니다.</li>\n<li>대표적인 서비스로는 <strong>Firebase</strong>가 있습니다.</li>\n</ul>\n<p><strong>장점</strong></p>\n<ul>\n<li>개발 시간의 단축</li>\n<li>서버 확장의 불필요함</li>\n<li>백엔드에 대한 지식이 부족하더라도 빠른 속도로 개발이 가능</li>\n<li>토이 프로젝트, 소규모 프로젝트에서는 백엔드로 유용하게 사용가능</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>\n<p>클라이언트 위주의 코드</p>\n<ul>\n<li>백엔드 로직이 클라이언트 쪽에 구현됨 (보안 등의 큰 이슈)</li>\n<li>Firebase SDK를 통해 서버쪽에서 개발할 수 있지만, 이보다는 직접 구현이 좋습니다.</li>\n<li>데이터단의 로직이 변경되면 클라이언트 코드 수정이 이루어집니다.</li>\n</ul>\n</li>\n<li>\n<p>가격</p>\n<ul>\n<li>Firebase의 경우 초반에는 무료이지만, 앱의 규모가 커지면 비싸집니다.</li>\n<li>서비스 규모가 늘어날 수록 직접 구현의 장점이 가능합니다.</li>\n</ul>\n</li>\n<li>\n<p>복잡한 쿼리가 불가능함</p>\n<ul>\n<li>Firebase는 데이터 베이스가 하나의 큰 Json 형식으로 구조화 되어 있습니다. </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-faasfunction-as-a-service\"><a href=\"#2-faasfunction-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. FaaS(Function as a Service)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100354291-468c5780-3033-11eb-8d18-e6b0ba4fdf20.png\" alt=\"image\"></p>\n<ul>\n<li>코드, <strong>함수</strong>를 서비스로 제공합니다. 애플리케이션 개발에서 함수를 실행하기 위해 서버를 올리고 런타임을  구성하고 코드를 배포해서 실행해야 하는 일련의 과정을 없애고 원하는 로직을 함수로 등록만 해놓으면 특정 이벤트시 함수가 실행되고 종료됩니다.</li>\n<li>서버가 계속 대기하면서 사용자의 요청하는 것이 아니라, 이벤트가 발생했을 때만 함수가 실행되기 때문에 함수가 실행되는 시간 및 호출된 횟수만큼만 비용을 지불합니다.</li>\n<li>PaaS의 경우는 전체 애플리케이션을 배포하여 서버에서 애플리케이션이 계속 돌아가지만, FaaS는 애플리케이션을 더 작게 쪼갠 함수를 배포하며, 특정 이벤트가 발생했을 때만 실행되고 종료됩니다.</li>\n<li>주로 서비스 사이의 간단한 작업을 처리하는 용도로 쓰이며, BaaS와 결합해서 사용하기 좋습니다. 대표적인 예시로는 AWS Lambda, 구글의 Knative, Nuclio 등이 있습니다.</li>\n</ul>\n<p><strong>장점</strong></p>\n<ul>\n<li>\n<p>비용</p>\n<ul>\n<li>특정 작업을 하기위해 서버를 준비하고 켜놓는 것이 아니라면, 필요시만 호출되기 때문에 많은 비용을 절감할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>인프라 관리</p>\n<ul>\n<li>네트워크, 장비 등에 대해 신경쓸 필요가 없습니다.</li>\n</ul>\n</li>\n<li>\n<p>인프라 보안</p>\n<ul>\n<li>리눅스 업데이트, 취약점 보안 패치 등에 큰 신경을 쓰지 않다도 됩니다.</li>\n</ul>\n</li>\n<li>\n<p>확장성</p>\n<ul>\n<li>확장성에서 굉장히 유연합니다. (AutoScaling 등의 필요없습니다. 그저 호출만 될뿐...)</li>\n</ul>\n</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>\n<p>제한</p>\n<ul>\n<li>함수에서 사용할 수 있는 자원의 제한이 존재합니다.</li>\n<li>웹소켓과 같이 계속 켜놓는 것은 사용하기 힘듭니다.</li>\n</ul>\n</li>\n<li>제공사에 대한 강한 의존</li>\n<li>\n<p>로컬 데이터 사용 불가능</p>\n<ul>\n<li>함수들은 무상태이기 때문에 이 데이터를 로컬 스토리지에 쓸수없습니다. (물론, AWS는 S3, Azure는 Storage를 사용 가능합니다.)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-정리\"><a href=\"#3-%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 정리</h3>\n<p>Serverless의 특징은 다음과 같습니다.</p>\n<ul>\n<li>\n<p>Cold Start</p>\n<ul>\n<li>클라우드 업체는 자원을 효율적으로 관리하기 위해 일정 기간 행위가 없는 사용자에게는 컴퓨팅 파워를 제공하지않습니다.</li>\n<li>비활성 함수가 갑자기 호출되면 서버가 준비되는 지연 시간이 발생하여 애플리케이션 성능에 영향을 줄 수도 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>Stateless</p>\n<ul>\n<li>함수가 없는 경우에는 모든 리소스 종류가 존재하지 않습니다.</li>\n<li>세션을 보존해야하는 경우에는 DB에 저장하는 것이 좋습니다.</li>\n</ul>\n</li>\n<li>\n<p>일시적 컨테이너</p>\n<ul>\n<li>특정 이벤트가 발생하는 일정 기간 동안에만 컨테이너에 배포되고, 그 이후는 자원이 없습니다.</li>\n<li><strong>큰 요구사항이 필요한 경우에는 적합하지 않습니다.</strong></li>\n</ul>\n</li>\n<li>\n<p>언어지원</p>\n<ul>\n<li>AWS Lambda: Node.js, Python, Java, C#, Go</li>\n<li>MS Azure: C#, Javascript, F#, Python, Batch, PHP, PowerShell</li>\n<li>Google Function: Node.js, Python, Javascript</li>\n</ul>\n</li>\n<li>\n<p>NoSQL</p>\n<ul>\n<li>함수는 제한된 데이터베이스 색인(Index)을 구성하기 때문에 서버리스 아키텍처에서 관계형 데이터베이스를 사용하면 동시 연결 수 제한으로 확장성과 성능 문제가 발생합니다.</li>\n<li>따라서 RDBMS 보다는 <strong>NoSQL</strong>이 적합합니다.</li>\n</ul>\n</li>\n</ul>\n<p>그러나. 현재는 Stateless, 일시적 컨테이너에 따른 특징으로 인해 <strong>큰 프로젝트에는 적합하지 않습니다.</strong></p>\n<br/>\n<h2 id=\"그-외\"><a href=\"#%EA%B7%B8-%EC%99%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>그 외.</h2>\n<h3 id=\"1-caascontainer-as-as-service\"><a href=\"#1-caascontainer-as-as-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. CaaS(Container as as Service)</h3>\n<p>컨테이너 기반 추상화를 통해 사용자가 애플리케이션을 배포하고 관리하도록 지원하는 클라우드 서비스 컴퓨팅 모델입니다. 제공없체는 컨테이너가 배포 및 관리되는 프레임워크 또는 오케스트레이션 플랫폼을 제공합니다.</p>\n<blockquote>\n<p>오케스트레이션(orchestration)이란?</p>\n<ul>\n<li>Container orchestration이란 컨테이너의 배포, 관리, 확장 및 네트워킹을 자동화합니다.</li>\n</ul>\n</blockquote>\n<p>클라우드 서비스의 범위에서 CaaS는 IaaS의 하위집합으로 간주되며 I<strong>aaS와 서비스 플랫폼인 PaaS 사이</strong>에 존재한다고 이해하면 됩니다.</p>\n<p>컨테이너를 사용하므로 다음과 같은 특징을 가집니다.</p>\n<ul>\n<li>이식성 : private, public 등의 다양한 환경에서 배포가능</li>\n<li>확장성 : 컨테이너의 수를 늘려서 확장할 수 있습니다.</li>\n<li>효율성 : 컨테이너는 별도의 운영체제가 필요없으므로 가상 머신(VM)보다 리소스가 적게 필요합니다.</li>\n<li>보안강화 : 컨테이너는 격리되어 있으므로 다른 컨테이너에 영향을 주지 않습니다.</li>\n<li>속도 : 운영 체제에 구애받지 않기 때문에 시작과 종료시간이 짧습니다.</li>\n</ul>\n<p>이와 같은 환경에서는 <strong>쿠버네티스</strong>를 사용하는 것이 좋습니다.</p>\n<p>쿠버네티스에 대한 간단한 정리는 아래의 링크를 보시면 좋을 듯합니다.</p>\n<p>: <a href=\"https://azderica.github.io/backend/2020/11/10/backend-kubernetes-study/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">쿠버네티스란?</a></p>\n<h3 id=\"2dbaasdatabase-as-a-service\"><a href=\"#2dbaasdatabase-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2.DBaaS(Database as a Service)</h3>\n<p>DBaaS는 <strong>클라우드 아키텍처</strong>로서 데이터베이스 서비스 프로바이더가 하나 아싱의 서비스 소비자에게 데이터베이스 서비스를 제공하는 아키텍처, 운영 전략입니다.</p>\n<p>다음과 같은 요구사항을 만족합니다.</p>\n<ul>\n<li>리소스의 빠른 제공 및 Self-Service 동작, 데이터베이스 관리</li>\n<li>데이터베이스 서비스 사용량에 기반한 Show-back 리포트와 Charge-back 기능을 제공합니다.</li>\n</ul>\n<p>이러한 특성을 바탕으로 DBaaS는 클라우드 서비스를 통해 자원의 탄력적인 운용과 확장가능, 자동화된 자원 관리, 용량 설정 및 설계의 기능을 제공합니다.</p>\n<p>이러한 기능은 다음의 장점을 가집니다.</p>\n<ul>\n<li>비용절감</li>\n<li>\n<p>서비스 수준향상</p>\n<ul>\n<li>Self-Service Provising, 관리</li>\n<li>미리 약속된 서비스 정의</li>\n<li>Metering 및 Chargeback을 통한 IT 비용 및 활용도 측정 가능</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"정리\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>정리.</h2>\n<p>간단하게 서버리스 아키텍처에 대해 정리하였습니다. 흔히 듣던, IaaS, BaaS, PaaS, FaaS에 대해 간단하게 정리해보았고, 최근에 들었던 CaaS에 대해서도 간단하게 조사했습니다.</p>\n<p>이후 부족한 내용이나 보완되어야하는 내용이 있다면 편하게 이야기주세요.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://velopert.com/3543\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velopert.com/3543</a></li>\n<li><a href=\"https://stonesteel1023.github.io/TIL181109/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://stonesteel1023.github.io/TIL181109/</a></li>\n<li><a href=\"https://m.blog.naver.com/PostView.nhn?blogId=shakey7&#x26;logNo=221739057486&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.blog.naver.com/PostView.nhn?blogId=shakey7&#x26;logNo=221739057486&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F</a></li>\n<li><a href=\"https://www.redhat.com/ko/topics/cloud-computing/what-is-caas\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/cloud-computing/what-is-caas</a></li>\n</ul>\n"}}]}}},"context":{}}