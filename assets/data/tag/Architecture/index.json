{"hash":"314c4422387ef2cae421ff768d6b6746d38a40d1","data":{"tag":{"title":"Architecture","belongsTo":{"edges":[{"node":{"title":"[DB] Couchbase의 개념과 특징, 아키텍처","path":"/02-db-nosql-couchbase/","date":"20. September 2021","timeToRead":11,"description":"Nosql 중 Couchbase에 대해 좀 더 자세하게 알아봅니다.","content":"<h1 id=\"couchbase를-좀-더-자세하게\"><a href=\"#couchbase%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase를 좀 더 자세하게</h1>\n<p>지난 게시글은 다음과 같습니다.</p>\n<ul>\n<li><a href=\"https://azderica.github.io/00-db-nosql/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL</a></li>\n<li><a href=\"https://azderica.github.io/01-db-nosql-redis/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis</a></li>\n</ul>\n<p>오늘은 Couchbase 개념입니다.</p>\n<h2 id=\"couchbase-개념\"><a href=\"#couchbase-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase 개념</h2>\n<ul>\n<li>카우치 베이스는 Document 기반의 Key-Value 스토어입니다.</li>\n<li>하나의 유니크(Unique)한 키에 값을 저장하는 방식이며, 저장되는 값은 JSON 도큐먼트가 저장됩니다.</li>\n<li>키(key)는 최대 <strong>250 바이트</strong>, 밸류(Value)는 카우치베이스 버킷은 20BMB, Memcached 방식의 버킷의 경우 1MB까지 저장이 됩니다.</li>\n</ul>\n<p>저장할 때, 키와 값 뿐만 아니라 메타데이터도 같이 저장되며 메타 데이터는 <code class=\"language-text\">CAS, TTL, Flag</code> 값 3가지가 저장됩니다.</p>\n<ul>\n<li><code class=\"language-text\">CAS</code> : 데이터에 대한 일종의 타임 스탬프와 같은 개념으로, 여러 클라이언트가 같이 데이터를 접근했을 때 일관성(Consistent) 문제를 해결해줍니다.</li>\n<li><code class=\"language-text\">TTL</code> : <code class=\"language-text\">Time To Live</code>, 데이터의 유효 시간을 정의합니다.</li>\n<li><code class=\"language-text\">FLAG</code> : 카우치베이스 클라이언트에서 사용하는 메타데이터입니다.</li>\n</ul>\n<p>이러한 메타데이터는 하나의 메타데이터(CAS, TTL, Flag)는 60바이트의 메모리를 차지하며, 카우치베이스 서버는 모든 키와 메타데이터를 유지하기 위해 용량을 설계할때, RAM의 사이즈를 결정합니다.</p>\n<h3 id=\"버킷bucket\"><a href=\"#%EB%B2%84%ED%82%B7bucket\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>버킷(Bucket)</h3>\n<ul>\n<li>일종의 RDBMS의 데이터베이스 같은 공간이며 JSON document 들은 이 버킷에 저장됩니다.</li>\n<li>각각의 버킷은 고유의 속성 값을 가지고 있습니다. 버킷별로 사용할 수 있는 메모리 양, 옵션으로 버킷별로 접근할 수 있는 TCP 포트, 접근 비밀번호, 버킷에 들어가는 데이터에 대한 복제본의 수 등을 정할 수 있습니다.</li>\n</ul>\n<h3 id=\"뷰view\"><a href=\"#%EB%B7%B0view\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>뷰(View)</h3>\n<ul>\n<li>카우치 베이스의 강력한 능력이며, 이 뷰를 통해서 <code class=\"language-text\">Indexing, grouping, sorting</code> 등이 가능합니다.</li>\n<li>뷰는 데이터베이스 뷰와 유사한 개념을 가지며 카우치베이스의 뷰는 incremental view라는 컨셉을 가집니다.</li>\n</ul>\n<p>다음의 예시를 보면 뷰의 기능의 동작을 예상할 수 있습니다. Json document 안에 주민번호있고, 80년생 이하만 저장하는 뷰를 만든다고 가정하면 데이터가 버킷에 저장될 때마다 생성된 뷰에 같이 저장됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133991552-ccead205-7fc2-4ed3-bc6a-7832eee5e241.png\" alt=\"couchbase-view-sample\"></p>\n<p>이와 같은 결과로 데이터를 저장하거나 업데이트시 뷰 코드가 매번 수행되고, 뷰코드에 저장된 알고리즘에 따라 뷰에 데이터를 업데이트합니다.</p>\n<p>이를 더 자세하게 보면 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133992279-e17df7a9-9369-459f-9b27-9a840b9edb14.png\" alt=\"Map &#x26; Reduce\"></p>\n<p><a href=\"https://bcho.tistory.com/928?category=534534\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">출처 및 뷰에 대한 상세 개념</a></p>\n<p><code class=\"language-text\">Map Function(Map &amp; Reduce)</code> 함수를 통해서 View를 만듭니다.</p>\n<ul>\n<li>맵함수는 두 개의 인자를 전달받으며 index(id, key, value)를 만들고 리듀스를 통해서 grouping이나 여러 처리를 할 수 있습니다.</li>\n<li>즉, <strong>뷰에는 각 버킷내의 개별 데이터를 반환하는 맵함수와 변환된 개별 데이터를 그룹별로 모아서 처리할 수 있는 리듀스 함수를 가집니다.</strong></li>\n</ul>\n<br/>\n<h2 id=\"couchbase-특징\"><a href=\"#couchbase-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase 특징</h2>\n<h3 id=\"memcached-기반의-level-2-캐쉬를-내장하여-빠릅니다\"><a href=\"#memcached-%EA%B8%B0%EB%B0%98%EC%9D%98-level-2-%EC%BA%90%EC%89%AC%EB%A5%BC-%EB%82%B4%EC%9E%A5%ED%95%98%EC%97%AC-%EB%B9%A0%EB%A6%85%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Memcached 기반의 Level 2 캐쉬를 내장하여 빠릅니다.</h3>\n<ul>\n<li>memcached를 자체적으로 Level 2 캐쉬로 사용합니다.</li>\n<li>자체적으로 메모리 캐쉬 기능을 가지고 있기 때문에 성능이 빠릅니다.</li>\n</ul>\n<p>(다만, 키의 유연성이나 클러스터에서 단점을 가집니다.)</p>\n<h3 id=\"모바일-디바이스와-sync\"><a href=\"#%EB%AA%A8%EB%B0%94%EC%9D%BC-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4%EC%99%80-sync\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>모바일 디바이스와 Sync</h3>\n<ul>\n<li>카우치디비 계열 DB들은 모바일 디바이스에 탑재할 수 있으며, 서버에 설치된 카우치베이스 계열과 Sync가 됩니다.</li>\n</ul>\n<h3 id=\"데이터-센터간-복제-기간\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%84%BC%ED%84%B0%EA%B0%84-%EB%B3%B5%EC%A0%9C-%EA%B8%B0%EA%B0%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>데이터 센터간 복제 기간</h3>\n<ul>\n<li>XDCR(Cross Data Center Replication)의 기능을 이용해서 물리적으로 떨어진 데이터 센터간에 복제가 가능합니다.</li>\n<li><a href=\"https://azderica.github.io/00-db-couchbase-xdcr/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">XDCR의 상세 내용</a></li>\n</ul>\n<h3 id=\"indexing-grouping-ordering-join-가능\"><a href=\"#indexing-grouping-ordering-join-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Indexing, Grouping, Ordering, Join 가능</h3>\n<ul>\n<li>대부분의 NoSQL은 Key/Value Store 형식으로, 개별 필드에 대한 Indexing이나 필드별로 group by를 통한 sum,count 등의 기능, 특정 필드별로의 Sorting이 불가능합니다.</li>\n<li>Indexing을 지원하는 경우도 있기는 하지만, 내부적으로 성능상 문제가 있는 경우가 많으나 카우치베이스는 그러한 문제가 없습니다.</li>\n</ul>\n<h3 id=\"확장이-쉬움\"><a href=\"#%ED%99%95%EC%9E%A5%EC%9D%B4-%EC%89%AC%EC%9B%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>확장이 쉬움</h3>\n<ul>\n<li>분산 구조의 NoSQL의 경우 노드확장이 어렵거나 장애처리가 어려운 경우가 많으나 카우치베이스는 손쉽게 확장을 하고 장애 처리를 합니다.</li>\n<li>이러한 장점은 운영에서 큰 이점이 됩니다.</li>\n</ul>\n<h3 id=\"built-in-관리-도구-제공\"><a href=\"#built-in-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC-%EC%A0%9C%EA%B3%B5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Built in 관리 도구 제공</h3>\n<ul>\n<li>카우치베이스는 웹 기반의 GUI 관리 도구를 기본으로 제공합니다.</li>\n</ul>\n<blockquote>\n<p>Couchbase Web Console</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133992009-871775fb-ac8f-4453-ad35-5ba7ba349d31.png\" alt=\"couchbase-web-console\"></p>\n<p><a href=\"https://soccerda.tistory.com/124\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">출처</a></p>\n<h3 id=\"memcached-프로토콜-지원\"><a href=\"#memcached-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Memcached 프로토콜 지원</h3>\n<ul>\n<li>캐쉬 솔루션으로 유명한 Memcached 르포토콜을 지원하기 때문에 Memcached 인프라를 사용할 수 있습니다.</li>\n</ul>\n<h3 id=\"스키마가-없는-유연한-저장-구조scheme-less\"><a href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88%EA%B0%80-%EC%97%86%EB%8A%94-%EC%9C%A0%EC%97%B0%ED%95%9C-%EC%A0%80%EC%9E%A5-%EA%B5%AC%EC%A1%B0scheme-less\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>스키마가 없는 유연한 저장 구조(Scheme-less)</h3>\n<ul>\n<li>스키마가 없으므로 하나의 테이블에 컬럼 형식이 다른 데이터를 넣을 수 있습니다.</li>\n<li>하나의 데이터 버킷에 데이타 구조가 다른 JSON 문서들을 넣을 수 있습니다.</li>\n<li>데이터 타입이 다름에도 불구하고 공통되는 필드에 대해 Indexing, grouping 등을 제공할 수 있으며 JSON 도큐먼트에 country 라는 앨리먼트가 있는 도큐먼트등을 대상으로 grouping등을 할수 있습니다.</li>\n</ul>\n<br/>\n<h2 id=\"couchbase-architecture\"><a href=\"#couchbase-architecture\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase Architecture</h2>\n<p>Couchbase Server는 모든 노드에 설치된 단일 패키지로 구성됩니다.</p>\n<h3 id=\"노드와-클러스터node--cluster\"><a href=\"#%EB%85%B8%EB%93%9C%EC%99%80-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0node--cluster\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>노드와 클러스터(Node &#x26; Cluster)</h3>\n<ul>\n<li>노드는 물리적인 서버에서 기동하는 하나의 카우치베이스 인스턴스</li>\n<li>카우치베이스는 여러 개의 노드로 이루어진 클러스터로 구성됩니다.</li>\n</ul>\n<h3 id=\"클라이언트-sdkclient-sdk\"><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-sdkclient-sdk\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>클라이언트 SDK(Client SDK)</h3>\n<ul>\n<li>프로그래밍 언어별로 카우치베이스에 접근하기 위한 API(SDK)를 제공합니다.</li>\n<li>SDK를 사용해서 선택한 언어(Java, node.js, .NET 등)으로 애플리케이션을 작성할 수 있습니다.</li>\n</ul>\n<h3 id=\"vbucket\"><a href=\"#vbucket\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>vBucket</h3>\n<ul>\n<li>카우치베이스는 실제 데이터와 물리서버간의 맵핑을 <code class=\"language-text\">vBucket</code>을 통해 관리합니다.</li>\n<li>카우치베이스는 키-밸류 스토어이며, 각 키가 어디있는지는 vBucket이라는 단위로 관리하고, 키에 대한 해쉬값을 계산한 후에 각 해쉬값에 따라서 저장되는 vBucket을 맵핑한다음 각 vBucket을 노드에 맵핑합니다.</li>\n<li><strong>Rebalancing</strong> : 노드가 추가되거나 삭제되었을 때, 물리적으로 데이터가 다른 노드로 다시 분산배치되고 새롭게 배치된 데이터에 따라 vBucket이 노드간에 데이터 맵핑 정보도 업데이트됩니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133996020-9ffb4d3d-9091-4e47-bb22-fdcf93baf961.png\" alt=\"vBucket\"></p>\n<h3 id=\"노드의-구조\"><a href=\"#%EB%85%B8%EB%93%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>노드의 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133996334-1d0c59e5-c7d7-48d9-a8a8-ea87bc0fed64.png\" alt=\"couchbase-node-detail\"></p>\n<ul>\n<li>Couchbase의 노드는 Data Manage과 Cluster Manager로 나눠집니다.</li>\n</ul>\n<h4 id=\"data-manager\"><a href=\"#data-manager\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Manager</h4>\n<ul>\n<li>직접 데이터에 접근하는 부분이며, set/get 메서드를 통한 데이터 저장이나 뷰에 대한 쿼리를 수행할 때 접근합니다.</li>\n<li><code class=\"language-text\">Multi Thread Persistence Engine</code> : 디스크에 데이터를 저장하거나 읽을 때 사용하는 컴포넌트입니다.</li>\n</ul>\n<h4 id=\"cluster-manager\"><a href=\"#cluster-manager\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cluster Manager</h4>\n<ul>\n<li>노드에 대한 상태와 클러스터에 대한 상태, 설정 등을 관리하는 부분이며 <code class=\"language-text\">Erlang/OTP</code>로 구성되어 있습니다.</li>\n<li>카우치베이스 클라이언트 SDK는 8091포트의 REST API를 통해서 vBucket 정보를 가져옵니다.</li>\n<li>다수의 포트 등을 사용합니다. (사용전에 열어야하는 포트들이 있습니다.)</li>\n</ul>\n<h3 id=\"데이터-쓰기와-복제\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%93%B0%EA%B8%B0%EC%99%80-%EB%B3%B5%EC%A0%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>데이터 쓰기와 복제</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133997054-0f325983-d6b6-4a10-b1e7-634de4a7e50b.png\" alt=\"couchbase-data-read/write\"></p>\n<ul>\n<li>클라이언트에서 Client SDK를 통해서 쓰기 요청을 하면, Client SDK는 해쉬 알고리즘에 따라 데이터의 키 값에 맵핑되는 vBucket을 찾아내고 그 해당하는 노드를 찾아 쓰기 요청을 합니다.</li>\n<li>쓰기 요청은 해당 노드의 Listener로 전달되고, 이 Listener는 들어온 데이터를 로컬의 캐쉬에 쓰고 클러스터의 다른 노드로 복제 요청을 보냅니다. 그리고 데이터는 노드의 디스크에 저장됩니다.</li>\n</ul>\n<br/>\n<h2 id=\"couchbase-cluster\"><a href=\"#couchbase-cluster\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase Cluster</h2>\n<ul>\n<li>Couchbase 클러스터는 각각 독립 노드에서 실행되는 하나 이상의 Couchbase Server 인스턴스로 구성됩니다.</li>\n<li>Couchbase Server를 실행하는 각 노드, 클러스터에 여러 노드가 있는 경우 Couchbase 클러스터 관리자는 각 노드에서 실행됩니다.</li>\n<li>클러스터의 전체 또는 일부 노드에서 실행되도록 서비스를 구성할 수 있습니다.</li>\n</ul>\n<h3 id=\"유혀성\"><a href=\"#%EC%9C%A0%ED%98%80%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>유혀성</h3>\n<ul>\n<li>데이터는 Couchbase Server에 의해 클러스터 전체에 자동으로 배포됩니다.</li>\n<li>Couchbase Server는 노드 추가 및 제거, 노드 장애를 자동으로 처리합니다.</li>\n</ul>\n<br/>\n<h2 id=\"couchbase-vs-mongodb\"><a href=\"#couchbase-vs-mongodb\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Couchbase VS MongoDB</h2>\n<p>공통점은 다음과 같습니다.</p>\n<ul>\n<li>Document 기반의 NoSQL입니다.</li>\n</ul>\n<p>그러나 차이점이 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>이름</th>\n<th>Couchbase</th>\n<th>MongoDB</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>설명</td>\n<td>Memcached 호환 인터페이스를 사용하여 CouchDB에서 파생된 JSON 기반 문서 저장소</td>\n<td>완전 관리형 클라우드 서비스와 자체 관리형, 인프라에 배포할 수 있는 가장 인기있는 문서 저장소 입니다.</td>\n</tr>\n<tr>\n<td>기본 데이터베이스 모델</td>\n<td>문서 저장소</td>\n<td>문서 저장소</td>\n</tr>\n<tr>\n<td>보조 데이터베이스 모델</td>\n<td>키-값 저장 공간 DBMS</td>\n<td>공간 DBMS</td>\n</tr>\n<tr>\n<td>스키마</td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>파티셔닝</td>\n<td>샤딩</td>\n<td>샤딩</td>\n</tr>\n</tbody>\n</table>\n<p>좀 더 자세한 차이를 알기 위해서는 다음 링크를 참고합니다.</p>\n<p><a href=\"https://db-engines.com/en/system/Couchbase%3BMongoDB\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Couchbase VS MongoDB</a></p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://bcho.tistory.com/924\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase 소개</a></li>\n<li><a href=\"https://bcho.tistory.com/925\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase 개념</a></li>\n<li><a href=\"https://bcho.tistory.com/928\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase view</a></li>\n<li><a href=\"https://bcho.tistory.com/934\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase architecture</a></li>\n<li><a href=\"https://docs.couchbase.com/server/5.0/architecture/architecture-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase architecture detail</a></li>\n<li><a href=\"https://docs.couchbase.com/server/current/learn/clusters-and-availability/clusters-and-availability.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase cluster</a></li>\n<li><a href=\"https://dzone.com/articles/introduction-to-couchbase-for-mongodb-developers-a-1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">couchbase vs mongodb</a></li>\n<li><a href=\"https://zepinos.tistory.com/60?category=797689\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">왜 Couchbase을 선택하게 되었는가 - 1</a></li>\n<li><a href=\"https://zepinos.tistory.com/61\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">왜 Couchbase을 선택하게 되었는가 - 2</a></li>\n<li><a href=\"https://docs.couchbase.com/couchbase-manual-2.5/cb-admin/#faqs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Couchbase Docs</a></li>\n</ul>\n"}},{"node":{"title":"[DB] Redis의 개념과 특징, 아키텍처","path":"/01-db-nosql-redis/","date":"17. September 2021","timeToRead":9,"description":"NoSQL 중 Redis에 대해 좀 더 자세하게 알아봅니다.","content":"<h1 id=\"redis를-좀-더-자세하게\"><a href=\"#redis%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis를 좀 더 자세하게.</h1>\n<p>지난번 게시글에서는 <a href=\"https://azderica.github.io/00-db-nosql/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NoSQL</a>에 대한 기본 개념과 종류에 대해서 정리했습니다.</p>\n<p>이번에는 더 나아가서 대표적인 NoSQL이 가지는 아키텍처를 정리합니다. 오늘은 Redis에 대해 좀 더 정리하려고합니다.</p>\n<h2 id=\"redis란\"><a href=\"#redis%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis란.</h2>\n<ul>\n<li>고 성능의 키-값 데이터 구조 스토어입니다.</li>\n<li>여러 자료구조를 지원하며 크게 <code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 등의 데이터 형식을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis-특징\"><a href=\"#redis-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 특징</h2>\n<ul>\n<li>\n<p>영속성을 지원하는 인메모리 데이터 저장소</p>\n<ul>\n<li>왜 영속성을 제공하는지는 아래에서 설명합니다.</li>\n</ul>\n</li>\n<li>\n<p>읽기 성능 증대를 위한 서버 측 복제를 지원합니다.</p>\n<ul>\n<li>전체 데이터베이스의 초기 복사본을 받는 마스터/슬레이브 복제를 지원합니다.</li>\n<li>마스터에서 쓰기가 수행되면 슬레이브 데이터 세트를 실시간으로 업데이터하기 위해 연결된 모든 슬레이브로 전송됩니다.</li>\n</ul>\n</li>\n<li>쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding)을 지원합니다.</li>\n<li><code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 과 같은 다양한 데이터형을 지원합니다.</li>\n</ul>\n<blockquote>\n<p>샤딩(Sharding)</p>\n</blockquote>\n<p>파티셔닝과 동일하며, 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미합니다.</p>\n<br/>\n<h2 id=\"redis-특징-1\"><a href=\"#redis-%ED%8A%B9%EC%A7%95-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 특징</h2>\n<h3 id=\"key-value-store\"><a href=\"#key-value-store\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Key-Value Store</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133774329-00ddf3c0-a24e-40b0-9dd8-460616ea5400.png\" alt=\"Redis-is-map\"></p>\n<ul>\n<li>Redis는 거대한 맵(Map) 데이터 저장소입니다.</li>\n<li>Redis는 익히기 쉬우며 직관적입니다. 그러나, 데이터를 레디스 자체 내에서는 처리하기 어렵습니다.</li>\n</ul>\n<h3 id=\"다양한-데이터-타입\"><a href=\"#%EB%8B%A4%EC%96%91%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>다양한 데이터 타입</h3>\n<ul>\n<li><code class=\"language-text\">String, Set, Sorted Set, Hash, List</code> 등의 타입을 지원합니다.</li>\n</ul>\n<h3 id=\"persistence\"><a href=\"#persistence\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Persistence</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133775761-c7644499-ae6f-4aa8-bd25-8208780c41e0.png\" alt=\"Redis-Persistence\"></p>\n<ul>\n<li>Redis는 영속성을 가집니다.</li>\n<li>Redis는 데이터를 disk에 저장할 수 있습니다. 따라서 Redis는 서버가 강제 종료되고 재시작하더라도 disk에 저장해놓은 데이터를 다시 읽어서 데이터가 유실되지 않습니다.</li>\n<li>\n<p>redis의 데이터를 disk에 저장하는 방식은 <strong>snapshot, AOF</strong> 방식이 있습니다.</p>\n<ul>\n<li><code class=\"language-text\">Snapshot</code> : RDB와 비슷하게 어떤 특정 시점의 데이터를 Disk에 담는 방식을 뜻합니다. <strong>Blocking</strong> 방식의 <strong>SAVE</strong>와 <strong>Non-blocking</strong> 방식의 <strong><a href=\"http://redisgate.kr/redis/server/bgsave.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">BGSAVE</a></strong> 방식이 있습니다.</li>\n<li><code class=\"language-text\">AOF</code> : Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태입니다. 서버가 재시작 시 write/update를 순차적으로 재실행하고 데이터를 복구합니다.</li>\n<li>가장 좋은 방식은 두 방법을 혼용해서 사용하는 방법으로 주기적으로 snapshot으로 백업을 하고 다음 snapshot까지의 저장을 AOF 방식으로 수행하는 방식입니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ansi-c로-작성\"><a href=\"#ansi-c%EB%A1%9C-%EC%9E%91%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ANSI C로 작성</h3>\n<ul>\n<li>C언어로 작성되어 Java와 같이 가상머신 위에서 동작하는 언어에서 발생하는 성능 문제에서 자유롭습니다.</li>\n</ul>\n<h3 id=\"서버측-복제-및-샤딩-지원\"><a href=\"#%EC%84%9C%EB%B2%84%EC%B8%A1-%EB%B3%B5%EC%A0%9C-%EB%B0%8F-%EC%83%A4%EB%94%A9-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서버측 복제 및 샤딩 지원</h3>\n<ul>\n<li>읽기 성능 증대를 위해 서버 측 복제를 지원합니다.</li>\n<li>쓰기 성능 증대를 위해 클라이언트 측 샤딩을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis의-장점\"><a href=\"#redis%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis의 장점</h2>\n<ul>\n<li>리스트, 배열과 같은 데이터를 처리하는데 유용합니다.</li>\n<li>Message Queue, Shared Memory, Remote Dictionary(RDBMS의 캐시 솔루션 / read 속도가 매우 빠릅니다.) 용도로 사용됩니다.</li>\n<li>메모리를 활용하면서 데이터를 보존합니다.</li>\n<li>Redis Server는 1개의 싱글 쓰레드로 수행되며, 서버 하나에 여러개의 서버를 띄우는 것이 가능합니다.</li>\n</ul>\n<br/>\n<h2 id=\"redis-아키텍처-구성\"><a href=\"#redis-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 아키텍처, 구성</h2>\n<ul>\n<li>HA(High Availability) : 무중단 서비스 등</li>\n</ul>\n<h3 id=\"standalone--no-ha-마스터\"><a href=\"#standalone--no-ha-%EB%A7%88%EC%8A%A4%ED%84%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Standalone : No HA, 마스터</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133778042-cf59f712-752a-4c61-8a1a-b9ac435726a1.png\" alt=\"Redis-Standalone\"></p>\n<ul>\n<li>레디스 서버 1대로 구성하며 이를 마스터 노드라고 합니다.</li>\n<li>서버 다운시 AOF 또는 Snapshot 파일을 이용해 재 시작합니다.</li>\n</ul>\n<h3 id=\"replication--half-ha-마스터-슬레이브\"><a href=\"#replication--half-ha-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%8A%AC%EB%A0%88%EC%9D%B4%EB%B8%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Replication : Half HA, 마스터-슬레이브</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133778753-41bfa929-aa5f-48e5-9509-7e4df1379baa.png\" alt=\"Redis-Replication\"></p>\n<ul>\n<li>레디스 서버 2대(마스터-슬레이브)로 구성됩니다. 슬레이브는 마스터의 데이터를 실시간으로 전달받아 보관합니다.</li>\n<li>마스터 다운 시 슬레이브 서버를 통해 서비스를 계속할 수 있습니다. 하지만, 이때는 수동으로 슬레이브 서버를 마스터로 변경해야합니다.</li>\n<li>한 마스터에 슬레이브를 여러 대 구성할 수 도 있습니다.</li>\n</ul>\n<h3 id=\"이중화--센티널sentinel--ha-무중단-서비스-가능\"><a href=\"#%EC%9D%B4%EC%A4%91%ED%99%94--%EC%84%BC%ED%8B%B0%EB%84%90sentinel--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>이중화 + 센티널(Sentinel) : HA, 무중단 서비스 가능</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133779960-5c97207f-75d7-405c-a4ea-730bba593e2d.png\" alt=\"image\"></p>\n<ul>\n<li>마스터-슬레이브 구성에 <strong>센티널</strong>을 추가해서 각 서버를 감시하도록하며, 센티널은 마스터 서버를 감시하고 있다가 다운되면 슬레이브를 마스터로 승격시킵니다.</li>\n<li>다운된 마스터가 다시 시작되면 센티널이 슬레이브로 전환시킵니다.</li>\n<li>레디스 마스터 노드가 모든 데이터를 가지고 있으며 슬레이브는 마스터에 대한 복제본을 유지하고 있으며, 데이터를 분산하지 않습니다.</li>\n<li>일반적으로 레디스 센티널은 레디스 서버마다 하나씩 설치하며, 레디스 서버와 분리된 프로세스이며 다른 포트를 사용합니다. (데이터를 처리하지 않습니다.)</li>\n<li>레디스 센티널은 높은 가용성과 자동 fail over 을 해결하지만 <strong>데이터 분산 문제를 해결하지 못합니다.</strong></li>\n</ul>\n<p><a href=\"https://hub.docker.com/r/erichsu/redis-sentinel/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Sentinel Docker</a></p>\n<h3 id=\"레디스-클러스터cluster--ha-무중단-서비스-가능\"><a href=\"#%EB%A0%88%EB%94%94%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0cluster--ha-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>레디스 클러스터(Cluster) : HA, 무중단 서비스 가능</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133781464-16c21b85-1ca2-4e0f-8028-5acf9a37a2f8.png\" alt=\"Redis-Cluster-Type-1\"></p>\n<p>머신 하나가 죽었을 시 해결이 됩니다. 다만 두개가 죽으면 해결이 안됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133782017-fe094509-ed9a-419c-9739-35a766b4e334.png\" alt=\"Redis-Cluster-Type-2\"></p>\n<p>위의 문제를 해결하는 방법입니다.</p>\n<ul>\n<li>\n<p><strong>샤딩</strong></p>\n<ul>\n<li>클라스터는 <strong>샤딩</strong>(sharding, 대량의 데이터를 처리하기 위해 여러 개의 데이터베이스에 분할하는 기술) 방법을 제공하는 방법입니다.</li>\n<li>100개의 데이터를 1번 마스터에 33개, 2번 마스터 33개, 3번 마스터에 나머지 34개가 저장되는 방식입니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>Hash 함수</strong></p>\n<ul>\n<li>데이터를 나누는 방식은 키에 hash 함수를 적용해서 값을 추출하고, 이 값을 각 마스터 서버에 할당합니다.</li>\n<li>클러스터 구성시 해쉬 함수를 통해서 1~33까지를 1번 서버, 34~ 66번까지를 2번 서버, 3번 서버는 또 다르게 할당됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>해시 슬록(16384 슬롯)</strong></p>\n<ul>\n<li>레디스에서 hash 값의 개수는 16384(0~16383)이고 슬롯(slot)이라고 합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>해시 태그</strong></p>\n<ul>\n<li>다중 키 작업을 진행하려면 동일 노드에 저장될 모든 키가 필요합니다. 해시 태그는 레디스 클러스터에서 다중키를 사용할 수 있는 유일한 방법입니다.</li>\n<li>해시 함수를 적용해 동일한 해시 슬롯에 여러 개의 키 이름을 저장할 수 있도록 사용됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>레디스 클라이언트</strong></p>\n<ul>\n<li>클라이언트는 서버와 동일한 hash 함수를 가지고 있으며 마스터 서버에 접속해서 각 서버에 할당된 슬롯 정보를 가지고 있습니다.</li>\n<li>키가 입력되면 hash 함수를 적용해서 어느 마스터에 저장할지 판단해서 해당 마스터에 저장합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>데이터 서버 + 센티널</strong></p>\n<ul>\n<li>각 마스터 서버는 데이터의 처리와 센티널의 역할을 같이수행합니다.</li>\n<li>1번 마스터 서버가 다운되면 나머지 살아있는 마스터들 중에서 리더를 선출해서 리더가 1번 마스터의 슬레이브를 마스터로 승격시킵니다.</li>\n</ul>\n</li>\n<li>\n<p>최소 3대</p>\n<ul>\n<li>마스터 서버는 최소 3대로 구성하고 각각은 슬레이브를 가질 수 있습니다.</li>\n</ul>\n</li>\n<li>마스터를 관리하는 마스터는 없습니다. 이는 또 하나의 장애점입니다.</li>\n<li>레디스가 사용하는 포트는 2개이며 하나는 클라이언트 하나는 노드 간의 통신을 위한 버스로 사용됩니다.</li>\n</ul>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jyejye9201.medium.com/%EB%A0%88%EB%94%94%EC%8A%A4-redis-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-2b7af75fa818\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis란 무엇인가</a></li>\n<li><a href=\"https://docs.redis.com/latest/rs/concepts/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Concept</a></li>\n<li><a href=\"http://redisgate.kr/redis/configuration/redis_overview.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Architecture Overview</a></li>\n<li><a href=\"https://cla9.tistory.com/101\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis 구조</a></li>\n<li><a href=\"https://engkimbs.tistory.com/869\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">레디스 소개 및 아키텍처, 주의할 점</a></li>\n<li><a href=\"https://coding-start.tistory.com/128\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis - Cluster &#x26; Sentinel</a></li>\n<li><a href=\"https://redis.io/commands\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Command</a></li>\n<li><a href=\"https://redis.com/redis-enterprise/technology/redis-enterprise-cluster-architecture/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis Enterprise Cluster Architecture</a></li>\n</ul>\n"}},{"node":{"title":"[Database] CAP 정리","path":"/00-db-cap/","date":"9. February 2021","timeToRead":4,"description":"CAP 이론에 대해 정리합니다.","content":"<h1 id=\"cap-정리\"><a href=\"#cap-%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CAP 정리</h1>\n<p>DB에 대해 공부하다 보면, CAP 이론에 대해 듣게 됩니다. 비록 이야기가 조금 있기는 하지만 그래도 CAP에 대해 개념을 정리합니다.</p>\n<br/>\n<h2 id=\"cap-란\"><a href=\"#cap-%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CAP 란.</h2>\n<p>CAP이론(Brewer's theorem)은 Network로 연결된 분산된 데이터베이스 시스템은 일관성(Consistency), 가용성(Availability), 분할 내구성(Partition Tolerance)의 3가지 특성 중 2가지 특성만을 충족할 수 있고 3가지를 모두 충족할 수는 없다는 이론입니다.</p>\n<h3 id=\"c일관성-consistency\"><a href=\"#c%EC%9D%BC%EA%B4%80%EC%84%B1-consistency\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>C(<strong>일관성</strong>, Consistency)</h3>\n<ul>\n<li>일관성을 가진다는 것은 모든 데이터를 요청할 때 응답으로 가장 최신의 변경된 데이터를 리턴 또는 실패를 리턴합니다.</li>\n<li>모든 읽기에 대해서 DB노드가 항상 동일한 데이터를 가지고 있어야한다는 의미입니다.</li>\n</ul>\n<h3 id=\"a가용성-availability\"><a href=\"#a%EA%B0%80%EC%9A%A9%EC%84%B1-availability\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>A(<strong>가용성</strong>, Availability)</h3>\n<ul>\n<li>가용성은 모든 요청에 대해서 정상적인 응답을 합니다.</li>\n<li>클러스터의 노드 일부에서 장애가 발생해도 READ나 WRITE 등의 동작은 항상 성공적으로 리턴되어야합니다.</li>\n</ul>\n<h3 id=\"p분할내성-partition-tolerance\"><a href=\"#p%EB%B6%84%ED%95%A0%EB%82%B4%EC%84%B1-partition-tolerance\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>P(<strong>분할내성</strong>, Partition tolerance)</h3>\n<ul>\n<li>메시지 전달이 실패하는 시스템 일부가 망가져도 시스템이 계속 동작할 수 있습니다.</li>\n<li>분할 내구성이란 Node간의 통신 장애가 발생하더라도 동작해야합니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107368608-19285380-6b24-11eb-95b2-846fea107c43.png\" alt=\"image\"></p>\n<p>다만, 현재의 DB와는 문제가 있다는 이야기는 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107371626-d1a3c680-6b27-11eb-9d32-1edebb653aed.png\" alt=\"image\"></p>\n<br/>\n<h2 id=\"일반적으로\"><a href=\"#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9C%BC%EB%A1%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>일반적으로</h2>\n<h3 id=\"cpconsistency--partition-tolerance\"><a href=\"#cpconsistency--partition-tolerance\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CP(Consistency &#x26; Partition Tolerance)</h3>\n<ul>\n<li>어떤 상황에서도 안정적으로 시스템은 운영되지만 Consistency가 보장되지 않는다면 Error를 반환합니다.</li>\n<li><strong>매 순간 Read / Write 에 따른 정합성이 일치할 필요가 있는 경우 적합한 형태입니다.</strong></li>\n</ul>\n<h3 id=\"apavailability--partition-tolerance\"><a href=\"#apavailability--partition-tolerance\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>AP(Availability &#x26; Partition Tolerance)</h3>\n<ul>\n<li>어떤 상황에서도 안정적으로 시스템은 운영됩니다.</li>\n<li>데이터와 상관없이 안정적인 응답을 받을 수 있습니다.</li>\n<li>다만 데이터의 정합성에 대한 보장은 불가능합니다.</li>\n<li><strong>결과적으로 일관성이 보장되는 Eventual Consistency를 보장할 수 있는 시스템에 알맞는 형태입니다.</strong></li>\n</ul>\n<h3 id=\"대부분은\"><a href=\"#%EB%8C%80%EB%B6%80%EB%B6%84%EC%9D%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>대부분은...</h3>\n<ul>\n<li>사실 대부분 CP, AP 시스템은 없고 대부분 CP와 AP의 어느 중간 쯤에 존재합니다.</li>\n<li>예제에 봤듯이 configuration에 따라 변하기도 하고, 이론 자체에서 한계점도 존재합니다.</li>\n<li>가장 큰 문제는 P에 대한 명확한 정의가 부족합니다.</li>\n<li>기존의 문제를 해결하기 위해 PACELC 이론이 등장하였습니다.</li>\n</ul>\n<br/>\n<h2 id=\"pacelc-이론\"><a href=\"#pacelc-%EC%9D%B4%EB%A1%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PACELC 이론</h2>\n<p>다음과 같은 요소로 표현됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107372209-7faf7080-6b28-11eb-897d-461cc4b64a86.png\" alt=\"pacelc\"></p>\n<h3 id=\"pacelc-구성\"><a href=\"#pacelc-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PACELC 구성</h3>\n<p>PACELC는 크게 4가지로 구성됩니다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>구성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Partition</td>\n<td>Availability</td>\n<td>가용성</td>\n</tr>\n<tr>\n<td></td>\n<td>Consistency</td>\n<td>일관성</td>\n</tr>\n<tr>\n<td>Else</td>\n<td>Latency</td>\n<td>시간 지연</td>\n</tr>\n<tr>\n<td></td>\n<td>Consistency</td>\n<td>일관성</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"pacelc-대입\"><a href=\"#pacelc-%EB%8C%80%EC%9E%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PACELC 대입</h3>\n<p>이를 기존의 DB에 대입시키면 다음과 같이 볼 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107372699-0bc19800-6b29-11eb-96f0-957e59da40b8.png\" alt=\"pacelc-db\"></p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>CAP 이론과 PACELC 이론에 대한 개념을 잡았습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jins-dev.tistory.com/entry/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%98%EA%B2%BD-Distributed-System-%EC%97%90%EC%84%9C-BASE-%EC%9B%90%EC%B9%99%EA%B3%BC-CAP-%EC%A0%95%EB%A6%AC\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://jins-dev.tistory.com/entry/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%98%EA%B2%BD-Distributed-System-%EC%97%90%EC%84%9C-BASE-%EC%9B%90%EC%B9%99%EA%B3%BC-CAP-%EC%A0%95%EB%A6%AC</a></li>\n<li><a href=\"https://sabarada.tistory.com/91\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://sabarada.tistory.com/91</a></li>\n<li><a href=\"https://m.blog.naver.com/PostView.nhn?blogId=windfalcon1&#x26;logNo=220402574806&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.blog.naver.com/PostView.nhn?blogId=windfalcon1&#x26;logNo=220402574806&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F</a></li>\n</ul>\n"}},{"node":{"title":"[Architecture] MSA : Istio 개념 잡기","path":"/00-architecture-istio/","date":"2. February 2021","timeToRead":10,"description":"Istio 패턴에 대해 정리합니다.","content":"<h1 id=\"istio\"><a href=\"#istio\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio</h1>\n<h2 id=\"istio의-정의\"><a href=\"#istio%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio의 정의</h2>\n<p>Istio는 <strong>애플리케이션 네트워크 기능을 유연하고 쉽게 자동화할 수 있는 투명한 언어 독립적인 방법을 제공하는 현대화된 서비스 네트워킹 레이어인 서비스 메시</strong>입니다. 클라우드 기반 애플리케이션을 구성하는 다양한 마이크로 서비스르르 관리하는데 널리 사용되는 솔루션이며 마이크로 서비스가 서로 통신하고 데이터를 공유하는 방법을 지원합니다.</p>\n<p>Istio를 통해서 느슨하게 결합된 마이크로 서비스를 통해 앱을 어셈블하고, 새로운 클라우드 기반 앱을 관리할 수 있습니다. 또한 <strong>서비스 코드 변경 없이 로드배런싱, 서비스 간 인증, 모니터링 등을 적용해서 마이크로 서비스를 쉽게 관리</strong>할 수 있습니다.</p>\n<p>Istio는 애플리케이션 코드를 변경할 필요 없이 서비스 간 트래픽 흐름을 관리하고 액세스 정책을 적용하여 원격 분석 데이터를 집계합니다. 또한 기존의 분산형 애플리케이션에 투명하게 레이어하여 배포 복잡성을 완화시킵니다.</p>\n<h3 id=\"service-mesh-란\"><a href=\"#service-mesh-%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><code class=\"language-text\">Service Mesh</code> 란?</h3>\n<ul>\n<li>애플리케이션의 다양한 부분들이 서로의 데이터를 공유하는 방식을 제어하는 방법입니다.</li>\n<li>좀 더 자세하게 이야기 한다면, API 등을 사용해서 마이크로 서비스간 통신을 안전하고, 빠르고, 신뢰할 수 있게 만들기 위해 설계된 전용 인프라 계층입니다.</li>\n<li>Service Discovery, Load Balancing, Dynamic Request Routing, Circuit Breacking, Retry and Timeout, TLS, Distributed Tracing, Metric 수집, Access Control, A/B Testing 기능 등을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"istio-service-mesh의-장점\"><a href=\"#istio-service-mesh%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio Service Mesh의 장점</h2>\n<h3 id=\"일관된-서비스-네트워킹-달성\"><a href=\"#%EC%9D%BC%EA%B4%80%EB%90%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9-%EB%8B%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>일관된 서비스 네트워킹 달성</h3>\n<p>네트워킹 운영자는 개발자 오버헤드를 추가하지 않고도 모든 서비스의 네트워킹을 일관성 있게 관리할 수 있습니다.</p>\n<h3 id=\"istio-이점을-통해-서비스-보호\"><a href=\"#istio-%EC%9D%B4%EC%A0%90%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%B3%B4%ED%98%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio 이점을 통해 서비스 보호</h3>\n<p>보안 운영자는 인증, 승인, 암호화를 비롯한 서비스 간 보안을 쉽게 구현할 수 있습니다.</p>\n<h3 id=\"애플리케이션-성능-향상\"><a href=\"#%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>애플리케이션 성능 향상</h3>\n<p>Canary Rollout(새로운 버전 모델 배포시, 소규모 사용자에게 먼저 제공함으로서 위험을 빠르게 감지하는 배포 전략)과 같은 권장사항을 구현하고 애플리케이션을 심도 있게 파악하여 성능을 개선하기 위해 집중해야하는 부분을 파악할 수 있습니다.</p>\n<br/>\n<h2 id=\"istio의-구조\"><a href=\"#istio%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio의 구조</h2>\n<p>마이크로 서비스 간의 모든 네트워크 통신을 담당할 수 잇는 프록시인 Envoy를 사이드카 패턴으로 마이크로 서비스들에 배포한 다음, 프록시들의 설정 값 저장 및 관리/감독을 수행하고, 프록시들에 설정값을 전달하는 컨트롤러를 수행합니다.</p>\n<p>그후 각각의 마이크로 서비스에 사이드카 패턴으로 배포된 Envoy 프록시를 <code class=\"language-text\">데이터 플레인(Data Plane)</code> 이라고 하며, 이를 컨트롤 하는 부분이 <code class=\"language-text\">컨트롤 플레인(Control Plane)</code>이라고 합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/106528740-981dfa80-652c-11eb-95e7-fd408293b65e.png\" alt=\"Istio-Architecture\"></p>\n<p>구성요소를 좀 더 자세하게 설명하면 다음과 같습니다.</p>\n<h3 id=\"data-plane-데이터-플레인\"><a href=\"#data-plane-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%8C%EB%A0%88%EC%9D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Plane (데이터 플레인)</h3>\n<p>실제 데이터 트래픽이 돌아다니는 영역입니다. Envoy Proxy 세트로 구성되어 있습니다.</p>\n<h4 id=\"envoy\"><a href=\"#envoy\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Envoy</h4>\n<p>Envoy는 사이드카 방식으로 각각의 마이크로서비스에 배포되어 서비스로 들어오고 나가는 모든 트래픽을 통제합니다. Envoy를 통해서 서비스를 호출할 때 호출하는 서비스의 IP주소는 파일럿에 저당된 엔드포인트 정보를 활용합니다.</p>\n<p>Istio는 Envoy의 <strong>동적 서비스 디스커버리, 로드밸런싱, TLS 인증서 처리, HTTP/2, gRPC 프록시, 서킷브레이커, 헬스체크, 실패 삽입, 많은 메트릭 등의 기능을 사용</strong>할 수 있습니다.</p>\n<p>사이드카 방식을 사용하기 때문에 기존 컨테이너나 코드를 재사용할 필요없이 그대로 사용가능합니다.</p>\n<h3 id=\"control-plane-컨트롤-플레인\"><a href=\"#control-plane-%EC%BB%A8%ED%8A%B8%EB%A1%A4-%ED%94%8C%EB%A0%88%EC%9D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Control Plane (컨트롤 플레인)</h3>\n<p>트래픽 경로를 설정하고 관리하는 용도로 사용합니다.</p>\n<p>Istio1.4 버전까지는 <strong>파일럿(Pilot), 믹서(Mixer), 시타델(Citadel), 갤리(Galley)</strong> 로 구성되어 있었으나 Istio1.5버전부터 4개의 모듈이 <strong>Istiod</strong> 라는 하나의 모듈로 통합되었습니다.</p>\n<h4 id=\"mixer\"><a href=\"#mixer\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Mixer</h4>\n<ul>\n<li>서비스 매쉬 엑세스 컨트롤 및 정책 관리 수행합니다.</li>\n<li>Envoy와 다른 서비스에서 모니터링 지표 수집합니다.</li>\n</ul>\n<h4 id=\"pilot\"><a href=\"#pilot\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Pilot</h4>\n<ul>\n<li>Envoy 설정 관리를 수행하는 모듈입니다.</li>\n<li>Envoy가 호출하는 서비스의 주소를 얻을 수 잇는 Service Discovery 기능을 제공합니다.</li>\n<li>서비스 트래픽 라우팅 기능 제공합니다.</li>\n<li>서비스 안정성을 위해 서비스 간 호출시 Time out, Retry, Circuit Breaker(서킷 브레이커)같은 기능들을 제공합니다.</li>\n</ul>\n<h4 id=\"citadel\"><a href=\"#citadel\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Citadel</h4>\n<ul>\n<li>보안 관련 기능을 수행하는 모듈입니다.</li>\n<li>사용자 인증을 통해서 서비스/앤드 유저 간의 인증을 강화합니다.</li>\n<li>TLS(SSL)을 이용하여 통신 암호화와 인증서 관리를 할 수 있습니다.</li>\n</ul>\n<h4 id=\"galley\"><a href=\"#galley\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Galley</h4>\n<ul>\n<li>Istio 설정을 Validation, Ingestion, Processing, Distribution 하는 역할을 합니다.</li>\n<li>즉, Istio의 구성 및 설정을 검증하고 배포 관리를 진행합니다.</li>\n</ul>\n<h4 id=\"istiod\"><a href=\"#istiod\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istiod</h4>\n<p>Istio 1.5 이상 버전에서 제공되며 서비스 디스커버리, 설정관리, 인증관리 등을 수행합니다.</p>\n<ul>\n<li>트래픽 동작을 제어하는 라우팅 규칙을 Envoy 전용 설정으로 변환하고 마이크로 서비스에 사이드카 방식으로 Envoy를 배포합니다.</li>\n<li>Envoy 설정 변경을 통해 서비스 메시 트래픽을 제어합니다.</li>\n<li>내장된 Identity나 Credential Management(증명 관리)을 통해서 강력한 서비스 간 인증 및 사용자 인증 기능을 지원합니다.</li>\n<li>인증 기관의 역할을 수행하, 데이터 플레인에서 안전한 mTLS 통신을 허용하는 인증서를 생성합니다.</li>\n</ul>\n<br/>\n<h2 id=\"istio의-장점\"><a href=\"#istio%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio의 장점</h2>\n<p>Istio를 통해서 분산형 애플리케이션을 대규모로 제공할 수 있습니다. 아래와 같은 장점이 있습니다.</p>\n<h3 id=\"안전한-클라우드-기반-앱\"><a href=\"#%EC%95%88%EC%A0%84%ED%95%9C-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EA%B8%B0%EB%B0%98-%EC%95%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>안전한 클라우드 기반 앱</h3>\n<p>Istio는 기본적인 보안 통신 채널을 제공하며 대규모 서비스 통신의 인증(Authentication), 권한부여(Authorization), 암호화(Encryption) 등을 통해서 애플리케이션 수준에서 보안을 강화할 수 있습니다.</p>\n<h3 id=\"효율적인-트래픽-관리\"><a href=\"#%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%8A%B8%EB%9E%98%ED%94%BD-%EA%B4%80%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>효율적인 트래픽 관리</h3>\n<p>Istio는 간편한 규칙(Rule) 설정과 트래픽 라우팅(Traffic Routing) 기능을 통해서 서비스 간의 트래픽 흐름과 API 호출을 제어할 수 있습니다. 또한 서킷 브레이커(Circuit Breaker), 타임아웃(Timeout), Retry 등의 기능과 같은 서비스 레벨의 속성 구성을 단순화 할 수 있습니다.</p>\n<p>이를 바탕으로 트래픽을 분할하여 A/B Test, Canary Rollout, Staged Rollout과 같은 작업을 쉽게 설정할 수 있습니다.</p>\n<p>트래픽에 대한 더 나은 가시성과 독창적인 장애 복구 기능을 통해서 문제가 발생하기 전에 문제를 발견하고 서비스 호출을 안정화 시킬 수 있습니다.</p>\n<h3 id=\"서비스-메시-모니터링\"><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%A9%94%EC%8B%9C-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서비스 메시 모니터링</h3>\n<p>Istio의 Tracing(트레이싱), Monitoring(모니터링), Logging(로깅) 기능으로 서비스 성능이 업스트림에 미치는 영향을 자세히 파악할 수 있습니다. 또한 서비스 성능이 업스트림이나 다운 스트림에 어떤 영향을 끼치는 지 파악할 수 있습니다. 또한 맞춤형 대시보드를 통해서 모든 서비스 성능을 보기 좋고, 다른 프로세스에 미치는 영향을 확인할 수 있습니다.</p>\n<h3 id=\"kubenetes-및-가상-머신을-통한-간편한-배포\"><a href=\"#kubenetes-%EB%B0%8F-%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0%EC%9D%84-%ED%86%B5%ED%95%9C-%EA%B0%84%ED%8E%B8%ED%95%9C-%EB%B0%B0%ED%8F%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Kubenetes 및 가상 머신을 통한 간편한 배포</h3>\n<p>Istio는 컨테이너 및 가상 머신을 포함하여 기존과 최신 워크로드 모두에 대해 가시성과 네트워크 제어를 제공합니다.</p>\n<p>즉, Istio는 플랫폼에 독립적입니다.</p>\n<h3 id=\"고급-기능을-통해-부하-분산-최소화\"><a href=\"#%EA%B3%A0%EA%B8%89-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%B6%80%ED%95%98-%EB%B6%84%EC%82%B0-%EC%B5%9C%EC%86%8C%ED%99%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>고급 기능을 통해 부하 분산 최소화</h3>\n<p>클라이언트 기반 라우팅, Canary Rollout과 같은 고급 기능과 함께 모든 트래픽에 자동화된 부하 분산을 사용할 수 있습니다.</p>\n<h3 id=\"정책-시행\"><a href=\"#%EC%A0%95%EC%B1%85-%EC%8B%9C%ED%96%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>정책 시행</h3>\n<p>액세스 제어, 비율 제한, 할당량을 지원하는 플러그인 가능한 정책 레이어 및 구성 API를 사용하여 정책을 시행할 수 있습니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>Istio에 대해 내용을 정리했습니다. 감사합니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://twofootdog.tistory.com/78\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://twofootdog.tistory.com/78</a></li>\n<li><a href=\"https://www.redhat.com/ko/topics/microservices/what-is-istio\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/microservices/what-is-istio</a></li>\n<li><a href=\"https://cloud.google.com/learn/what-is-istio?hl=ko\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cloud.google.com/learn/what-is-istio?hl=ko</a></li>\n<li><a href=\"https://arisu1000.tistory.com/27865\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://arisu1000.tistory.com/27865</a></li>\n</ul>\n"}},{"node":{"title":"[Architecture] SOA 패턴이란","path":"/01-architecture-soa/","date":"1. January 2021","timeToRead":6,"description":" SOA 패턴에 대해 정리합니다.","content":"<h1 id=\"soa-패턴을-알아보자\"><a href=\"#soa-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>SOA 패턴을 알아보자.</h1>\n<p>대용량의 분산 시스템에서 SOA라는 개념에 대해 많이 듣습니다. 서버사이드의 근간이 되는 SOA(Service Oriented Architecture)에 대해 알아보겠습니다.</p>\n<br/>\n<h2 id=\"soa이란\"><a href=\"#soa%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>SOA이란?</h2>\n<p>SOA란 Service Oriented Architecture의 약자로서, 이를 해석하면 서비스 지향 아키텍쳐를 의미합니다.</p>\n<p>기존의 애플리케이션의 기능들을 <strong>비지니스적인 의미를 가지는 기능 단위</strong>로 묶어서 표준화된 호출 인터페이스를 통해 서비스로 구현하고, 이 서비스들을 기업의 업무에 따라 어플리케이션을 구성하는 소프트웨어 개발 아키텍처를 의미합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103477346-5f8de280-4e01-11eb-9500-25672abe187f.png\" alt=\"SoaModel\">\n: <a href=\"https://songii00.github.io/2019/11/17/2019-11-17-CleanArchitecture%20Item%2027/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://songii00.github.io/2019/11/17/2019-11-17-CleanArchitecture%20Item%2027/</a></p>\n<h3 id=\"왜-soa가-주목-받나요\"><a href=\"#%EC%99%9C-soa%EA%B0%80-%EC%A3%BC%EB%AA%A9-%EB%B0%9B%EB%82%98%EC%9A%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>왜 SOA가 주목 받나요?</h3>\n<ul>\n<li>웹 서비스의 등장으로 인해 다양한 기술적 복합도를 낮출 수 있게되어, 기술적인 대안이 등장하였습니다.</li>\n<li>점점 확장되는 독립된 업무 시스템으로 인해 통합에 대한 필요가 생겼습니다.</li>\n<li>기업의 비지니스 속도가 빨라져서 민첩한 대응이 필요해졌습니다.</li>\n</ul>\n<br/>\n<h2 id=\"soa의-기본적인-개념\"><a href=\"#soa%EC%9D%98-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>SOA의 기본적인 개념</h2>\n<h3 id=\"서비스란\"><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서비스란?</h3>\n<p>서비스란 플랫폼에 종속되지 않는 표준 인터페이스를 통해 비지니스적인 의미를 가지는 기능들을 모아놓은 <strong>소프트웨어 컴포넌트</strong>를 의미합니다.</p>\n<p>ex. 임직원 정보 서비스, 계좌이체 서비스, 상품 주문 서비스</p>\n<p>일반적으로 SOA에서 정의하는 서비스는 <strong>비지니스 서비스</strong>를 의미합니다.</p>\n<p>그 외의 서비스로는 Intermediary 서비스나 Process Centrix 서비스, Application 서비스, Public Enterprise 서비스 등이 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103477324-1e95ce00-4e01-11eb-8332-46a5dd17f6fb.png\" alt=\"ServiceImage\">\n: <a href=\"https://www.slideshare.net/Byungwook/soa-61487404\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.slideshare.net/Byungwook/soa-61487404</a></p>\n<br/>\n<h2 id=\"soa의-단계적-발전-구조\"><a href=\"#soa%EC%9D%98-%EB%8B%A8%EA%B3%84%EC%A0%81-%EB%B0%9C%EC%A0%84-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>SOA의 단계적 발전 구조.</h2>\n<p>SOA는 시스템의 규모와 업무적 요구 사항에 따라 3단계 순서로 발전됩니다.</p>\n<h3 id=\"fundamental-soa\"><a href=\"#fundamental-soa\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Fundamental SOA</h3>\n<p>기존 시스템들을 서비스화하여, 각 시스템들을 통합하는 단계입니다.</p>\n<ul>\n<li>서비스화와 통합이 중점 전체를 한 시스템화합니다.</li>\n<li>서비스에 대한 조합은, Front End에서 담당합니다.</li>\n<li>비지니스 서비스와 Application서비스로만 구성됩니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103477424-230eb680-4e02-11eb-96d1-3d5efa11bd40.png\" alt=\"FundamentalSOA\"></p>\n<h3 id=\"networked-soa\"><a href=\"#networked-soa\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Networked SOA</h3>\n<p>Fundamental SOA의 문제점</p>\n<ul>\n<li>시스템의 크기가 증가됨에 따라 서비스와 Front-End 사이에 연결이 복잡해집니다.</li>\n<li>시스템의 유연성이 떨어집니다.</li>\n<li>관리 및 중앙 통제가 어렵습니다.</li>\n</ul>\n<p>이러한 단점을 해결하기 위해 Networked SOA는 아래의 특징을 가지고 있습니다.</p>\n<ul>\n<li>SOA 시스템의 가운데 서비스 허브를 둬서 서비스의 중앙 통제력 및 유연성을 강화합니다.</li>\n<li>Intermediary 서비스가 ESB(라우팅, 변환, 로깅, 서비스 통제 등)에 위치합니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103477468-8d275b80-4e02-11eb-9fc0-d2a37057ac5b.png\" alt=\"NetworkedSOA\"></p>\n<h3 id=\"process-oriented-soa\"><a href=\"#process-oriented-soa\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Process Oriented SOA</h3>\n<p>기존에 Networked SOA에서 발전한 단계입니다.</p>\n<ul>\n<li>비지니스 플로우(Business Flow)가 있을 경우에만 적용됩니다.</li>\n<li>서비스의 조합을 통한 업무의 구현을 BPM을 이용합니다.</li>\n<li>업무 변화에 민첩하게 반응합니다,. (Agile 가능)</li>\n<li>기술조직과 비지니스 조직간의 의사 소통이 원할합니다.</li>\n</ul>\n<br/>\n<h2 id=\"다른-아키텍처와-비교\"><a href=\"#%EB%8B%A4%EB%A5%B8-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%99%80-%EB%B9%84%EA%B5%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>다른 아키텍처와 비교</h2>\n<h3 id=\"monolithic-보다-나은점\"><a href=\"#monolithic-%EB%B3%B4%EB%8B%A4-%EB%82%98%EC%9D%80%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Monolithic 보다 나은점</h3>\n<ul>\n<li>출시 일정 단축 및 유연성이 향상됩니다.</li>\n<li>신규 시장에서 레거시 인프라를 활용가능합니다.</li>\n<li>더 효율적인 애자일 개발 방식으로 비용을 아낄 수 있습니다.</li>\n<li>손쉽게 유지관리합니다.</li>\n<li>확정성을 가지고 있습니다.</li>\n<li>안정성이 강화됩니다.</li>\n<li>편리한 이용이 가능합니다.</li>\n</ul>\n<h3 id=\"msa와-비교\"><a href=\"#msa%EC%99%80-%EB%B9%84%EA%B5%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA와 비교</h3>\n<p>MSA와 SOA는 유사한 개념 때문에 혼동하기 쉽습니다. 다만 둘의 <strong>근본적인 차이점은 범위</strong>입니다. <strong>SOA는 전사적인 아키텍처 접근 방식이며, MSA는 어플리케이션 개발 팀 내의 구현 전략</strong>입니다.</p>\n<p>또한 각각의 구성 요소와 통신하는 방법에서 차이가 있습니다. <strong>SOA는 ESB를 사용</strong>하는 반면에 <strong>마이크로서비스끼리는 언어의 제약이 없는 API</strong>를 통해 stateless 방식으로 통신합니다. 마이크로서비스의 API에는 언어의 제약이 없기 때문에 개발팀에서 사용하고 싶은 툴을 선택할 수 있습니다. 따라서, 마이크로서비스의 내결합성과 유연성이 더 유연합니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>오늘은 간단하게 SOA개념에 대해 정리해보았습니다. MSA와 혼란스러운 부분이 있었으나 큰 차이를 이해할 수 있었습니다. 해당 게시글의 잘못된 부분을 알려주시면 감사합니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://sarc.io/index.php/miscellaneous/742-soa-service-oriented-architecture\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://sarc.io/index.php/miscellaneous/742-soa-service-oriented-architecture</a></li>\n<li><a href=\"https://www.slideshare.net/Byungwook/soa-61487404\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.slideshare.net/Byungwook/soa-61487404</a></li>\n<li><a href=\"https://www.redhat.com/ko/topics/cloud-native-apps/what-is-service-oriented-architecture\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/cloud-native-apps/what-is-service-oriented-architecture</a></li>\n</ul>\n"}},{"node":{"title":"[Architecture] MSA : CQRS 패턴이란","path":"/02-architecture-msa/","date":"23. December 2020","timeToRead":7,"description":" CQRS 패턴에 대해 정리합니다.","content":"<h1 id=\"msa--cqrs-패턴의-정의과-종류\"><a href=\"#msa--cqrs-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A0%95%EC%9D%98%EA%B3%BC-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA : CQRS 패턴의 정의과 종류</h1>\n<p>지난 시간에는 MSA와 MSA 패턴 중, SAGA 패턴에 대해 알아보았습니다.</p>\n<ul>\n<li><a href=\"Azderica.github.io/00-architecture-msa/\">MSA 개념 잡기</a></li>\n<li><a href=\"Azderica.github.io/01-architecture-msa/\">MSA : SAGA 패턴</a></li>\n</ul>\n<br/>\n<h2 id=\"cqrs-패턴이란\"><a href=\"#cqrs-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CQRS 패턴이란.</h2>\n<p>CQRS 패턴이란 Command and Query Responsibility Segregation의 약자입니다. 이를 해석하면 <strong>명령과 쿼리의 역할을 구분</strong>한다는 것입니다. 즉, Command (<strong>C</strong>reate, Insert, <strong>U</strong>pdate, <strong>D</strong>elete)와 쿼리(Select - <strong>R</strong>ead)의 책임을 분리하는 의미를 가집니다.</p>\n<br/>\n<h2 id=\"cqrs가-왜-필요한가요\"><a href=\"#cqrs%EA%B0%80-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80%EC%9A%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CQRS가 왜 필요한가요?</h2>\n<p>전통적인 CRUD 아키텍처 기반에서 Application을 개발 및 운영하다가 보면, 자연스럽게 <strong>Domain Model의 복잡도가 증가하고 그에 따라 유지보수의 비용이 증가하고 Domain model은 설계의 방향과 다르게 변질</strong>됩니다. 특히 요즘처럼 고급화된 UX, 어려워진 Business, 자주 변하는 요구사항에서 이러한 Model을 설계하는 것은 어려워졌습니다.</p>\n<p>이러한 흐름에서 확인해보니, 대부분의 정책이나 제약은 데이터 변경(C, U, D)에서 처리되고, 데이터 조회(R) 작업은 단순 데이터 조회인데, 동일 Domain Model로 처리하면 필요하지 않은 Domain 속성들로 인해 <strong>복잡도가 증가</strong>합니다.</p>\n<p>따라서 이 문제를 해결하기위해서 <strong>명령을 처리하는 책임</strong>과 <strong>조회를 처리하는 책임</strong>을 <strong>분리</strong>하는 해법을 찾았고 이 방법이 CQRS입니다.</p>\n<br/>\n<h2 id=\"cqrs의-종류\"><a href=\"#cqrs%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CQRS의 종류</h2>\n<blockquote>\n<p>전통적인 CRUD 시스템.</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103001594-b0cfe380-4570-11eb-8166-ab5f026e534a.png\" alt=\"original-crud\"></p>\n<p>기존의 전통적인 CRUD 시스템은 다음 그림과 같은 계층 구조를 지니고 있습니다. 이에 CQRS 패턴을 적용하기 위한 방법으로 크게 최소 <strong>3가지 방법</strong>이 있습니다.</p>\n<h3 id=\"1-simple-cqrs-architecture\"><a href=\"#1-simple-cqrs-architecture\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. Simple CQRS architecture</h3>\n<p>이는 단일 Data Store에 Command Query Model을 분리된 계층으로 나누는 방식입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103002233-df9a8980-4571-11eb-9156-a6d3675bc07b.png\" alt=\"Simple CQRS architecture\"></p>\n<p>해당 그림처럼 Database(RDBMS)는 분리하지 않고 <strong>기존 구조를 유지하고 Model Layer 부분과 Command와 Query Model로 분리</strong>하는 수준으로 간단하게 적용할 수 있습니다.</p>\n<h4 id=\"장점\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>장점.</h4>\n<ul>\n<li>훨씬 단순하게 구현 및 적용할 수 있습니다.</li>\n</ul>\n<h4 id=\"단점\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단점.</h4>\n<ul>\n<li>동일한 Database 사용에 따른 성능상 문제점은 개선하지 못합니다.</li>\n</ul>\n<h3 id=\"2-cqrs-with-separated-persistance-mechanisms\"><a href=\"#2-cqrs-with-separated-persistance-mechanisms\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. CQRS with separated persistance mechanisms</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103002567-79facd00-4572-11eb-8d8a-723176ff0e35.png\" alt=\"CQRS with separated persistance mechanisms\"></p>\n<p>해당 방법은 Command용 Database와 Query용 Database를 분리하고 별도의 Broker를 통해서 이 둘간의 Data를 동기화 처리하는 방식입니다. 이 경우에는 데이터를 조회하려는 서비스들은 서비스에 맞는 저장소를 선택할 수 있기 때문에 polyglot 구조로 구성할 수도 있습니다. 이 경우에는 각각의 Model에 맞게 저장소(RDBMS, NOSQL, Cache)를 튜닝해서 사용할 수 있습니다.</p>\n<ul>\n<li><strong>polyglot</strong> 이란? 다수의 Database를 혼용하여 사용하는 것입니다.</li>\n</ul>\n<h4 id=\"장점-1\"><a href=\"#%EC%9E%A5%EC%A0%90-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>장점</h4>\n<ul>\n<li>Simple CQRS 에서 거론되는 Database 사용에 발생하는 성능 관점의 문제를 해결할 수 있습니다.</li>\n</ul>\n<h4 id=\"단점-1\"><a href=\"#%EB%8B%A8%EC%A0%90-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단점</h4>\n<ul>\n<li>동기화 처리를 위한 Broker의 가용성과 신뢰도가 보장이 되어야합니다.</li>\n</ul>\n<h3 id=\"3-eventsouring-model\"><a href=\"#3-eventsouring-model\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. EventSouring Model</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103003262-ceeb1300-4573-11eb-8591-f4ceb1a7312e.png\" alt=\"EventSouring Model\"></p>\n<p>해당 방법은 이벤트 소싱(Event Sourcing)을 적용한 구조입니다.</p>\n<p><strong>이벤트 소싱</strong>이란 <strong>Application 내의 모든 Activity를 이벤트로 전환해서 이벤트 스트림(Event Stream)을 별도의 Database에 저장하는 방식</strong>을 의미합니다. EvensSourcing Model이란 이벤트 스트림을 저장하는 Database에는 오직 데이터 추가만 가능하고 계속적으로 쌓이는 데이터를 구체화시키는 시점에서 그때까지 구축된 데이터를 바탕으로 조회 대상 데이터를 작성하는 방법을 의미합니다. 즉, Application 내의 상태 변경을 이력으로 관리하는 패턴의 발전된 형태로 이해하면 됩니다.</p>\n<p>이벤트 소싱의 이벤트 스트림은 오직 추가만 가능하고, 필요로 하는 시점에 구체화 단계를 가지게 되고 이 처리과정이 CQRS의 모델 분리 관점에서 잘 맞기 때문에 주로 선택한다.</p>\n<p><strong>CQRS 패턴에 이벤트 소싱은 필수가 아니지만 이벤트 소싱에는 CQRS가 필요합니다.</strong></p>\n<br/>\n<h2 id=\"cqrs의-이점\"><a href=\"#cqrs%EC%9D%98-%EC%9D%B4%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CQRS의 이점.</h2>\n<ul>\n<li>\n<p>독립적인 크기 조정</p>\n<ul>\n<li>CQRS를 통해 읽기 및 쓰기의 워크로드를 독립적으로 확장할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>최적화된 데이터 스키마</p>\n<ul>\n<li>읽기 쪽에서는 쿼리에 최적화된 슼니마를 사용하고 쓰기에서는 업데이트에 최적화된 스키마를 사용할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>보안</p>\n<ul>\n<li>올바른 도메인 엔터티만 데이터에 쓰기를 수행할 수 있는지 쉽게 확인 가능합니다.</li>\n</ul>\n</li>\n<li>\n<p>유연한 모델 생성</p>\n<ul>\n<li>대부분의 복잡한 비즈니스 논리는 쓰기 모델로 이동시키고 읽기모델은 상대적으로 간단하게 정리하여 유지가능하고 유연한 모델을 만들 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>단순한 쿼리</p>\n<ul>\n<li>읽기 데이터베이스에서 구체화된 뷰를 저장하여 쿼리 시 복잡한 조인을 방지할 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>이전의 게시글과 오늘 게시글을 통해서 <strong>CQRS 패턴은 Database의 성능을 올리기 위해서 적용된 패턴</strong>이고 <strong>SAGA 패턴은 MSA환경에서의 데이터 일관성을 유지하기 위해 제안된 방법</strong>으로 이해하였습니다.</p>\n<p>MSA에 대해 좀 더 공부해야하는 부분이나, 추가적으로 공부를 해야하는 부분이 있다면 다시 정리해보겠습니다. 회사 업무에서는 MSA 구조를 사용하는 일은 아직 없지만, 혹시라도 이후에 적용하게 되었을 때를 대비학는 의미 + 개인적인 호기심으로 글을 정리했습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://www.popit.kr/cqrs-eventsourcing/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.popit.kr/cqrs-eventsourcing/</a></li>\n<li><a href=\"https://docs.microsoft.com/ko-kr/azure/architecture/patterns/cqrs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://docs.microsoft.com/ko-kr/azure/architecture/patterns/cqrs</a></li>\n<li><a href=\"https://engineering-skcc.github.io/microservice%20outer%20achitecture/inner-architecture-cqrs/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://engineering-skcc.github.io/microservice%20outer%20achitecture/inner-architecture-cqrs/</a></li>\n<li><a href=\"https://code-masterjung.tistory.com/80\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://code-masterjung.tistory.com/80</a></li>\n</ul>\n"}},{"node":{"title":"[Architecture] MSA : SAGA 패턴이란","path":"/01-architecture-msa/","date":"22. December 2020","timeToRead":7,"description":" SAGA 패턴에 대해 정리합니다.","content":"<h1 id=\"msa--saga-패턴의-정의과-종류\"><a href=\"#msa--saga-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A0%95%EC%9D%98%EA%B3%BC-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA : SAGA 패턴의 정의과 종류</h1>\n<p>이전에 MSA 개념에 대해 잡아보았습니다. 오늘은 MSA를 듣다보면 꼭 듣게 되는 SAGA 패턴에 대해 공부해보겠습니다.</p>\n<ul>\n<li><a href=\"https://Azderica.github.io/00-architecture-msa/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MSA 개념 잡기</a></li>\n</ul>\n<br/>\n<h2 id=\"들어가기-앞서서\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%95%9E%EC%84%9C%EC%84%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>들어가기 앞서서.</h2>\n<p>기존의 Monolithic와 MSA 아키텍처에 대해서는 이전 게시글에서 정리했습니다. 오늘은 좀 더 MSA에 대해 이야기할려고 합니다. MSA 아키텍처를 구성하기 어려운 이유 중 하나는 <strong>트랜적션</strong> 의 문제입니다.</p>\n<p>기존의 Monolithic 환경에서는 DBMS가 기본적으로 제공해주는 트랜잭선 기능을 통해서 데이터 commit이나 rollback을 통해서 일관성있게 관리하였습니다. 그러나 Applcation 과 DB가 분산되면서 해당 트랜잭션 처리를 단일 DBMS에서 제공하는 기능으로는 해결할 수 없습니다.</p>\n<h3 id=\"대안--two-phase-commit\"><a href=\"#%EB%8C%80%EC%95%88--two-phase-commit\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>대안 : Two-Phase Commit?</h3>\n<p>여러 서비스 간에 데이터 일관성을 유지하기 위해서 전통적인 방법인 Two-Phase commit 과 같은 방법을 사용했습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102893652-4f8f0e00-44a5-11eb-9f1a-f4d3508e6c97.png\" alt=\"two-phase commit\"></p>\n<p>다만 이 방법은 하나의 서비스가 장애가 있는 경우나 각각의 서비스에 동시에 Rocking이 걸리게 되면 성능의 문제가 발생하기 때문에 비효율적입니다. 더나아가 각각의 서비스가 다른 instance에 있기 때문에 이를 통제하는데 어려움이 있습니다.</p>\n<blockquote>\n<p>트랜잭션이란?</p>\n</blockquote>\n<p>트랜잭션이란 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위를 의미합니다. 트랜잭션은 4가지의 특성(원자성, 일관성, 독립성, 지속성)을 지켜야합니다. 이에 대해 상세하게 다루기에는 주제에 너무 벗어난 주제이기 때문에 다른 게시글로 정리하겠습니다.</p>\n<br/>\n<h2 id=\"saga-패턴의-정의\"><a href=\"#saga-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>SAGA 패턴의 정의</h2>\n<p>위의 문제를 해결하기 위해서 SAGA 패턴이 등장했습니다.</p>\n<p>SAGA 패턴이란 <strong>마이크로서비스들끼리 이벤트를 주고 받아 특정 마이크로서비스에서의 작업이 실패하면 이전까지의 작업이 완료된 마이크서비스들에게 보상 (complemetary) 이벤트를 소싱함으로써 분산 환경에서 원자성(atomicity)을 보장</strong>하는 패턴입니다.</p>\n<p>이를 그림으로 표현하면 다음과 같습니다. SAGA 패턴의 이벤트 성공 시는 다음과 같이 동작합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102894284-33d83780-44a6-11eb-9cb0-1c526edd5642.png\" alt=\"saga-pattern-success\"></p>\n<p>SAGA 패턴의 이벤트 실패 시는 다음과 같이 실패 이벤트를 주어 처리합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102894291-35a1fb00-44a6-11eb-93bf-2371f322c99c.png\" alt=\"saga-pattern-fail\"></p>\n<p>해당 SAGA 패턴의 핵심은 <strong>트랜잭션의 관리주체가 DBMS에 있는 것이 아닌 Application</strong>에 있습니다. Application이 분산되어 있을때는 각 Applicatin은 하위에 존재하는 DB는 local 트랜잭션만 담당합니다.</p>\n<p>즉, 각각의 Application의 트랜잭션 요청의 실패로 인한 Rollback 처리(보상 트랜잭션)은 Application에서 구현합니다.</p>\n<p>이러한 과정을 통해서 순차적으로 트랜잭션이 처리되며, 마지막 트랜잭션이 끝났을 때 데이터가 완전히 영속되었음을 확인하고 종료합니다. 이 방법을 통해서 최종 일관성(Eventually Consistency)를 달성할 수 있습니다.</p>\n<br/>\n<h2 id=\"saga-패턴의-종류\"><a href=\"#saga-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>SAGA 패턴의 종류</h2>\n<p>일반적으로 SAGA 패턴은 크게 2가지로 나누어집니다. 하나는 <strong>Choreography based SAGA pattern</strong>이고 다른 하나는 <strong>Orchestration based SAGA pattern</strong>입니다.</p>\n<h3 id=\"choreography-based-saga-pattern\"><a href=\"#choreography-based-saga-pattern\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Choreography based SAGA pattern</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102895303-ccbb8280-44a7-11eb-8b80-8b87630db5f5.png\" alt=\"Choreography-Based Saga Success\"></p>\n<p>Choreography-based Saga 패턴은 보유한 서비스 내의 Local 트랜잭션을 관리하며 트랜잭션이 종료하게 되면 완료 Event를 발행합니다. 만약 그 다음 수행해야할 트랜잭션이 있으면 해당 트랜잭션을 수행해야하는 App으로 이벤트를 보내고, 해당 App은 완료 Event를 수신받고 다음 작업을 진행합니다. 이를 순차적으로 수행합니다. 이때 Event는 Kafka와 같은 메시지 큐를 통해서 비동기 방식으로 전달할 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102895310-cf1ddc80-44a7-11eb-9941-de72656dd3a8.png\" alt=\"Choreography-Based Saga Fail\"></p>\n<p>Choreography-base Saga 패턴에서는 각 App별로 트랜잭션을 관리하는 로직이 있습니다. 이를 통해서 중간에 트랜잭션이 실패하면 해당 트랜잭션 취소 처리를 실패한 App에서 보상 Event를 발행해서 Rollback 처리를 시도합니다.</p>\n<h4 id=\"장점\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>장점</h4>\n<ul>\n<li>구성하기 편합니다.</li>\n</ul>\n<h4 id=\"단점\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단점</h4>\n<ul>\n<li>운영자 입장에서 트랜잭션의 현재 상태를 확인하기 어렵습니다.</li>\n</ul>\n<h3 id=\"orchestration-based-saga-pattern\"><a href=\"#orchestration-based-saga-pattern\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Orchestration based SAGA pattern</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102895290-c927fb80-44a7-11eb-88ee-8f08ec4b2c21.png\" alt=\"Orchestration-Based Saga Success\"></p>\n<p>Orchestration-Based Saga 패턴은 트랜잭션 처리를 위해 Saga 인스턴스(Manager)가 별도로 존재합니다. 트랜잭션에 관여하는 모든 App은 Manager에 의해 점진적으로 트랜잭션을 수행하며 결과를 Manager에게 전달하게 되고, 비지니스 로직상 마지막 트랜잭션이 끝나면 Manager를 종료해서 전체 트랜잭션 처리를 종료합니다. 만약 중간에 실패하게 되면 Manager에서 보상 트랜잭션을 발동하여 일관성을 유지합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102895323-d47b2700-44a7-11eb-9bc1-2c46cf517c06.png\" alt=\"Orchestration-Based Saga Fail\"></p>\n<p>해당 Orchestration-Based Saga 패턴은 모든 관리를 Manager가 호출하기 때문에 분산트랜잭션의 중앙 집중화가 이루어집니다.</p>\n<h4 id=\"장점-1\"><a href=\"#%EC%9E%A5%EC%A0%90-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>장점</h4>\n<ul>\n<li>서비스간의 복잡성이 줄어들어서 구현 및 테스트가 쉬워집니다.</li>\n<li>트랜잭션의 현재 상태를 Manager가 알고 있으므로 롤백을 하기 쉽습니다.</li>\n</ul>\n<h4 id=\"단점-1\"><a href=\"#%EB%8B%A8%EC%A0%90-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단점</h4>\n<ul>\n<li>관리를 해야하는 Orchestrator 서비스가 추가되어야하기 때문에 인프라 구현이 복잡해집니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리</h2>\n<p>MSA 아키텍처 중 가장 유명한 SAGA 패턴에 대해 알아보았습니다. 다만 항상 SAGA 패턴이 좋다고는 볼 수 없습니다. 비지니스 로직상 트랜잭션 처리가 반드시 필요한 경우에만 사용하는 것이 좋습니다. 그렇지 않으면 여러곳에서 트랜잭션 처리 지옥을 경험할 수 있기 때문에 필요한 곳에서만 사용할 수 있도록 비지니스 로직을 설계하고 사용하는 것이 좋습니다.</p>\n<p>다음 게시글에서는 CQRS 패턴에 대해서 정리해보겠습니다. 감사합니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jjeongil.tistory.com/1100\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://jjeongil.tistory.com/1100</a></li>\n<li><a href=\"https://cla9.tistory.com/22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cla9.tistory.com/22</a></li>\n<li><a href=\"https://velog.io/@dvmflstm/SAGA-pattern%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@dvmflstm/SAGA-pattern%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0</a></li>\n<li><a href=\"https://ichi.pro/ko/maikeulo-seobiseu-akitegcheo-saga-paeteon-ilan-mueos-imyeo-eolmana-jung-yohabnikka-94512583990635\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ichi.pro/ko/maikeulo-seobiseu-akitegcheo-saga-paeteon-ilan-mueos-imyeo-eolmana-jung-yohabnikka-94512583990635</a></li>\n</ul>\n"}},{"node":{"title":"[Architecture] MSA 개념 잡기","path":"/00-architecture-msa/","date":"21. December 2020","timeToRead":4,"description":" 마이크로 서비스 아키텍처에 대한 개념을 정리합니다 ","content":"<h1 id=\"microservice-architecture\"><a href=\"#microservice-architecture\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Microservice Architecture</h1>\n<p>크게 아키텍처는 Monolithic Architecture과 Microservice Architecture 등으로 구성됩니다.</p>\n<p>그러나 많은 회사들이 Monolithic 아키텍처의 단점으로 인해 MSA 아키텍처로 넘어가기 위해 노력하려고 합니다. 오늘은 그 차이에 대해 정리하고, 그 개념에 대해 정리해볼려고 합니다.</p>\n<br/>\n<h2 id=\"msa의-등장\"><a href=\"#msa%EC%9D%98-%EB%93%B1%EC%9E%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 등장</h2>\n<p>MSA는 microservice architecture의 약자로서, <strong>하나의 큰 어플리케이션을 여러개의 작은 어플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처</strong> 입니다.</p>\n<h3 id=\"기존-monolithic의-한계\"><a href=\"#%EA%B8%B0%EC%A1%B4-monolithic%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>기존 Monolithic의 한계</h3>\n<blockquote>\n<p>왜 필요할까요?</p>\n</blockquote>\n<p>기존의 서비스는 Monolithic Architecture의 구조를 가지고 있었습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102787038-cebc0d80-43e3-11eb-9a67-829adb6ebe51.png\" alt=\"monolithic-vs-msa\"></p>\n<p>Monolithic Architecture은 소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어 있는 서비스입니다. 현재 많은 회사들의 소프트웨어가 <strong>레거시</strong> 또는 필요로 인해서 Monolithic 형태로 구현되어 있습니다.</p>\n<p>소규모의 프로젝트에서는 Monolithic 형태는 간단하며, 유지보수가 편하기 때문에 선호됩니다.</p>\n<p>그러나 일정 규모 이상을 넘어가면 Monolithic은 많은 한계점에 봉착합니다.</p>\n<ul>\n<li>전체 시스템 구조 파악의 문제</li>\n<li>빌드 시간 및 테스트, 배포 시간의 급증</li>\n<li>서비스의 특정 부분만 scale-out을 하기 어렵습니다.</li>\n<li><strong>부분의 장애가 전체 서비스의 장애로 이어질 수도 있습니다.</strong></li>\n</ul>\n<p>이러한 이유로 인해서, MSA가 등장하게 되었습니다.</p>\n<br/>\n<h2 id=\"msa의-정의\"><a href=\"#msa%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 정의</h2>\n<p>MSA의 핵심은 <strong>small services, each running in its own process</strong> + <strong>independently deployable</strong> 으로 표현할 수 있습니다.</p>\n<p>이를 번역한다면, <strong>스스로 돌아갈 수 있는 서비스</strong>와 <strong>독립적인 배포 기능</strong>입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102787740-e8118980-43e4-11eb-8760-c52424630810.png\" alt=\"architecture-diff\"></p>\n<p>soa를 추가해서 좀 더 자세하게 보자면.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/102787984-4474a900-43e5-11eb-8a27-4e60f3aecfca.png\" alt=\"architecture-diff-2\"></p>\n<p>다음과 같이 구성됩니다.</p>\n<br/>\n<h2 id=\"msa의-장단점\"><a href=\"#msa%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 장단점</h2>\n<h3 id=\"msa의-장점\"><a href=\"#msa%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 장점</h3>\n<h4 id=\"1-배포\"><a href=\"#1-%EB%B0%B0%ED%8F%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 배포</h4>\n<ul>\n<li>서비스 별 개별 배포가 가능합니다. (배포 시 전체 서비스의 중단이 없습니다.)</li>\n<li>요구사항을 반영하여 빠르게 배포 가능합니다.</li>\n</ul>\n<h4 id=\"2-확장\"><a href=\"#2-%ED%99%95%EC%9E%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 확장</h4>\n<ul>\n<li>특정 서비스에 대한 확장성이 유리합니다. (scale-out)</li>\n<li>클라우드 사용 시 적합합니다.</li>\n</ul>\n<h4 id=\"3-장애-해결error-handling\"><a href=\"#3-%EC%9E%A5%EC%95%A0-%ED%95%B4%EA%B2%B0error-handling\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 장애 해결(Error Handling)</h4>\n<ul>\n<li>일부 장애가 전체 서비스로 확장될 가능성이 적습니다.</li>\n<li>부분적으로 발생하는 장애에 대해 격리가 수월합니다.</li>\n</ul>\n<h4 id=\"4-그-외\"><a href=\"#4-%EA%B7%B8-%EC%99%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>4. 그 외</h4>\n<ul>\n<li>새로운 기술을 적용하기 유연합니다.</li>\n<li>서비스를 polyglot(여러 언어를 사용하여)하게 개발 및 운영할 수 있습니다.</li>\n</ul>\n<h3 id=\"msa의-단점\"><a href=\"#msa%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>MSA의 단점</h3>\n<h4 id=\"1-성능-이슈\"><a href=\"#1-%EC%84%B1%EB%8A%A5-%EC%9D%B4%EC%8A%88\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 성능 이슈</h4>\n<ul>\n<li>서비스 간 호출 시 API를 사용하므로, 통신 비용이나 Latency에 대해 이슈가 존재합니다.</li>\n<li>다만 일반적으로 Monolithic에서 MSA로 넘어오는 이유가 Monolithic으로 더이상 성능적인 한계에 봉착했을 때 넘어오는 느낌이 있습니다...</li>\n<li>최근 우아한 테크 컨퍼런스에서는 이벤트 발행을 통해서 해당 부분을 해결했다고 했는데 이부분은 한번 참고해서 보면 좋을 듯 합니다.</li>\n</ul>\n<h4 id=\"2-테스트--트랜잭션\"><a href=\"#2-%ED%85%8C%EC%8A%A4%ED%8A%B8--%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 테스트 / 트랜잭션</h4>\n<ul>\n<li>서비스가 분리되어 있어 테스트와 트랜잭션의 복잡도가 증가합니다.</li>\n<li>많은 자원이 필요합니다.</li>\n</ul>\n<h4 id=\"3-데이터-관리\"><a href=\"#3-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B4%80%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 데이터 관리</h4>\n<ul>\n<li>데이터가 여러서비스에 분산되어 조회하기 어렵습니다.</li>\n<li>데이터를 관리하기 어렵습니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간단하게 MSA에 대해 개념을 잡았습니다. 다음에는 이 MSA에 대한 개념을 바탕으로 SAGA 패턴과 CQRS 패턴에 대해 작성하겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MSA 기본 개념</a></li>\n<li><a href=\"https://www.samsungsds.com/kr/insights/msa.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">마이크로서비스 아키텍처가 꼭 필요한가?</a></li>\n</ul>\n"}},{"node":{"title":"[Server] 서버리스 아키텍처에 대한 기초 지식","path":"/00-server-serverless/","date":"25. November 2020","timeToRead":13,"description":" 서버리스와 서버 아키텍처에 대한 기본 내용을 정리한 글입니다. ","content":"<h1 id=\"서버리스-아키텍처에-대하여\"><a href=\"#%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서버리스 아키텍처에 대하여</h1>\n<p>회사에서 개발과 관련해서 이야기를 하는데, CaaS, FaaS, BaaS 등에 대한 이야기를 듣게 되었다. 생각해보니 이름만 들어보고 한 번도 제대로 알아본적이 없어서 이번기회에 정리합니다.</p>\n<p>서버리스(Serverless)란 말 그대로 서버가 없다는 의미는 아닙니다. 다만, 특정 작업을 수행하기 위해서 컴퓨터 혹은 가상머신에 서버를 설정할 필요없이 다른 서비스(BaaS, FaaS) 등에 의존해서 작업을 처리합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100229273-5474a680-2f67-11eb-8a3a-467c9f409a72.png\" alt=\"image\"></p>\n<blockquote>\n<p>들어가기에 앞서서 간단한 발전 과정은 다음과 같습니다.</p>\n</blockquote>\n<p><br/>></p>\n<h2 id=\"기존-애플리케이션\"><a href=\"#%EA%B8%B0%EC%A1%B4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>기존 애플리케이션</h2>\n<h3 id=\"1-자체-설계\"><a href=\"#1-%EC%9E%90%EC%B2%B4-%EC%84%A4%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 자체 설계</h3>\n<p>시스템에서 필요한 모든 인프라를 직접 관리합니다. 기존의 <strong>전산실</strong>로 이해하면 됩니다.</p>\n<ul>\n<li>필요한 모든 인프라를 직접 관리. 예를 들어 기업 전산실에서 서버 및 하드웨어, 네트워크, 운영체제 등을 갖추어 모두 직접 처리해야합니다.</li>\n<li>시스템이 커질 수록 유지할 관리자가 필요하고, 이에 따른 비용이 발생합니다.</li>\n</ul>\n<h3 id=\"2-iaasinfrastructure-as-a-service\"><a href=\"#2-iaasinfrastructure-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. IaaS(Infrastructure as a Service)</h3>\n<p>AWS, Azure 등의 서비스에서 제공하는 서비스입니다. 서버자원, 네트워크, 전력 등의 인프라를 직접 구축할 필요없이 이러한 <strong>인프라를 가상화</strong>하여 관리하기 쉽게 해주는 서비스를 제공합니다.</p>\n<p>사용자는 해당 서비스를 통해서 관리자패널에서 인프라를 구성하면 됩니다. 사용자는 가상머신을 만들고 네트워크를 설정하고, 하드웨어를 설정하고, 운영체제를 설치해서 애플리케이션을 구동합니다.</p>\n<h3 id=\"3-paasplatform-as-a-service\"><a href=\"#3-paasplatform-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. PaaS(Platform as a Service)</h3>\n<p>IaaS에서 좀 더 추상화된 모델입니다. 네트워크, OS, 런타임을 제공합니다. 사용자는 애플리케이션만 배포하면 바로 구동할 수 있습니다. 또한 Auto Scaling 및 Load Balacing도 손쉽게 적용가능합니다.</p>\n<p>예시로는 다음과 같습니다.</p>\n<ul>\n<li>AWS Elastic Beanstalk, Azure App Servies 등등</li>\n</ul>\n<br/>\n<h2 id=\"servless\"><a href=\"#servless\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Servless</h2>\n<ul>\n<li>서버리스는 애플리케이션 개발자가 서버를 프로비저닝하거나 애플리케이션의 확장을 관리할 필요가 없습니다.</li>\n</ul>\n<blockquote>\n<p>프로비저닝(Provisioning) : 사용자의 요구에 맞게 시스템을 할당하고 배치, 배포한 이후 필요시에 시스템을 즉시 사용할 수 있는 상태로 미리 준비해놓는 것입니다.</p>\n</blockquote>\n<ul>\n<li>서버가 없다는 뜻은 아니며, 작업을 처리하는 서버는 있지만 서버를 관리할 필요가 없습니다.</li>\n<li>대표적으로 <strong>BaaS</strong> 와 <strong>FaaS</strong>로 나눠집니다.</li>\n</ul>\n<h3 id=\"1-baasbackend-as-a-service\"><a href=\"#1-baasbackend-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. BaaS(Backend as a Service)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100353200-82beb880-3031-11eb-89d9-5a361d5f88c4.png\" alt=\"image\"></p>\n<ul>\n<li>애플리케이션에서 일반 사용자가 보는 영역은 프론트엔드, 관리자가 보는 영역은 백엔드로 불립니다. <strong>이때 BaaS는 백엔드인 관리자 영역을 모듈화하여 서비스</strong>로 제공합니다.</li>\n<li>백엔드 개발(데이터 저장, 다른 기기로 접근, 파일 공유 등)이 필요한 경우, 개발자가 이러한 모든 서비스를 구축하기 어려워서, BaaS를 통해서 개발 시간을 단축합니다.</li>\n<li>IaaS, PaaS가 서버 인프라를 대체하는 정도였다면, <strong>BaaS와 FaaS는 서버 운영까지 맡기는 서비스</strong>입니다.</li>\n<li>대표적인 서비스로는 <strong>Firebase</strong>가 있습니다.</li>\n</ul>\n<p><strong>장점</strong></p>\n<ul>\n<li>개발 시간의 단축</li>\n<li>서버 확장의 불필요함</li>\n<li>백엔드에 대한 지식이 부족하더라도 빠른 속도로 개발이 가능</li>\n<li>토이 프로젝트, 소규모 프로젝트에서는 백엔드로 유용하게 사용가능</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>\n<p>클라이언트 위주의 코드</p>\n<ul>\n<li>백엔드 로직이 클라이언트 쪽에 구현됨 (보안 등의 큰 이슈)</li>\n<li>Firebase SDK를 통해 서버쪽에서 개발할 수 있지만, 이보다는 직접 구현이 좋습니다.</li>\n<li>데이터단의 로직이 변경되면 클라이언트 코드 수정이 이루어집니다.</li>\n</ul>\n</li>\n<li>\n<p>가격</p>\n<ul>\n<li>Firebase의 경우 초반에는 무료이지만, 앱의 규모가 커지면 비싸집니다.</li>\n<li>서비스 규모가 늘어날 수록 직접 구현의 장점이 가능합니다.</li>\n</ul>\n</li>\n<li>\n<p>복잡한 쿼리가 불가능함</p>\n<ul>\n<li>Firebase는 데이터 베이스가 하나의 큰 Json 형식으로 구조화 되어 있습니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-faasfunction-as-a-service\"><a href=\"#2-faasfunction-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. FaaS(Function as a Service)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100354291-468c5780-3033-11eb-8d18-e6b0ba4fdf20.png\" alt=\"image\"></p>\n<ul>\n<li>코드, <strong>함수</strong>를 서비스로 제공합니다. 애플리케이션 개발에서 함수를 실행하기 위해 서버를 올리고 런타임을 구성하고 코드를 배포해서 실행해야 하는 일련의 과정을 없애고 원하는 로직을 함수로 등록만 해놓으면 특정 이벤트시 함수가 실행되고 종료됩니다.</li>\n<li>서버가 계속 대기하면서 사용자의 요청하는 것이 아니라, 이벤트가 발생했을 때만 함수가 실행되기 때문에 함수가 실행되는 시간 및 호출된 횟수만큼만 비용을 지불합니다.</li>\n<li>PaaS의 경우는 전체 애플리케이션을 배포하여 서버에서 애플리케이션이 계속 돌아가지만, FaaS는 애플리케이션을 더 작게 쪼갠 함수를 배포하며, 특정 이벤트가 발생했을 때만 실행되고 종료됩니다.</li>\n<li>주로 서비스 사이의 간단한 작업을 처리하는 용도로 쓰이며, BaaS와 결합해서 사용하기 좋습니다. 대표적인 예시로는 AWS Lambda, 구글의 Knative, Nuclio 등이 있습니다.</li>\n</ul>\n<p><strong>장점</strong></p>\n<ul>\n<li>\n<p>비용</p>\n<ul>\n<li>특정 작업을 하기위해 서버를 준비하고 켜놓는 것이 아니라면, 필요시만 호출되기 때문에 많은 비용을 절감할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>인프라 관리</p>\n<ul>\n<li>네트워크, 장비 등에 대해 신경쓸 필요가 없습니다.</li>\n</ul>\n</li>\n<li>\n<p>인프라 보안</p>\n<ul>\n<li>리눅스 업데이트, 취약점 보안 패치 등에 큰 신경을 쓰지 않다도 됩니다.</li>\n</ul>\n</li>\n<li>\n<p>확장성</p>\n<ul>\n<li>확장성에서 굉장히 유연합니다. (AutoScaling 등의 필요없습니다. 그저 호출만 될뿐...)</li>\n</ul>\n</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>\n<p>제한</p>\n<ul>\n<li>함수에서 사용할 수 있는 자원의 제한이 존재합니다.</li>\n<li>웹소켓과 같이 계속 켜놓는 것은 사용하기 힘듭니다.</li>\n</ul>\n</li>\n<li>제공사에 대한 강한 의존</li>\n<li>\n<p>로컬 데이터 사용 불가능</p>\n<ul>\n<li>함수들은 무상태이기 때문에 이 데이터를 로컬 스토리지에 쓸수없습니다. (물론, AWS는 S3, Azure는 Storage를 사용 가능합니다.)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-정리\"><a href=\"#3-%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 정리</h3>\n<p>Serverless의 특징은 다음과 같습니다.</p>\n<ul>\n<li>\n<p>Cold Start</p>\n<ul>\n<li>클라우드 업체는 자원을 효율적으로 관리하기 위해 일정 기간 행위가 없는 사용자에게는 컴퓨팅 파워를 제공하지않습니다.</li>\n<li>비활성 함수가 갑자기 호출되면 서버가 준비되는 지연 시간이 발생하여 애플리케이션 성능에 영향을 줄 수도 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>Stateless</p>\n<ul>\n<li>함수가 없는 경우에는 모든 리소스 종류가 존재하지 않습니다.</li>\n<li>세션을 보존해야하는 경우에는 DB에 저장하는 것이 좋습니다.</li>\n</ul>\n</li>\n<li>\n<p>일시적 컨테이너</p>\n<ul>\n<li>특정 이벤트가 발생하는 일정 기간 동안에만 컨테이너에 배포되고, 그 이후는 자원이 없습니다.</li>\n<li><strong>큰 요구사항이 필요한 경우에는 적합하지 않습니다.</strong></li>\n</ul>\n</li>\n<li>\n<p>언어지원</p>\n<ul>\n<li>AWS Lambda: Node.js, Python, Java, C#, Go</li>\n<li>MS Azure: C#, Javascript, F#, Python, Batch, PHP, PowerShell</li>\n<li>Google Function: Node.js, Python, Javascript</li>\n</ul>\n</li>\n<li>\n<p>NoSQL</p>\n<ul>\n<li>함수는 제한된 데이터베이스 색인(Index)을 구성하기 때문에 서버리스 아키텍처에서 관계형 데이터베이스를 사용하면 동시 연결 수 제한으로 확장성과 성능 문제가 발생합니다.</li>\n<li>따라서 RDBMS 보다는 <strong>NoSQL</strong>이 적합합니다.</li>\n</ul>\n</li>\n</ul>\n<p>그러나. 현재는 Stateless, 일시적 컨테이너에 따른 특징으로 인해 <strong>큰 프로젝트에는 적합하지 않습니다.</strong></p>\n<br/>\n<h2 id=\"그-외\"><a href=\"#%EA%B7%B8-%EC%99%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>그 외.</h2>\n<h3 id=\"1-caascontainer-as-as-service\"><a href=\"#1-caascontainer-as-as-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. CaaS(Container as as Service)</h3>\n<p>컨테이너 기반 추상화를 통해 사용자가 애플리케이션을 배포하고 관리하도록 지원하는 클라우드 서비스 컴퓨팅 모델입니다. 제공없체는 컨테이너가 배포 및 관리되는 프레임워크 또는 오케스트레이션 플랫폼을 제공합니다.</p>\n<blockquote>\n<p>오케스트레이션(orchestration)이란?</p>\n<ul>\n<li>Container orchestration이란 컨테이너의 배포, 관리, 확장 및 네트워킹을 자동화합니다.</li>\n</ul>\n</blockquote>\n<p>클라우드 서비스의 범위에서 CaaS는 IaaS의 하위집합으로 간주되며 I<strong>aaS와 서비스 플랫폼인 PaaS 사이</strong>에 존재한다고 이해하면 됩니다.</p>\n<p>컨테이너를 사용하므로 다음과 같은 특징을 가집니다.</p>\n<ul>\n<li>이식성 : private, public 등의 다양한 환경에서 배포가능</li>\n<li>확장성 : 컨테이너의 수를 늘려서 확장할 수 있습니다.</li>\n<li>효율성 : 컨테이너는 별도의 운영체제가 필요없으므로 가상 머신(VM)보다 리소스가 적게 필요합니다.</li>\n<li>보안강화 : 컨테이너는 격리되어 있으므로 다른 컨테이너에 영향을 주지 않습니다.</li>\n<li>속도 : 운영 체제에 구애받지 않기 때문에 시작과 종료시간이 짧습니다.</li>\n</ul>\n<p>이와 같은 환경에서는 <strong>쿠버네티스</strong>를 사용하는 것이 좋습니다.</p>\n<p>쿠버네티스에 대한 간단한 정리는 아래의 링크를 보시면 좋을 듯합니다.</p>\n<p>: <a href=\"https://Azderica.github.io/backend/2020/11/10/backend-kubernetes-study/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">쿠버네티스란?</a></p>\n<h3 id=\"2dbaasdatabase-as-a-service\"><a href=\"#2dbaasdatabase-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2.DBaaS(Database as a Service)</h3>\n<p>DBaaS는 <strong>클라우드 아키텍처</strong>로서 데이터베이스 서비스 프로바이더가 하나 아싱의 서비스 소비자에게 데이터베이스 서비스를 제공하는 아키텍처, 운영 전략입니다.</p>\n<p>다음과 같은 요구사항을 만족합니다.</p>\n<ul>\n<li>리소스의 빠른 제공 및 Self-Service 동작, 데이터베이스 관리</li>\n<li>데이터베이스 서비스 사용량에 기반한 Show-back 리포트와 Charge-back 기능을 제공합니다.</li>\n</ul>\n<p>이러한 특성을 바탕으로 DBaaS는 클라우드 서비스를 통해 자원의 탄력적인 운용과 확장가능, 자동화된 자원 관리, 용량 설정 및 설계의 기능을 제공합니다.</p>\n<p>이러한 기능은 다음의 장점을 가집니다.</p>\n<ul>\n<li>비용절감</li>\n<li>\n<p>서비스 수준향상</p>\n<ul>\n<li>Self-Service Provising, 관리</li>\n<li>미리 약속된 서비스 정의</li>\n<li>Metering 및 Chargeback을 통한 IT 비용 및 활용도 측정 가능</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"정리\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>정리.</h2>\n<p>간단하게 서버리스 아키텍처에 대해 정리하였습니다. 흔히 듣던, IaaS, BaaS, PaaS, FaaS에 대해 간단하게 정리해보았고, 최근에 들었던 CaaS에 대해서도 간단하게 조사했습니다.</p>\n<p>이후 부족한 내용이나 보완되어야하는 내용이 있다면 편하게 이야기주세요.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://velopert.com/3543\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velopert.com/3543</a></li>\n<li><a href=\"https://stonesteel1023.github.io/TIL181109/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://stonesteel1023.github.io/TIL181109/</a></li>\n<li><a href=\"https://m.blog.naver.com/PostView.nhn?blogId=shakey7&#x26;logNo=221739057486&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.blog.naver.com/PostView.nhn?blogId=shakey7&#x26;logNo=221739057486&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F</a></li>\n<li><a href=\"https://www.redhat.com/ko/topics/cloud-computing/what-is-caas\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/cloud-computing/what-is-caas</a></li>\n</ul>\n"}}]}}},"context":{}}