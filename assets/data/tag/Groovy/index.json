{"hash":"a43281d937e690ee41ca21913c539571e0d27905","data":{"tag":{"title":"Groovy","belongsTo":{"edges":[{"node":{"title":"[Springboot] Gradle을 좀 더 자세하게 알아보기","path":"/03-springboot-gradle/","date":"25. October 2020","timeToRead":7,"description":" Build.Gradle에 대한 차이에 대한 글입니다. ","content":"<h1 id=\"gradle을-좀-더-파헤쳐보자\"><a href=\"#gradle%EC%9D%84-%EC%A2%80-%EB%8D%94-%ED%8C%8C%ED%97%A4%EC%B3%90%EB%B3%B4%EC%9E%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Gradle을 좀 더 파헤쳐보자.</h1>\n<p>이전글</p>\n<ul>\n<li><a href=\"./springboot-maven-gradle-difference\">Maven과 Gradle의 차이</a></li>\n<li><a href=\"./springboot-maven-gradle-change\">Maven과 Gradle로 바꾸기</a></li>\n</ul>\n<p>이전글에서 maven과 gradle에 대해 설명하고, maven에서 gradle로 바꾸는 방법에 대해서 글을 작성하였다.</p>\n<p>그러나 <code class=\"language-text\">build.gradle</code>을 구성하면서 groovy 문법에 대해서, 더 나아가서 gradle에 대해서 좀 더 상세하게 알아봐야함을 느꼈다.</p>\n<br/>\n<h2 id=\"gradle-정의\"><a href=\"#gradle-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Gradle 정의</h2>\n<p>자난번에 간략하게 설명했지만, 간략하게 설명하자면 다음과 같다.</p>\n<ul>\n<li>maven을 대체할 빌드 도구(build tool)이다.</li>\n<li>Groovy 기반의 DSL(Domain Specific Language)를 사용한다.</li>\n<li>스프링 오픈소스 프로젝트이며, 안드로이드 스튜디오에서도 사용하고 있다.</li>\n</ul>\n<p>참고 사이트 : <a href=\"https://gradle.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Gradle 공식 사이트</a></p>\n<br/>\n<h2 id=\"gradle-프로젝트에-대해\"><a href=\"#gradle-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Gradle 프로젝트에 대해</h2>\n<p>gradle의 구성은 다음과 같다. Spring gradle 에서 자주 볼수 있는 세팅이다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">.\n├── build.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradlew\n├── gradlew.bat\n├── settings.gradle\n└── src\n    ├── main\n    │   └── java\n    │       └── App.java\n    └── test\n        └── java\n            └── AppTest.java</code></pre>\n<p>하나씩 설명해보자면, 다음과 같다.</p>\n<ul>\n<li>\n<p>.gradle 폴더</p>\n<ul>\n<li>Gradle이 사용하는 폴더</li>\n<li>작업(task)로 생성된 파일이며 수정할일은 거의 없다.</li>\n</ul>\n</li>\n<li>\n<p>gralde 폴더</p>\n<ul>\n<li>Gradle이 필요한 경우 사용할 폴더</li>\n<li>Gradle 환경을 정리한 <strong>\"wrapper 파일\"</strong> 이라는 파일들이 저장되어 있다.</li>\n</ul>\n</li>\n<li>\n<p>src 폴더</p>\n<ul>\n<li>프로젝트에서 만든 프로그램 관련 폴더</li>\n<li>소스 코드 파일이나 각종 리소스 파일 등과 같이 프롲젝트에서 사용하는 파일이 있다.</li>\n<li>Maven의 구조와 비슷하다.</li>\n</ul>\n</li>\n<li>\n<p>build.gradle</p>\n<ul>\n<li>Gradle 기본 빌드 설정 파일</li>\n<li>프로젝트의 빌드 처리에 대해서 내용이 작성되어 있음</li>\n</ul>\n</li>\n<li>\n<p>gradlew, gradlew.bat</p>\n<ul>\n<li>Gradle의 명령어</li>\n<li>bat가 붙어있는 것이 window용이고, 안붙은게 macOS나 Linux용이다.</li>\n</ul>\n</li>\n<li>\n<p>settings.gradle</p>\n<ul>\n<li>프로젝트에 대한 설정 정보를 작성한 파일이다.</li>\n</ul>\n</li>\n</ul>\n<p>여기서 가장 중요한 파일은 <code class=\"language-text\">src파일</code>과 <code class=\"language-text\">build.gradle</code> 파일이다.</p>\n<br/>\n<h2 id=\"gradle의-init-명령과-type-종류\"><a href=\"#gradle%EC%9D%98-init-%EB%AA%85%EB%A0%B9%EA%B3%BC-type-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Gradle의 init 명령과 type 종류</h2>\n<p>해당 게시글은 아래의 링크에서 참고하면 좋을 듯하다.</p>\n<p>: <a href=\"http://devkuma.com/books/pages/1069\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://devkuma.com/books/pages/1069</a></p>\n<br/>\n<h2 id=\"gradle-wrapper란\"><a href=\"#gradle-wrapper%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Gradle Wrapper란.</h2>\n<p>Ant로 구성된 프로젝트는 git으로 받아서 빌드를 할려면 Ant를 설치해야한다. 그러나 이 경우, 설치와 버전이 다른 부분때문에 어려운 부분이 많다. Gradle은 이 문제를 해결하기 위해 Gradle이 실행하는 스크립트를 소스 트리 안에 포함시킨 Gradle Wrapper을 제공한다.</p>\n<p>Gradle Wrapper은 이전에 말한 gradlew/gradlew.bat으로 실행하며, 처음 실행하면 지정된 버전의 Gradle과 플러그인을 다운받아 설치해버리기 때문에 편의성을 가진다.</p>\n<p><code class=\"language-text\">gradle init</code>을 하면 자동으로 gradle wrapper가 생성되지만 <code class=\"language-text\">gradle wrapper</code>로 따로 만들 수도 있다.</p>\n<br/>\n<h2 id=\"buildgradle을-좀-더-자세하게-보면\"><a href=\"#buildgradle%EC%9D%84-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C-%EB%B3%B4%EB%A9%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>build.gradle을 좀 더 자세하게 보면.</h2>\n<p>다음과 같은 build.gradle이 있을 때.</p>\n<pre class=\"language-gradle\"><code class=\"language-gradle\">// Apply the java plugin to add support for Java\napply plugin: 'java'\n\n// Apply the application plugin to add support for building an application\napply plugin: 'application'\n\n// In this section you declare where to find the dependencies of your project\nrepositories {\n    // Use jcenter for resolving your dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n}\n\ndependencies {\n    // This dependency is found on compile classpath of this component and consumers.\n    compile 'com.google.guava:guava:22.0'\n\n    // Use JUnit test framework\n    testCompile 'junit:junit:4.12'\n}\n\n// Define the main class for the application\nmainClassName = 'App'</code></pre>\n<p>하나씩 설명하면 다음과 같다.</p>\n<h3 id=\"플러그인-추가\"><a href=\"#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%B6%94%EA%B0%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>플러그인 추가</h3>\n<pre class=\"language-gradle\"><code class=\"language-gradle\">apply plugin: 'java'</code></pre>\n<ul>\n<li>\n<p><code class=\"language-text\">apply plugin:</code></p>\n<ul>\n<li>Gradle 플러그인을 사용하기 위한 것</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">apply plugin: &#39;java&#39;</code></p>\n<ul>\n<li>Java 프로그램을 위한 기능을 제공하는 플러그인</li>\n<li>compileJava이라는 테스크는 이 java 플러그인에서 제공한다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">apply plugin: &#39;application&#39;</code></p>\n<ul>\n<li>응용 프로그램에 대한 기능을 제공하는 플러그인</li>\n<li>application 플로그인을 통해 run 응용 프로그램을 실행할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"메인-클래스-이름\"><a href=\"#%EB%A9%94%EC%9D%B8-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%9D%B4%EB%A6%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>메인 클래스 이름</h3>\n<ul>\n<li>\n<p><code class=\"language-text\">mainClassName = &#39;App&#39;</code></p>\n<ul>\n<li>application 플러그인으로 사용되는 것, 메인 클래스를 지정</li>\n<li>ruin으로 응용프로그램을 실행할 수 있는 이유가 이 mainClassName 메인 클래스가 지정되어 있기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"저장소repositories\"><a href=\"#%EC%A0%80%EC%9E%A5%EC%86%8Crepositories\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>저장소(repositories)</h3>\n<p>저장소(repositories)는 각종 프로그램들이 저장되는 위치이다. 이 저장소는 \"어떤 저장소를 사용하는지\"를 빌드 파일에 작성하여 설정할 수 있다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">mavenCentral()</code></p>\n<ul>\n<li>Apache Maven 중앙 저장소를 이용하기 위한 것.</li>\n<li>Gradle은 중앙 저장소를 그대로 사용할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">jcenter()</code></p>\n<ul>\n<li>Maven과 Gradle 등 각종 빌드 도구에서 사용할 수 있는 공개 저장소</li>\n</ul>\n</li>\n</ul>\n<p>mavenCentral()와 jcenter()는 Gradle 메소드이며 이러한 repositories 안에서 호출하여 지정된 저장소를 사용할 수 있다.</p>\n<h3 id=\"의존-라이브러리dependencies\"><a href=\"#%EC%9D%98%EC%A1%B4-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%ACdependencies\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>의존 라이브러리(dependencies)</h3>\n<p>저장소에서 필요한 라이브러리를 사용하는데 사용할 수 있는 것이 dependencies이다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">compile &#39;com.google.guava:guava:22.0&#39;</code></p>\n<ul>\n<li><strong>컴파일시 의존 라이브러리</strong> </li>\n<li>라이브러리가 컴파일 시에 참조된다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">testCompile &#39;junit:junit:4.12&#39;</code></p>\n<ul>\n<li><strong>테스트 컴파일시 의존 라이브러리</strong></li>\n</ul>\n</li>\n<li>\n<p>`calsspath '... 라이브러리 ...'</p>\n<ul>\n<li>지정된 라이브러리를 클래스 경로에 추가할 수 있다</li>\n<li>컴파일ㅅ에서 실행시까지 의존하는 라이브러리 지정에 사용한다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"implementation과-compile의-차이\"><a href=\"#implementation%EA%B3%BC-compile%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>implementation과 compile의 차이</h4>\n<p>가끔 다른 프로젝트를 보면 implementation과 compile로 되어 있는 것을 볼 수 있다. 이는 무슨 차이일까?</p>\n<p>간단하게 설명하면 다음과 같다.</p>\n<ul>\n<li>\n<p>Compile의 경우.</p>\n<ul>\n<li>A라는 모듈을 수정하게 되면 A를 간접 의존하는 B와 직접 의존하는 C가 있을 때, 둘다 재빌드한다.</li>\n</ul>\n</li>\n<li>\n<p>Implementation의 경우</p>\n<ul>\n<li>A라는 모듈의 경우, A를 직접 의존하는 C만 재빌드한다.</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"implementation의-장점\"><a href=\"#implementation%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Implementation의 장점</h5>\n<ol>\n<li>\n<p>compile보다 빠르다</p>\n<ul>\n<li>적은 recompile을 하므로 </li>\n</ul>\n</li>\n<li>\n<p>API 노출이 적다.</p>\n<ul>\n<li>Design Pattern 중 Transparency(투명도)의 장점이 드러난다.</li>\n<li>compile을 사용하게되면 연결된 모든 모듈의 API가 노출된다.</li>\n<li>그러나 Implementation은 그렇지 않다.</li>\n</ul>\n</li>\n</ol>\n<p>Gradle 3.0부터는 compile을 비추천하고 있다.</p>\n<p>참고하면 좋은 글 : <a href=\"\">https://hack-jam.tistory.com/13</a></p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"http://devkuma.com/books/pages/1064\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://devkuma.com/books/pages/1064</a></li>\n<li><a href=\"http://devkuma.com/books/pages/1068\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://devkuma.com/books/pages/1068</a></li>\n<li><a href=\"https://ddmix.blogspot.com/2019/10/get-used-to-gradle.html?m=1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ddmix.blogspot.com/2019/10/get-used-to-gradle.html?m=1</a></li>\n<li><a href=\"\">https://hack-jam.tistory.com/13</a></li>\n</ul>\n"}}]}}},"context":{}}