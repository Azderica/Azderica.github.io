{"hash":"0cbdbe3ad78e6929600cc32326d49aab3f1f64f3","data":{"tag":{"title":"Web","belongsTo":{"edges":[{"node":{"title":"[Network] LDAP이란?","path":"/00-network-ldap/","date":"19. January 2021","timeToRead":5,"description":"LDAP에 대해 작성합니다.","content":"<h1 id=\"ldap\"><a href=\"#ldap\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAP</h1>\n<p>LDAP의 개념은 들어본 사람도 있을 것이고 들어보지 못한 사람도 있을 것입니다. 업무에 대해 진행을 하다가 LDAP에 대해 들어보게 되었고 처음 듣는 개념이라 한 번 정리가 필요하다는 생각이 필요했습니다.</p>\n<br/>\n<h2 id=\"ldap의-개념\"><a href=\"#ldap%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAP의 개념</h2>\n<p>LDAP이란 <code class=\"language-text\">Lightweight Directory Access Protocol</code>의 약자로 이를 해석하면 경량 디렉터리 액세스 프로토콜로 해석됩니다. 간단하게 이야기하면 TCP/IP 위에서 <strong>디렉터리 서비스를 조회하고 수정하는 응용 프로토콜</strong>입니다.</p>\n<ul>\n<li>디렉토리 : 논리, 계급 방식 속에서 조직화된 비슷한 특성을 가진 객체들의 모임</li>\n</ul>\n<p>일반적으로 LDAP은 인증을 위한 다른 서비스에서 자주 사용됩니다. 또한 LDAP의 배치는 최상위 수준의 계급을 구조화하기 위해 도메인 이름을 사용하는데 디렉토리가 깊어질수록 이를 대표하는 항목이 나타납니다.</p>\n<p>LDAP의 개념을 이해하기 위해서는 DAP에 대해서 알면 좋습니다. X.500의 DAP은 OSI 7 계층의 전체 프로토콜 스택을 지원하는데 너무 무거운 프로토콜입니다. 그래서 <strong>DAP의 복잡성을 줄이고 TCP/IP 레이어에서 가볍게 조작할 수 있는 프로토콜, 저장소로서 특정화된 데이터베이스이며 write 작업보다는 read 작업에 적합</strong>한 것으로 탄생한 것이 LDAP입니다.</p>\n<blockquote>\n<p>X.500</p>\n</blockquote>\n<p>X.500은 전자 디렉토리 서비스를 전달하는 컴퓨터 네트워크 표준입니다. 좀 더 자세하게 알기위해서는 <code class=\"language-text\">Directory Service</code>의 개념에 대해서 이해해야하는데, 이는 <strong>OSI 7 Layer의 응용계층에 속하는 프로토콜로서 정보통신 서비스에 필요한 정보를 데이터베이스화하여 효율적으로 관리하고 사용자가 편리하게 접근하는 기능을 제공하는 서비스</strong>입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104970027-836e3c80-5a2d-11eb-8a53-ebf697fe300d.png\" alt=\"Directory-service\"></p>\n<p>Dircetory Service는 다음과 같은 형태를 가지고 있습니다.</p>\n<ul>\n<li><code class=\"language-text\">DUA</code> : Directory User Agent, 사용자와 디렉토리 간의 인터페이스 역할 수행 프로세스</li>\n<li><code class=\"language-text\">DSA</code> : Directory System Agent, 디렉토리 내 사용자의 요구 프로세스</li>\n</ul>\n<br/>\n<h2 id=\"ldap의-구성\"><a href=\"#ldap%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAP의 구성</h2>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104970321-5f5f2b00-5a2e-11eb-8e6d-b064167a8c52.png\" alt=\"ldap-component\"></p>\n<p>LDAP의 요청은 사용자나 응용프로그램에서 요청시 LDAP을 통해서 LDAP서버에 전달됩니다. 서버는 요청을 처리 후 다시 LDAP을 통해서 요청자에게 결과를 전송합니다. 기존의 DAP과 다르게 TCP/IP 상에서 운영됩니다.</p>\n<br/>\n<h2 id=\"ldap의-구조\"><a href=\"#ldap%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAP의 구조</h2>\n<p>LDAP의 구조는 크게 4가지로 구분됩니다.</p>\n<p>너무 깊게 들어가면 내용적으로 이해하기 힘들 것 같아 개념만 정리하겠습니다.</p>\n<h3 id=\"information-모델\"><a href=\"#information-%EB%AA%A8%EB%8D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Information 모델</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104970313-58d0b380-5a2e-11eb-9115-a9c1a527bc38.png\" alt=\"ldap-hierarchical\"></p>\n<p><strong>정의</strong> : LDAP의 데이터에 대한 종류와 디렉토리에 저장되는 정보에 대한 기본 단위를 정의합니다. 기본적으로 Entries, Attributes, Values 3가지로 정의됩니다.</p>\n<ul>\n<li>Entry : 디렉토리 정보에 대한 기본단위</li>\n<li>Attribute : Entry를 구성하는 단위</li>\n<li>Value : Attribute의 실질적인 데이터</li>\n</ul>\n<h3 id=\"naming-모델\"><a href=\"#naming-%EB%AA%A8%EB%8D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Naming 모델</h3>\n<p><strong>정의</strong> : 데이터를 어떻게 구성하고 참조할 것인지에 대해 정의합니다.</p>\n<h3 id=\"functional-모델\"><a href=\"#functional-%EB%AA%A8%EB%8D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Functional 모델</h3>\n<p><strong>정의</strong> : 디렉토리 트리의 데이터에 접근하는 방법에 대해 정의합니다. 크게 3가지 그룹으로 구성합니다.</p>\n<ul>\n<li>Interrogation(질문) 작업 : 디렉토리 Entry를 검색 및 비교하는 기능</li>\n<li>Update(갱신) 작업 : 디렉토리 Entry의 추가, 삭제, 변경 등의 기능</li>\n<li>Authentication(인증) 및 Control(제어) 작업 : 클라이언트의 확인 및 제어 기능(Bind, Unbind, Abandon)</li>\n</ul>\n<h3 id=\"secruity-모델\"><a href=\"#secruity-%EB%AA%A8%EB%8D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Secruity 모델</h3>\n<p>인증된 접근만 디렉토리 내 정보를 제공합니다.</p>\n<br/>\n<h2 id=\"ldap-version\"><a href=\"#ldap-version\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAP Version</h2>\n<p>현재 version 3까지 나왔습니다.</p>\n<h3 id=\"ldapv1-vs-ldap-v2\"><a href=\"#ldapv1-vs-ldap-v2\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAPv1 vs LDAP v2</h3>\n<ul>\n<li>LDAPv2는 인증과정없이 LDAP 서버에 Bind 되는 것이 허용됩니다.</li>\n<li>READ, List Operation이 삭제되었습니다.</li>\n<li>클라이언트는 오직 하나의 서버에만 연결가능하도록 바뀌었습니다.(DAP의 Referral 기능을 제공하지않습니다.)</li>\n</ul>\n<h3 id=\"ldapv2-vs-ldap-v3\"><a href=\"#ldapv2-vs-ldap-v3\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAPv2 vs LDAP v3</h3>\n<ul>\n<li>Referral을 통해서 분산 기능이 생겼습니다.</li>\n<li>사용자 정의 Attribute와 Object 생성이 가능합니다.</li>\n<li>UTF-8 Encoding을 이용해서 언어를 표현하는 제약이 완화되었고 다양한 언어 사용이 가능합니다.</li>\n<li>사용자 정의 Matching Rule이 생성 가능합니다.</li>\n<li>보안성이 올라갔습니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간략하게 개념을 잡는다고 생각하고 내용을 정리했습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://ldap.or.kr/ldap-%EC%9D%B4%EB%9E%80/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ldap.or.kr/ldap-%EC%9D%B4%EB%9E%80/</a></li>\n<li><a href=\"https://velog.io/@kante/LDAP-%EC%9D%B4%EB%9E%80\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@kante/LDAP-%EC%9D%B4%EB%9E%80</a></li>\n<li><a href=\"https://medium.com/@hmj2088/ldap-dc771e2704a9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/@hmj2088/ldap-dc771e2704a9</a></li>\n</ul>\n"}},{"node":{"title":"[WEB] Webpack이란","path":"/00-web-webpack/","date":"18. January 2021","timeToRead":5,"description":"Webpack에 대해 정리합니다.","content":"<h1 id=\"webpack\"><a href=\"#webpack\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Webpack</h1>\n<p>FE(Front-End)에 대해서 공부를 하다보면 한번쯤은 Webpack에 대한 개념을 듣게 되는데 이에 대해 알아보겠습니다.</p>\n<br/>\n<h2 id=\"webpack의-정의\"><a href=\"#webpack%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Webpack의 정의</h2>\n<p>웹팩이란 <strong>오픈 소스 자바스크립트 모듈 번들러</strong>입니다. 주로 JS를 위한 모듈 번들러지만 호환 플러그인을 포함하는 경우 HTML, CSS, 이미지 등의 자산들을 변환할 수 있으며 의존성이 있는 모듈들을 취하여 해당 모듈을 대표하는 정적 자산을 만들어 냅니다.</p>\n<p>웹팩은 의존성을 취한 다음 의존성 그래프를 만듦으로서 웹 개발자들이 웹 어플리케이션 개발 목적을 위해 모듈 방식의 접근을 사용할 수 있게 도와줍니다. 명령 중을 통해서 사용할 수 있으며 <code class=\"language-text\">webpack.config.js</code> 이라는 이름의 구성 파일을 사용해서 구성할 수 있습니다. 이 파일을 사용하여 프로젝트를 위해 로더나 플러그인 등을 정리할 수 있습니다. <code class=\"language-text\">createapp.dev</code>라는 이름의 도구는 구성 파일의 생성과정을 단순하게 만들어 줍니다.</p>\n<p>웹 팩의 설치에는 Node.js가 요구됩니다.</p>\n<blockquote>\n<p>Bundler란?</p>\n</blockquote>\n<ul>\n<li>소프트웨어 및 일부의 하드웨어와 함께 <strong>작동하는데 필요한 모든 것을 포함하는 Package</strong>입니다.</li>\n<li>각각의 모듈에 대해 의존성 관계를 파악하여 하나 또는 여러개의 그룹으로 볼 수 있습니다.</li>\n</ul>\n<br/>\n<h2 id=\"webpack의-필요성\"><a href=\"#webpack%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Webpack의 필요성</h2>\n<p>현재의 웹 개발은 복잡한 자바스크립트와 대규모 의존성 트리를 가지고 있는 다양한 기능을 갖춘 웹 애플리케이션으로 발전했으며, 이러한 복잡성은 꾸준하게 커져갔습니다.</p>\n<p>이러한 복잡성을 대응하기 위해서 Webpack이 등장하였습니다. 규모가 있는 System에서 많은 자바스크립트 파일이 존재하고 이러한 자바스크립트 파일 하나로 관리하기 위해서 Webpack을 사용합니다.</p>\n<p>만약 자바스크립트를 여러개로 호출하게 되면 여러개의 파일을 브라우저에 로딩하므로 네트워크 비용이 커져서 반응속도가 느려지고 각 파일의 충돌의 위험성도 존재합니다.</p>\n<br/>\n<h2 id=\"webpack과-다른-도구들의-차이\"><a href=\"#webpack%EA%B3%BC-%EB%8B%A4%EB%A5%B8-%EB%8F%84%EA%B5%AC%EB%93%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Webpack과 다른 도구들의 차이</h2>\n<p>다른 도구들로 Browsify, Grunt, Gulp 등의 도구들이 있지만 이는 Webpack과 시스템적으로나 성능적으로 차이가 납니다.</p>\n<h3 id=\"grunt-gulp\"><a href=\"#grunt-gulp\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Grunt, Gulp</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104858365-e4304300-5961-11eb-917f-87ec9d8f523d.png\" alt=\"grunt-gulp-build\"></p>\n<p>Grunt나 Gulp 등의 빌드 툴은 정의한 경로에서 구성과 일치한 파일을 찾습니다. 따라서 구성파일에서 이러한 파일들을 변환하고 조합 및 축소하는 단계를 지정해야합니다.</p>\n<h3 id=\"webpack의-빌드-방법\"><a href=\"#webpack%EC%9D%98-%EB%B9%8C%EB%93%9C-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Webpack의 빌드 방법</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104858360-d4186380-5961-11eb-91cd-c59c9b856589.png\" alt=\"webpack-build\"></p>\n<p>그러나 Webpack은 <strong>프로젝트 전체를 한단위로 분석</strong>합니다. 지정한 메인 파일에서 시작해서 자바스크립트의 <code class=\"language-text\">require(webpack commonJS 모듈 지원)</code>과 <code class=\"language-text\">import(ES6)</code>문을 참고해서 <strong>프로젝트의 모든 의존성을 조사하고 로더를 이용해 처리한 후 번들로 묶은 자바스크립트 파일을 생성</strong>합니다.</p>\n<p>Webpack는 다른 도구에 비해 아래의 장점이 있습니다.</p>\n<ul>\n<li>크고 복잡한 다양한 리소스가 존재하는 프로젝트에서 유리합니다,</li>\n<li>Grunt, Gulp는 오로지 리소스들에 대한 툴로 사용되며 dependency graph의 개념이 없습니다.</li>\n<li>Browsify는 비슷한 도구이지만 속도면에서 webpack이 좋습니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>Webpack을 좀 더 공부하기 위해서는 <code class=\"language-text\">Node.js</code>을 통해 공부해야하는데, Node.js에 대해 글을 작성하게 되면 너무 길어질 듯하여 간단하게 내용만 정리했습니다.</p>\n<p>좀 더 상세한 내용은 다른 게시글을 통해 정리하겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://nesoy.github.io/articles/2019-02/Webpack\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://nesoy.github.io/articles/2019-02/Webpack</a></li>\n<li><a href=\"https://jusungpark.tistory.com/52\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://jusungpark.tistory.com/52</a></li>\n<li><a href=\"https://ko.wikipedia.org/wiki/%EC%9B%B9%ED%8C%A9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ko.wikipedia.org/wiki/%EC%9B%B9%ED%8C%A9</a></li>\n</ul>\n"}},{"node":{"title":"[Network] NGINX란?","path":"/00-network-nginx/","date":"14. January 2021","timeToRead":3,"description":"NGINX에 대해 작성합니다.","content":"<h1 id=\"nginx란\"><a href=\"#nginx%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nginx란.</h1>\n<h2 id=\"nignx의-정의\"><a href=\"#nignx%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nignx의 정의.</h2>\n<p>Nginx는 가벼움과 높은 성능을 목표로 하는 웹서버 소프트웨어입니다.</p>\n<p>이러한 Nginx는 트래픽이 많은 웹사이트를 위해 확장성을 위해 설계한 비동기 이벤트 기반 구조를 가지고 있습니다.</p>\n<p>일반적으로 <strong>웹 서버, 리버스 프록시 및 메일 프록시</strong> 기능을 가집니다.</p>\n<br/>\n<h2 id=\"apache-vs-nginx\"><a href=\"#apache-vs-nginx\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Apache VS Nginx</h2>\n<p>주로 Nginx는 Apache 서버와 비교를 하는데, 현재는 Nginx가 1위를 차지하고 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104517057-bd5bcf00-5638-11eb-8e24-859c5bf2ee88.png\" alt=\"server-rank\"></p>\n<blockquote>\n<p>Apache</p>\n</blockquote>\n<ul>\n<li>쓰레드 / 프로세스 기반 구조로 요청 하나당 쓰레드 하나가 처리하는 구조입니다.</li>\n<li>사용자가 많으면 많은 쓰레드가 생성되고, 메모리와 CPU 낭비가 심합니다.</li>\n</ul>\n<blockquote>\n<p>Nginx</p>\n</blockquote>\n<ul>\n<li>비동기 Event-Driven 기반의 구조입니다.</li>\n<li>다수의 연결을 효과적으로 처리가능합니다.</li>\n<li>대부분의 코어 모듈이 Apache보다 적은 리소스로 더 빠르게 동작가능합니다.</li>\n<li>더 작은 쓰레드로 클라이언트의 요청들을 처리 가능합니다.</li>\n</ul>\n<p>Apache와 Nginx의 가장 큰 차이는 Thread 방식과 Event-drive의 차이입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104517420-4bd05080-5639-11eb-92a5-dc3f78cc5891.png\" alt=\"Thread-VS-Event-Driven\"></p>\n<p>다음 그림처럼 쓰레드 기반은 하나의 커넥션 당 하나의 쓰레드를 사용하지만, Event-driven 방식은 여러 커넥션을 모두 Event-Handler를 통해 비동기 방식으로 처리해서 먼저 처리되는 것부터 로직이 진행됩니다.</p>\n<br/>\n<h2 id=\"nginx-활용\"><a href=\"#nginx-%ED%99%9C%EC%9A%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nginx 활용</h2>\n<p>Nginx은 다음과 같은 기능으로 사용할 수 있습니다.</p>\n<ul>\n<li>\n<p>HTTP Server</p>\n<ul>\n<li>정적 파일을 처리하는 web server의 역할을 수행합니다.</li>\n</ul>\n</li>\n<li>\n<p>Reverse proxy server</p>\n<ul>\n<li>클라이언트의 요청을 Application server에 배분합니다.</li>\n<li>클라이언트 80포트 요청을 8080, 8081 등 여러 Application server로 보내줍니다.</li>\n<li>각 application server에 요청을 배분해서 부하를 분산합니다. (load balancing)</li>\n</ul>\n</li>\n<li>Mail proxy server</li>\n<li>Generic TCP/UDP proxy server</li>\n</ul>\n<br/>\n<h2 id=\"nginx-proxy\"><a href=\"#nginx-proxy\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nginx Proxy</h2>\n<p>node.js에서 nginx.conf를 파일을 수정하여 아래처럼 수정하면됩니다.</p>\n<pre class=\"language-conf\"><code class=\"language-conf\">server {\n  listen    81;\n  server_name localhost;\n\n  location / {\n    proxy_pass http://127.0.0.1:3000/;\n  }\n}</code></pre>\n<p>다음과 같이 수정을 하게 되면, 81번 포트로 접속을 해도 3000번 포트의 서버에 접속이 되게됩니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>오늘은 간략하게 Nginx에 대해 정리해보았습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"http://nginx.org/en/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://nginx.org/en/</a></li>\n<li><a href=\"https://news.netcraft.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://news.netcraft.com/</a></li>\n<li><a href=\"https://smjeon.dev/etc/nginx/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://smjeon.dev/etc/nginx/</a></li>\n<li><a href=\"https://m.blog.naver.com/jhc9639/220967352282\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.blog.naver.com/jhc9639/220967352282</a></li>\n</ul>\n"}},{"node":{"title":"[Web] Web Component","path":"/00-web-webcomponent/","date":"11. January 2021","timeToRead":4,"description":"Web Component에 대해 정리합니다.","content":"<h1 id=\"web-component\"><a href=\"#web-component\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Web Component</h1>\n<p>웹 기술에 대해서 듣다보면, 코드를 재 사용을 해야할 경우가 필요합니다. 그에 대한 핵심 기술인 웹 컴포넌트에 대해 정리합니다.</p>\n<h2 id=\"web-component의-개념\"><a href=\"#web-component%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Web Component의 개념</h2>\n<p>웹 컴포넌트는 기능을 나머지 코드로부터 캡슐화하여 재사용 가능한 커스텀 엘리먼트를 생성하고 웹 앱에서 활용할 수 있도록 해주는 다양한 기술들의 모음입니다.</p>\n<br/>\n<h2 id=\"web-component의-기술\"><a href=\"#web-component%EC%9D%98-%EA%B8%B0%EC%88%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Web Component의 기술</h2>\n<p>3가지의 기술들로 구성됩니다. 재사용을 운하는 어느 곳이든 코드 충돌에 대한 걱정이 없는 캡슐화된 기능을 갖춘 다용도의 <strong>커스텀 엘리먼트를 생성</strong>하기 위해 함께 사용할 수 있습니다.</p>\n<h3 id=\"custom-elements\"><a href=\"#custom-elements\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Custom elements</h3>\n<p>사용자 인터페이스에서 원하는 대로 사용할 수 있는 사용자 정의 요소 및 해당 동작을 정의할 수 있는 JavaScript API 세트입니다.</p>\n<h4 id=\"간단한-예제\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%98%88%EC%A0%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>간단한 예제.</h4>\n<p>간단한 에시로, <code class=\"language-text\">window.customElements</code>의 <code class=\"language-text\">define()</code> 메서드를 이용합니다. 해당 메서드는 아래 3개의 arguments를 받아 custom element를 사용합니다.</p>\n<ul>\n<li><code class=\"language-text\">DOMString</code> : custom element의 이름입니다.</li>\n<li><code class=\"language-text\">class extends HTMLElment</code> : element의 행동을 정의한 class입니다.</li>\n<li><code class=\"language-text\">{ extends }</code> : inherits할 node name입니다. (optional)</li>\n</ul>\n<pre class=\"language-js\"><code class=\"language-js\">customElements<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">define</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'text-sample'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">extends</span> <span class=\"token maybe-class-name\">HTMLElement</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// always call</span>\n\n      <span class=\"token comment\">// element functionality</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span></code></pre>\n<h3 id=\"shadow-dom\"><a href=\"#shadow-dom\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Shadow DOM</h3>\n<p>캡슐화된 shadow DOM 트리를 element(메인 다큐먼트 DOM으로부터 독집적으로 렌더링 되는)를 추가하고 연관된 기능을 제어하기 위한 JavaScript API 집합입니다. 이 방법을 통해서 엘리먼트의 기능을 private하게 유지할 수 있어서 다큐먼트의 다른 부분과 출돌없이 스크립트와 스타일을 작성할 수 있습니다.</p>\n<p>다음의 HTML 파일이 있을 때,</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">html</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charste</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>utf-8<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>Simple DOM<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>section</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>dinosaur.png<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>T-Rex<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>\n        Here we will add a link to the\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://www.mozilla.org/<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Mozilla<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>section</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>DOM은 아래와 같은 구성을 가지고 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104188740-12db8480-545d-11eb-8bab-1655175db87f.png\" alt=\"image\"></p>\n<p>이를 시각화하면 다음과 같이 표현할 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104189398-f3912700-545d-11eb-8b69-9d74a0dc71af.png\" alt=\"image\"></p>\n<p>다음에서 하나씩 설명하면 다음과 같습니다.</p>\n<ul>\n<li><code class=\"language-text\">shadow host</code> : 일반적인 DOM 노드처럼 보이는 Shadow DOM 연결 지점을 의미합니다.</li>\n<li><code class=\"language-text\">shadow tree</code> : Shadow DOM 내부의 DOM Tree</li>\n<li><code class=\"language-text\">shadow boundary</code> : Shadow DOM의 시작 노드부터 끝 노드까지의 공간입니다.</li>\n<li><code class=\"language-text\">shadow root</code> : Shadow tree의 root 노드</li>\n</ul>\n<p>다음과 같이 의미합니다.</p>\n<h4 id=\"간단한-예제-1\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%98%88%EC%A0%9C-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>간단한 예제.</h4>\n<pre class=\"language-js\"><code class=\"language-js\">customElements<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">define</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'open-shadow'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">extends</span> <span class=\"token maybe-class-name\">HTMLElement</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token keyword\">const</span> pElem <span class=\"token operator\">=</span> <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">)</span>\n      pElem<span class=\"token punctuation\">.</span><span class=\"token property-access\">textContent</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">getAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">'text'</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token keyword\">const</span> shadowRoot <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">attachShadow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> mode<span class=\"token operator\">:</span> <span class=\"token string\">'open'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      shadowRoot<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">appendChild</span><span class=\"token punctuation\">(</span>pElem<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span></code></pre>\n<h3 id=\"html-템플릿\"><a href=\"#html-%ED%85%9C%ED%94%8C%EB%A6%BF\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>HTML 템플릿</h3>\n<p><code class=\"language-text\">&lt;template&gt;</code>와 <code class=\"language-text\">&lt;slot&gt;</code> 엘리먼트는 렌더링 페이지에 나타나지 않는 마크업 템플릿을 작성할 수 있습니다. 커스텀 엘리먼트의 구조를 기반으로 여러번 재사용할 수 있습니다.</p>\n<h4 id=\"간단한-예제-2\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%98%88%EC%A0%9C-2\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>간단한 예제.</h4>\n<pre class=\"language-js\"><code class=\"language-js\">customElements<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">define</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'my-paragraph'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">extends</span> <span class=\"token maybe-class-name\">HTMLElement</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token keyword\">const</span> template <span class=\"token operator\">=</span> <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'my-paragraph'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">const</span> templateContent <span class=\"token operator\">=</span> template<span class=\"token punctuation\">.</span><span class=\"token property-access\">content</span>\n\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">attachShadow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> mode<span class=\"token operator\">:</span> <span class=\"token string\">'open'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">appendChild</span><span class=\"token punctuation\">(</span>\n        templateContent<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">cloneNode</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> slottedSpan <span class=\"token operator\">=</span> <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'my-paragraph span'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>slottedSpan<span class=\"token punctuation\">.</span><span class=\"token property-access\">assignedSlot</span><span class=\"token punctuation\">)</span>\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>slottedSpan<span class=\"token punctuation\">.</span><span class=\"token property-access\">slot</span><span class=\"token punctuation\">)</span></code></pre>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>좀 더 자세한 코드를 보고 싶으면 아래의 예제를 참고하면 좋습니다.</p>\n<ul>\n<li><a href=\"https://github.com/mdn/web-components-examples/blob/master/composed-composed-path/main.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN Examples</a></li>\n</ul>\n<p>잚못된 부분이 있으면 편하게 이야기주세요.</p>\n<hr>\n<p><strong>마무리</strong></p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/Web_Components\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://developer.mozilla.org/ko/docs/Web/Web_Components</a></li>\n</ul>\n"}},{"node":{"title":"[WEB] Socket 통신 vs Http 통신","path":"/00-web-socket/","date":"4. January 2021","timeToRead":3,"description":"Socket 통신과 HTTP 통신의 차이에 대해 서술합니다.","content":"<h1 id=\"socket-통신-vs-http-통신\"><a href=\"#socket-%ED%86%B5%EC%8B%A0-vs-http-%ED%86%B5%EC%8B%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Socket 통신 VS HTTP 통신</h1>\n<p>오늘은 웹에서 통신하는 대표적인 방식인 두 방식의 차이에 대해 서술하겠습니다.</p>\n<h2 id=\"socket-통신\"><a href=\"#socket-%ED%86%B5%EC%8B%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Socket 통신</h2>\n<p>Socket 통신을 한마지로 표현하자면, <strong>Server와 Client가 특정 Port를 통해 실시간으로 양방향 통신을 하는 방식</strong>입니다.</p>\n<h3 id=\"socket-통신의-구조\"><a href=\"#socket-%ED%86%B5%EC%8B%A0%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Socket 통신의 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103532675-042a2600-4ecf-11eb-815c-b73529445021.png\" alt=\"Socket통신\">\n출처 : <a href=\"https://mangkyu.tistory.com/48\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://mangkyu.tistory.com/48</a></p>\n<p>특정 포트를 통해 연결하여 실시간 양방향 통신을 합니다. 서버 또한 요청을 보낼 수 있고, 실시간으로 요청을 보낼 수 있기 때문에 양방향 정보 교환에서 유리한 점을 가집니다. 만약에 동영상 스트리밍이나 게임 서비스를 socket통신을 하지 않고 하는 경우에는 계속적인 연결요청이 가므로, 과부하가 걸리게 됩니다.</p>\n<h3 id=\"socket-통신의-특징\"><a href=\"#socket-%ED%86%B5%EC%8B%A0%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Socket 통신의 특징</h3>\n<ul>\n<li>Server와 Client가 계속 연결을 유지하는 <strong>양방향 통신</strong>입니다.</li>\n<li>Server와 Client가 실시간으로 데이터를 주고 받는 상황이 필요한 경우에 주로 사용됩니다.</li>\n<li>실시간 동영상 Streaming이나 온라인 게임 등과 같은 경우에 자주 사용됩니다.</li>\n</ul>\n<br/>\n<h2 id=\"http-통신\"><a href=\"#http-%ED%86%B5%EC%8B%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>HTTP 통신</h2>\n<h3 id=\"http-통신의-구조\"><a href=\"#http-%ED%86%B5%EC%8B%A0%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>HTTP 통신의 구조.</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103532658-feccdb80-4ece-11eb-8085-2cb7d7f83d8d.png\" alt=\"HTTP통신\">\n출처 : <a href=\"https://mangkyu.tistory.com/48\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://mangkyu.tistory.com/48</a></p>\n<p>client의 요청(Request)이 있을 때만 서버가 응답(response)하여 해당 정보를 전송하고 곧바로 연결을 종료하는 방식입니다. 일반적으로 request를 보냈을 때, 내용을 기다리는시간과 연결하는 시간이 필요하기 때문에 해당 통신은 콘텐츠 위주의 데이터를 사용할 때 유용합니다.</p>\n<h3 id=\"http-통신의-특징\"><a href=\"#http-%ED%86%B5%EC%8B%A0%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>HTTP 통신의 특징</h3>\n<ul>\n<li>Client가 요청을 보내는 경우에만 Server가 응답하는 <strong>단방향 통신</strong>입니다.</li>\n<li>Server로부터 응답을 받은 후에는 연결이 바로 종료가 됩니다.</li>\n<li>실시간 연결이 아니고, 필요한 경우에만 Server로 요청을 보내는 상황에 유용합니다.</li>\n<li>요청을 보내 Server의 응답을 기다리는 어플리케이션 개발에 주로 사용됩니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>HTTP 통신과 Socket 통신에 대해 알아보았습니다. 가장 큰 차이 중 하나는 단방향 통신과 양방향 통신의 차이입니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://velog.io/@ejchaid/http\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@ejchaid/http</a></li>\n<li><a href=\"https://mangkyu.tistory.com/48\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://mangkyu.tistory.com/48</a></li>\n</ul>\n"}},{"node":{"title":"[Springboot] CORS 이슈 해결하기","path":"/00-springboot-cors/","date":"27. December 2020","timeToRead":2,"description":" Springboot CORS에 대한 해결방법입니다.","content":"<h1 id=\"springboot-cors-이슈-해결하기\"><a href=\"#springboot-cors-%EC%9D%B4%EC%8A%88-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Springboot CORS 이슈 해결하기.</h1>\n<p>지난 게시글에서는 CORS 이슈에 대해 정리했습니다.</p>\n<ul>\n<li><a href=\"https://Azderica.github.io/00-web-cors/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CORS란.</a></li>\n</ul>\n<p>회사 보안 정책에 따라서, 웹페이지에 허용되는 HTTP 메소드가 제한되는 경우가 있습니다. 저 또한 회사에서 이러한 업무를 해야하는 경우가 있기 때문에 이에 대해 한번 정리합니다.</p>\n<p>이러한 CORS 이슈를 스프링 부트에서 해결하는 방법에 대해서 코드를 작성해볼려고합니다.</p>\n<h2 id=\"custom-filter-사용\"><a href=\"#custom-filter-%EC%82%AC%EC%9A%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Custom Filter 사용.</h2>\n<p>인터넷에서 CORS 이슈에 대한 해결책을 찾아보면 Spring은 쉽게 확인할 수 있는데, Sprinboot에 대한 글이 별로 없어 이를 작성했습니다.</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mvc</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">dispatch-options-request</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span></code></pre>\n<p>yaml 파일에서는 다음과 같이 추가했습니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomFilter</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Filter</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">FilterConfig</span> filterConfig<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ServletException</span> <span class=\"token punctuation\">{</span>   <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doFilter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ServletRequest</span> servletRequest<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ServletResponse</span> servletResponse<span class=\"token punctuation\">,</span> <span class=\"token class-name\">FilterChain</span> chain<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ServletException</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">HttpServletRequest</span> request <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletRequest</span><span class=\"token punctuation\">)</span> servletRequest<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletResponse</span><span class=\"token punctuation\">)</span> servletResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Access-Control-Allow-Origin\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"*\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletResponse</span><span class=\"token punctuation\">)</span> servletResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Access-Control-Allow-Methods\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"GET, OPTIONS, HEAD, POST\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletResponse</span><span class=\"token punctuation\">)</span> servletResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Access-Control-Allow-Headers\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Origin, X-Requested-With, Content-Type, Accept\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">HttpServletResponse</span> resp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletResponse</span><span class=\"token punctuation\">)</span> servletResponse<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">getMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"OPTIONS\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      resp<span class=\"token punctuation\">.</span><span class=\"token function\">setStatus</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpServletResponse</span><span class=\"token punctuation\">.</span>SC_OK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    chain<span class=\"token punctuation\">.</span><span class=\"token function\">doFilter</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> servletResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">destroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>기존의 Filter를 상속받아서 다음과 같이 수정합니다.</p>\n<p>이를 메소드 점검해보면 다음과 같습니다.</p>\n<pre class=\"language-sh\"><code class=\"language-sh\">curl -v -X OPTIONS {url}</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103171817-7cbb3200-4892-11eb-9a4a-d1125fc46506.png\" alt=\"image\"></p>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>다만 의문점 중 하나는 <strong>TRACE를 막는 방법</strong>에 대해서는 아직 확인 중에 있습니다.</p>\n<p>특히 <code class=\"language-text\">curl -v -X TRACE {url}</code> 와 <code class=\"language-text\">curl -v -X trace {url}</code> 이 다른 결과 값을 나타내는 것을 확인할 수 있습니다.</p>\n<p>이에 대해서는 좀 더 명확한 답을 추가해서 글에 추가를 해놓겠습니다. 혹시라도 답을 아시거나 잘못된 부분이 있으면 이야기주세요. 감사합니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://webhack.dynu.net/?idx=20161110.001&#x26;print=friendly\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://webhack.dynu.net/?idx=20161110.001&#x26;print=friendly</a></li>\n</ul>\n"}},{"node":{"title":"[WEB] CORS","path":"/00-web-cors/","date":"26. December 2020","timeToRead":6,"description":" CORS에 대한 개념을 잡습니다. ","content":"<h1 id=\"corscross-origin-resource-sharing\"><a href=\"#corscross-origin-resource-sharing\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CORS(Cross-Origin Resource Sharing)</h1>\n<p>웹 개발을 하게 되면, 반드시 보게되는 이슈입니다. 그러나 이에 대한 개념에 대해 정확하게 모른다는 생각이 들어 정리합니다.</p>\n<br/>\n<h2 id=\"cors의-정의\"><a href=\"#cors%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CORS의 정의</h2>\n<p>CORS(Cross-Origin Resource Sharing)은 <strong>추가 HTTP 헤더를 사용</strong>하여, <strong>하나의 출처(origin)에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 권한을 부여하도록 브라우저에 알려주는 체제</strong>입니다.</p>\n<p><strong>하나의 출처</strong>란? URL의 프로토콜, 호스트, 포트가 동일한 경우를 의미합니다.</p>\n<p>일반적으로는 다른 출처(origin)에서 내 자원(resource)에 함부로 접근하지 못하게 하기 위해 사용됩니다.</p>\n<p>일반적으로 <strong>요청 헤더 목록</strong>은 다음과 같습니다.</p>\n<ul>\n<li>\n<p>Origin</p>\n<ul>\n<li>fetch가 시작되는 위치.</li>\n<li>경로 정보는 포함이 되지않고 서버 이름만 포함됨.</li>\n</ul>\n</li>\n<li>\n<p>Access-Control-Request-Method</p>\n<ul>\n<li><code class=\"language-text\">preflight request</code> 을 할 때, 실제 요청에서 어떤 메소드를 사용할지 서버에 알려줍니다.</li>\n</ul>\n</li>\n<li>\n<p>Access-Control-Request-Headers</p>\n<ul>\n<li><code class=\"language-text\">preflight request</code> 을 할 때, 실제 요청에서 어떤 header를 사용할 것인지 서버에서 알리기 위해 사용됩니다.</li>\n</ul>\n</li>\n</ul>\n<p><strong>응답 헤더 목록</strong>은 다음과 같습니다.</p>\n<ul>\n<li>\n<p>Access-Control-Allow-Origin</p>\n<ul>\n<li>브라우저가 해당 origin이 자원에 접근할 수 있도록 허용합니다.</li>\n<li><code class=\"language-text\">*</code> 은 credentials이 없는 요청에 한해서 모든 origin에서 접근이 가능하도록 허용합니다.</li>\n</ul>\n</li>\n<li>\n<p>Access-Control-Expose-Headers</p>\n<ul>\n<li>브라우저가 액세스할 수 있는 서버의 화이트리스트 헤더를 허용합니다.</li>\n</ul>\n</li>\n<li>\n<p>Access-Control-Max-Age</p>\n<ul>\n<li>얼마나 오랫동안 <code class=\"language-text\">preflight request</code>가 캐싱될 수 있는지를 나타냅니다.</li>\n</ul>\n</li>\n<li>\n<p>Access-Control-Allow-Credential</p>\n<ul>\n<li><code class=\"language-text\">Credentials</code>가 true일 때 요청에 대한 응답이 노출될 수 있는지를 나타냅니다.</li>\n<li><code class=\"language-text\">preflight request</code> 에 대한 응답의 일부로 사용되는 경우, 실제 자격 증명을 사용하여 실제 요청을 수행 할 수 있는지를 나타냅니다.</li>\n<li>간단한 GET 요청의 경우에는 <code class=\"language-text\">preflight</code> 되지 않으므로 자격 증명이 필요한 리소스를 요청하면 헤더가 리소스와 함께 반환되지 않으며 브라우저에서 응답을 무시하고 웹 콘텐츠로 반환하지 않습니다.</li>\n</ul>\n</li>\n<li>\n<p>Access-Control-Allow-Methods</p>\n<ul>\n<li><code class=\"language-text\">preflight request</code> 에 대한 응답으로 허용되는 메서드들을 나타냅니다.</li>\n<li>일반적으로 회사에서 보안 상의 이유로 http 메소드를 제한하는 경우, 이 헤더를 많이 사용합니다.</li>\n</ul>\n</li>\n<li>\n<p>Access-Control-Allow-Headers</p>\n<ul>\n<li><code class=\"language-text\">preflight</code> 요청에 대한 응답으로 실제 요청 시 사용할 수 있는 HTTP 헤더를 나타냅니다.</li>\n</ul>\n</li>\n</ul>\n<p><strong>preflight request</strong>란? <strong>미리 전송(사전요청)</strong>을 의미합니다. 이는 본격적인 교차 HTTP 요청 전에 서버 측에서 그 요청의 메서드와 헤더에 대한 인식을 진행하는 지 확인합니다.</p>\n<p>이는 위에 있는 HTTPHeader의 \"Origin\", \"Access-Control-Request-Method\", \"Access-Control-Request-Headers\" 의 3가지 HTTP request headers를 사용하는 HTTPMethod(\"OPTIONS\") 요청입니다.</p>\n<br/>\n<h2 id=\"cors가-없으면\"><a href=\"#cors%EA%B0%80-%EC%97%86%EC%9C%BC%EB%A9%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CORS가 없으면?</h2>\n<p>만약 어떤 사이트에서 CORS 제한이 없으면 어떻게 될까요. 다른 출처의 어플리케이션이 서로 통신하는 것에 아무런 제한이 없게된다면 악의를 가진 사용자가 소스 코드를 볼 수도 있고, 세션정보를 가져갈 수도 있습니다.</p>\n<p>또한 <a href=\"https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B4%ED%8A%B8_%EA%B0%84_%EC%9A%94%EC%B2%AD_%EC%9C%84%EC%A1%B0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CSRF(Cross-Site Request Forgery)</a>나 <a href=\"https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B4%ED%8A%B8_%EA%B0%84_%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8C%85\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">XSS(Cross-Site Scripting)</a>와 같은 방법을 사용해서 어플리케이션에서 코드가 실행된 것처럼 꾸며서 사용자의 정보를 탈취하기 너무 쉬워집니다.</p>\n<p>이러한 경우에 개발자들이 투자해야하는 리소스들은 더 많아지기 때문에 이에 대한 제한은 꼭 필요합니다.</p>\n<br/>\n<h2 id=\"cors는-어떻게-동작하나요\"><a href=\"#cors%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CORS는 어떻게 동작하나요?</h2>\n<p>이러한 CORS의 정의와 왜 필요한지에 대해서 알게 되었기 때문에 좀 더 자세하게 이야기를 해볼려고 합니다.</p>\n<p>GET 요청은 다음과 같이 간단하게 작동합니다. 특히 GET은 서버의 자원을 바꾸지 않기 때문에 로직은 아래처럼 간단합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103171139-141d8680-488d-11eb-87bc-38088c87fbbf.png\" alt=\"CORS-GET\"></p>\n<p>그러나 POST와 같은 비멱등인 경우, 허용하지 않은 도메인이 서버 자원을 변경시킬 수 있기 때문에 이를 신경써줘야합니다. 따라서 POST와 같은 경우는 아래처럼 동작합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103171048-67430980-488c-11eb-98a1-4e77c348d22d.png\" alt=\"CORS-POST\"></p>\n<p>먼저 OPTIONS을 요청해서 해당 도메인간의 요청이 정상적인지 확인합니다.</p>\n<p>이와 같이 CORS는 동작합니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>CORS에 대한 이슈에 대해 정리했습니다. 이에 대한 개념을 잡았으며, 다음 글에서는 spring boot에서 CORS 이슈를 해결하는 방법에 대해 이야기해보겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Glossary/Preflight_request\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://developer.mozilla.org/ko/docs/Glossary/Preflight_request</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Origin\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Origin</a></li>\n<li><a href=\"https://hannut91.github.io/blogs/infra/cors\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://hannut91.github.io/blogs/infra/cors</a></li>\n<li><a href=\"https://zzossig.io/posts/web/what_is_cors/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://zzossig.io/posts/web/what_is_cors/</a></li>\n</ul>\n"}},{"node":{"title":"[GraphQL] GraphQL 개념잡기","path":"/00-graphql/","date":"1. December 2020","timeToRead":6,"description":" GraphQL에 대한 기본적인 내용을 정리합니다. ","content":"<h1 id=\"graphql이란\"><a href=\"#graphql%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GraphQL이란</h1>\n<p>gatsby로 블로그를 이전하게 되면서 GraphQL에 대해서 반드시 알아야하는 상황이 왔다. 기존에도 공부를 했어야한다고 꾸준하게 생각을 했는데, 드디어 한번 공부하게 되었다.</p>\n<br/>\n<h2 id=\"graphql-정의\"><a href=\"#graphql-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GraphQL 정의</h2>\n<p>페이스북에서 만든 퀴리 언어입니다. 다만 SQL은 <strong>데이터베이스에 저장된 데이터를 효율적으로 가져오는 것을 목적</strong>으로 하지만, GraphQL은 <strong>웹 클라이언트가 데이터를 서버로부터 효율적으로 가져오는 것을 목적</strong>으로 합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100871453-a9726880-34e3-11eb-9211-ef08e50163bf.png\" alt=\"image\"></p>\n<blockquote>\n<p>발전하고 있는 GraphQL의 관심도.</p>\n</blockquote>\n<p>GraphQL은 위에 이야기했듯이 기존의 쿼리언어인 sql과 많은 구조적 차이가 있습니다.</p>\n<br/>\n<h2 id=\"graphql-vs-http-api\"><a href=\"#graphql-vs-http-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GraphQL vs HTTP API</h2>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100874660-40d9ba80-34e8-11eb-8670-75e1c8ff0309.png\" alt=\"image\"></p>\n<blockquote>\n<p>HTTP API와 GQL의 기술 스택 비교</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100874777-6bc40e80-34e8-11eb-8bde-b938ffea55f9.png\" alt=\"image\"></p>\n<blockquote>\n<p>REST API와 GraphQL API의 차이</p>\n</blockquote>\n<p>GraphQL API를 사용하면 여러번 네트워크 호출을 할 필요 없이, 한번의 네트워크 호출로 처리 할 수 있습니다.</p>\n<br/>\n<h2 id=\"graphql-구조\"><a href=\"#graphql-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GraphQL 구조</h2>\n<h3 id=\"sql문-예시\"><a href=\"#sql%EB%AC%B8-%EC%98%88%EC%8B%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>SQL문 예시.</h3>\n<p>ex) 유저가 좋아하는 게시글을 가져오는 글이 필요하다.</p>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> board<span class=\"token punctuation\">.</span>likes\n<span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span>\n    <span class=\"token keyword\">left</span> <span class=\"token keyword\">join</span> board <span class=\"token keyword\">on</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> board<span class=\"token punctuation\">.</span>user_id</code></pre>\n<p>다음과 같은 쿼리를 구성할 수 있습니다. 그러나, 만약에 웹에서 이를 호출할려고 하는데, 여러 테이블을 join을 해야하는 경우가 발생할 수 있습니다. 이러한 경우에는 endpoint가 많아지는 문제가 발생할 수 있습니다.</p>\n<h3 id=\"graphql문-예시\"><a href=\"#graphql%EB%AC%B8-%EC%98%88%EC%8B%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GraphQL문 예시.</h3>\n<p>다음과 같은 경우 graphql은 아래와 같이 표현할 수 있습니다.</p>\n<ul>\n<li>쿼리문(query)</li>\n</ul>\n<pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">query</span><span class=\"token punctuation\">{</span>\n    user<span class=\"token punctuation\">{</span>\n        id<span class=\"token punctuation\">,</span>\n        name<span class=\"token punctuation\">,</span>\n        likes <span class=\"token punctuation\">{</span>\n            title\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>응답 데이터 형식(mutation)</li>\n</ul>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"user\"</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token property\">\"id\"</span> <span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n            <span class=\"token property\">\"name\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"user1\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token property\">\"likes\"</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n                <span class=\"token punctuation\">{</span>\n                    <span class=\"token property\">\"title\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"content13\"</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                <span class=\"token punctuation\">{</span>\n                    <span class=\"token property\">\"title\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"content56\"</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>서버사이드 GraphQL 어플리케이션은 gql로 작성된 쿼리를 입력으로 받아 쿼리를 처리한 결과를 다시 클라이언트로 돌려줍니다. HTTP API가 특정 DB나 플랫폼에 종속적이지 않은 것처럼 마찬가지로 gql도 역시 어떠한 특정 DB나 플랫폼에 종속적이지 않습니다.</p>\n<p>좀 더 자세하게 구조를 보면 다음과 같습니다. gql은 <strong>쿼리</strong>와 <strong>뮤테이션</strong>으로 구분됩니다. 쿼리는 데이터를 읽는데 사용되고, 뮤테이션은 데이터를 변조(CUD) 하는데 사용됩니다. 그러나 내부적으로는 큰 차이가 없고, 개념상의 차이라고 이해하면 됩니다.</p>\n<p>gql에서 쿼리에 변수라는 개념이 있습니다. 이 변수를 통해서 함수 인터페이스를 구현할 수 있습니다.</p>\n<pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">query</span> getStudentInformation<span class=\"token punctuation\">(</span><span class=\"token variable\">$studentId</span><span class=\"token punctuation\">:</span> ID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    personalInfo<span class=\"token punctuation\">(</span><span class=\"token attr-name\">studentId</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$studentId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        name\n        address1\n        address2\n        major\n    <span class=\"token punctuation\">}</span>\n    classInfo<span class=\"token punctuation\">(</span><span class=\"token attr-name\">yead</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2018</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">studentId</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$studentId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        classCode\n        className\n        teacher <span class=\"token punctuation\">{</span>\n            name\n            major\n        <span class=\"token punctuation\">}</span>\n        classRoom <span class=\"token punctuation\">{</span>\n            id\n            maintainer <span class=\"token punctuation\">{</span>\n                name\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    SATInfo<span class=\"token punctuation\">(</span><span class=\"token attr-name\">schoolCode</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0412</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">studentId</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$studentId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        totalScore\n        dueDate\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>이 <strong>오퍼레이션</strong> 네임 쿼리(쿼리용 함수)는 RDBMS의 프로시져와 비슷한 개념입니다. 이 개념을 통해 REST API 호출과 다르게, 한번의 호출로 모든 데이터를 가져올 수 있습니다. 더 나아가서 gql 오퍼레이션 네임 쿼리는 클라이언트 프로그래머가 작성하고 관리합니다.</p>\n<p>이 기능 덕분에 gql은 백엔드와 프론트 개발자의 협업에 많은 영향을 주었습니다. gql을 사용하면 백엔드 개발자가 개발하는 API의 request/response의 형식에 의존도가 낮아집니다. 다만, 데이터 schema에 대한 협업은 필요합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/101355449-ec647f80-38d9-11eb-8709-0cd0f98dc9f0.png\" alt=\"image\"></p>\n<br/>\n<h2 id=\"스키마타입schematype\"><a href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88%ED%83%80%EC%9E%85schematype\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>스키마/타입(schema/type)</h2>\n<p><strong>스키마</strong>란 서버 구현내에서 API를 정의하는데 사용되는 유형의 시스템입니다. 모든 기능은 스키마 내에서 정의됩니다.</p>\n<h3 id=\"오브젝트-타입과-필드\"><a href=\"#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%ED%83%80%EC%9E%85%EA%B3%BC-%ED%95%84%EB%93%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>오브젝트 타입과 필드</h3>\n<p>gql은 다음과 같이 작성합니다.</p>\n<pre class=\"language-js\"><code class=\"language-js\">type <span class=\"token maybe-class-name\">Charater</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token known-class-name class-name\">String</span><span class=\"token operator\">!</span>\n    item<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token maybe-class-name\">Episode</span><span class=\"token operator\">!</span><span class=\"token punctuation\">]</span><span class=\"token operator\">!</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>오브젝트 타입 : Character</li>\n<li>필드 : name, item</li>\n<li>스칼라 타입 : String, ID, Int ...</li>\n<li>느낌표(!) : 필수값을 의미</li>\n<li>대괄호([, ]) : 배열을 의미  </li>\n</ul>\n<br/>\n<h2 id=\"리졸버resolver\"><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84resolver\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>리졸버(resolver)</h2>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/101355996-c68baa80-38da-11eb-93a1-e0238e95ed2a.png\" alt=\"image\"></p>\n<p><code class=\"language-text\">GraphQL 파이프라인</code>을 보면, GraphQL 쿼리는 파싱되어 <code class=\"language-text\">리졸버</code>로 들어가게 됩니다. 즉, <code class=\"language-text\">리졸버</code>는 GraphQL에서 실제로 데이터 처리를 담당하는 개념으로 이해하면 됩니다.</p>\n<br/>\n<h2 id=\"인트로스펙션introspection\"><a href=\"#%EC%9D%B8%ED%8A%B8%EB%A1%9C%EC%8A%A4%ED%8E%99%EC%85%98introspection\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>인트로스펙션(introspection)</h2>\n<p>API를 만드는 경우에는 프론트와 백엔드가 협업하여 API 인터페이스를 작성하고 작업에 들어갑니다.</p>\n<p>그러나, <strong>GraphQL의 인트로스펙션 기능을 사용하면 현재 서버에 저장된 스키마를 실시간으로 확인할 수 있습니다.</strong> 이는 문서를 다로 만들 필요 없이 백엔드 개발자가 스키마를 정의해주면 프론트엔드 개발자는 실시간으로 확인해서 개발하면 됩니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>graphql에 대한 기본적인 내용을 정리했습니다. 정확한 개념을 잡는데 이해가 되었으면 좋겠습니다. 다음에는 이를 직접 사용해보면서 내용을 구체화 시키겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://tech.kakao.com/2019/08/01/graphql-basic/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://tech.kakao.com/2019/08/01/graphql-basic/</a></li>\n<li><a href=\"https://www.redhat.com/ko/topics/api/what-is-graphql\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/api/what-is-graphql</a></li>\n<li><a href=\"https://medium.com/@yeon22/graphql-graphql%EC%9D%B4%EB%9E%80-8468571ea96a\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/@yeon22/graphql-graphql%EC%9D%B4%EB%9E%80-8468571ea96a</a></li>\n<li><a href=\"https://simsimjae.medium.com/graphql%EA%B0%9C%EB%A1%A0-8d61b1952191\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://simsimjae.medium.com/graphql%EA%B0%9C%EB%A1%A0-8d61b1952191</a></li>\n</ul>\n"}}]}}},"context":{}}