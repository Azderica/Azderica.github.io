{"hash":"ae819642c9f6ee0978dccc3fd45c022929c76add","data":{"tag":{"title":"Infra","belongsTo":{"edges":[{"node":{"title":"[DevOps] DevOps의 개념이란","path":"/00-devops-definition/","date":"9. January 2021","timeToRead":8,"description":"DevOps의 정의와 개념에 대해 정리합니다.","content":"<h1 id=\"devops\"><a href=\"#devops\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>DevOps</h1>\n<p>말 그대로 DevOpsd에 대한 정리입니다. DevOps에 대한 이야기는 많이 들어보고, 어떠한 개발자들은 DevOps에 대해 꿈을 꾸고 업으로 하겠다는 이야기를 들은적이 있는데 정확하게 DevOps가 어떤 의미를 가지는 지에 대해 알아보기로 했습니다.</p>\n<ul>\n<li><a href=\"https://azderica.github.io/00-devops-cicd/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CI/CD 개념 정리</a>)</li>\n</ul>\n<h2 id=\"devops의-정의\"><a href=\"#devops%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>DevOps의 정의</h2>\n<p>DevOps는 개발(Dev)와 운영(Ops)의 합성어이며, 고객에게 지속적으로 가치를 제공하도록 지원하는 사람, 프로세스 및 기술의 합집합입니다. 이러한 DevOps는 어플리케이션과 서비스를 빠른 속도로 제공할 수 있습니다.</p>\n<p>DevOps는 개발, IT 운영, 품질 엔지니어링, 보안 등이 서로 조율하고 협업하여 더욱 안정적이고 뛰어난 제품을 생산할 수 있도록 지원합니다. 이러한 DevOps 방식과 문화를 통해 고객 요구 사항에 보다 효과적으로 대응하고 애플리케이션을 빌드하고, 비지니스 목표를 달성할 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104084804-d574cc80-528d-11eb-8eb9-5f43614371d4.png\" alt=\"image\"></p>\n<p><code class=\"language-text\">개발자</code>는 새로운 것을 도입하여 기능을 향상 시키는 것을 목표로 하지만, <code class=\"language-text\">운영</code> 측면에서는 안전성을 최우선으로 여깁니다. 이를 잘 융합시키고 의사소통으로 원할하게하는 것이 <code class=\"language-text\">DevOps</code>이며, 이는 소프트웨어 개발 방법론 중 하나입니다.</p>\n<br/>\n<h2 id=\"devops의-이점\"><a href=\"#devops%EC%9D%98-%EC%9D%B4%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>DevOps의 이점</h2>\n<p>DevOps는 다음과 같은 장점을 가집니다.</p>\n<h3 id=\"속도\"><a href=\"#%EC%86%8D%EB%8F%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>속도</h3>\n<ul>\n<li>작업 속도가 빨라지며 고객을 위해 더 빠르게 혁신합니다.</li>\n<li>시장 변화에 더 잘 적응하고 좀 더 효율적인 비지니스 성과를 창출합니다.</li>\n<li><strong>MSA와 CI/CD를 통해서 서비스를 주도적으로 운영하고 업데이트를 좀 더 빠르게 릴리스할 수 있습니다.</strong></li>\n</ul>\n<h3 id=\"신속한-제공\"><a href=\"#%EC%8B%A0%EC%86%8D%ED%95%9C-%EC%A0%9C%EA%B3%B5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>신속한 제공</h3>\n<ul>\n<li>릴리스의 빈도와 속도를 개선하여 제품을 더 빠르게 혁신하고 개선할 수 있습니다.</li>\n<li>CI/CD는 빌드에서 배포까지 release 프로세스를 자동화할 수 있습니다.</li>\n</ul>\n<h3 id=\"안정성\"><a href=\"#%EC%95%88%EC%A0%95%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>안정성</h3>\n<ul>\n<li>애플리케이션 업데이트와 인프라 변경의 품질을 통해 최종 사용자에게 좋은 경험을 지속적이고 안정적이게 제공합니다.</li>\n<li>CI/CD와 같은 방식을 통해 안전한지에 대해 테스트합니다.</li>\n<li>모니터링과 로깅 방식을 통해 실시간으로 성능에 대한 정보를 얻을 수 있습니다.</li>\n</ul>\n<h3 id=\"확장\"><a href=\"#%ED%99%95%EC%9E%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>확장</h3>\n<ul>\n<li>규모에 따라 인프라와 개발 프로세스를 운영 및 관릭합니다.</li>\n<li>자동화와 일관성이 지원되므로 위험을 줄이면서 복잡하고 변동성 있는 시스템을 효율적으로 관리할 수 있습니다.</li>\n<li>코드형 인프라를 사용하면 프로덕션 환경을 반복 가능하고 좀 더 효율적인 방식으로 관리할 수 있습니다.</li>\n</ul>\n<h3 id=\"협업-강화\"><a href=\"#%ED%98%91%EC%97%85-%EA%B0%95%ED%99%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>협업 강화</h3>\n<ul>\n<li>주인의식 및 책임 가치를 강조하므로 DevOps 문화에서는 좀 더 효과적인 팀을 구축합니다.</li>\n<li>개발자와 운영팀은 긴밀하게 협력하고 많은 책임을 공유하며, 워크플로를 결합하여 비효율성을 줄이고 시간을 절약합니다,</li>\n</ul>\n<h3 id=\"보안\"><a href=\"#%EB%B3%B4%EC%95%88\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>보안</h3>\n<ul>\n<li>제어를 유지하고 규정을 준수하며 신속하게 진행할 수 있습니다.</li>\n<li>자동화된 규정 준수 정책, 세분화된 제어 및 구성 관리 기술을 사용함으로\\$써 보안을 유지하며 DevOps 모델을 도입할 수 있습니다.</li>\n<li>코드형 인프라와 코드형 정책을 사용하면 규모에 따라 규정 중수를 정의하고 추적할 수 있습니다.</li>\n</ul>\n<br/>\n<h2 id=\"devops의-특징\"><a href=\"#devops%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>DevOps의 특징</h2>\n<h3 id=\"cross-functional-team\"><a href=\"#cross-functional-team\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cross Functional Team</h3>\n<p>서비스 기획부터 개발, 운영, 테스트, 배포 등 모든 제품 개발 프로세스를 하나의 팀에서 할 수 있도록 합니다.</p>\n<h3 id=\"widely-shared-metrics\"><a href=\"#widely-shared-metrics\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Widely Shared Metrics</h3>\n<p>서비스를 개발만 하는게 아니라 서비스가 운영에서 잘돌아가고 있는지, 사용자의 반응은 어떤지를 측정할 수 있는 기준을 제공합니다.</p>\n<h3 id=\"automating-repetitive-tasks\"><a href=\"#automating-repetitive-tasks\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Automating repetitive tasks</h3>\n<p>반복적인 일들은 자동화합니다. CI/CD를 통해 빌드, 배포, 테스트의 프로세스를 자동화하여 생산적인 결과를 얻을 수 있습니다. 더 나아가서 자동화 툴을 통해 시스템 전체에 대한 이해가 높아집니다.</p>\n<h3 id=\"post-mortems\"><a href=\"#post-mortems\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Post mortems</h3>\n<p><strong>후처리</strong>의 의미를 가지고 있습니다. 장애나 이슈가 있을때, 그 결과를 팀원들과 공유해야합니다.</p>\n<h3 id=\"regular-release\"><a href=\"#regular-release\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Regular Release</h3>\n<p>짧은 주기의 정기 배포를 통해서 빠르게 서비스의 기능을 개선하고 고객들의 소리를 반영해서 나아가야합니다.</p>\n<br/>\n<h2 id=\"devops와-애플리케이션-수명-주기\"><a href=\"#devops%EC%99%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%88%98%EB%AA%85-%EC%A3%BC%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>DevOps와 애플리케이션 수명 주기</h2>\n<p>DevOps는 계획, 개발, 제공, 운뎡 단계 전반에 걸쳐 애플리케이션 수명 주기에 영향을 줍니다. 각 단게는 서로 영향을 주며 단계가 특정 역할에 한정되지 않습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104085406-87ae9300-5292-11eb-87aa-f146c29a76c2.png\" alt=\"DevOps-Lifecycle\"></p>\n<ul>\n<li>\n<p>계획</p>\n<ul>\n<li>애플리케이션과 시스템의 특징 및 기능에 대해 아이디어를 도출합니다.</li>\n</ul>\n</li>\n<li>\n<p>개발</p>\n<ul>\n<li>팀원들이 코드를 작성하고 검토하고 통합하는 코딩의 모든 측면과 이 코드를 다양한 환경에 배포할 수 있는 빌드 아티팩트로 빌드하는 작업이 포함됩니다.</li>\n</ul>\n</li>\n<li>\n<p>제공</p>\n<ul>\n<li>일관성 있고 안정적인 방식으로 프로덕션 환경에 애플리케이션을 배포하는 과정을 의미합니다.</li>\n</ul>\n</li>\n<li>\n<p>운영</p>\n<ul>\n<li>프로덕션 환경에서 애플리케이션을 관리, 모니터링 및 문제 해결하는 작업이 이루어집니다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"devops의-문화\"><a href=\"#devops%EC%9D%98-%EB%AC%B8%ED%99%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>DevOps의 문화</h2>\n<p>DevOps 방식을 도입하면 기술을 통해 프로세스를 자동화 및 최적화할 수 있습니다. 모든 것을 조직 내부의 문화에서 나아가 문화의 핵심적인 부분은 사람에게서 시작을 하고, 이러한 문화가 정착되어야합니다.</p>\n<ul>\n<li>\n<p>협업, 가시성 및 조율</p>\n<ul>\n<li>개발 팀, IT 운영 팀 등은 DevOps 프로세스의 우선 순위, 우려 사항을 다른 팀과 공유해야하며 효과적인 협업을 계획해야합니다.</li>\n</ul>\n</li>\n<li>\n<p>팀 역할 범위와 책임의 변환</p>\n<ul>\n<li>주인의식을 가지고 관여해야합니다.</li>\n</ul>\n</li>\n<li>\n<p>짧은 릴리스 주기</p>\n<ul>\n<li>짧은 릴리스를 통해 민첩성을 유지합니다.</li>\n<li>고객 요구 사항과 경쟁사의 압박에 유연하게 대응가능합니다.</li>\n</ul>\n</li>\n<li>지속적인 학습</li>\n</ul>\n<br/>\n<h2 id=\"devops에-대해-공부하겠다면\"><a href=\"#devops%EC%97%90-%EB%8C%80%ED%95%B4-%EA%B3%B5%EB%B6%80%ED%95%98%EA%B2%A0%EB%8B%A4%EB%A9%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>DevOps에 대해 공부하겠다면?</h2>\n<p>배포와 서버, DevOps에 대해 다음과 같은 내용을 공부하면 좋습니다. (약간 주제에 어긋날 수도 있지만.)</p>\n<ul>\n<li>\n<p>Hosting Platforms</p>\n<ul>\n<li><strong>Heroku, AWS, Azure</strong>, Digital Ocean</li>\n</ul>\n</li>\n<li>\n<p>Web Servers</p>\n<ul>\n<li><strong>Nginx, Apache</strong></li>\n</ul>\n</li>\n<li>\n<p>Container</p>\n<ul>\n<li><strong>Docker, Kubernetes</strong>, Vagrant</li>\n</ul>\n</li>\n<li>\n<p>Image/Video</p>\n<ul>\n<li>Cloudinary, S3</li>\n</ul>\n</li>\n<li>\n<p>CI / CD</p>\n<ul>\n<li><strong>Jenkins</strong>, Travis CI, Circle CI</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간단하게 DevOps에 대해 정리해보았습니다. DevOps에 대한 개념은 이후에 공부하는 다양한 기술 들에 밑바탕이 되는 지식이라고 생각합니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://aws.amazon.com/ko/devops/what-is-devops/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://aws.amazon.com/ko/devops/what-is-devops/</a></li>\n<li><a href=\"https://azure.microsoft.com/ko-kr/overview/what-is-devops/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://azure.microsoft.com/ko-kr/overview/what-is-devops/</a></li>\n<li><a href=\"https://simsimjae.medium.com/devops%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-c50f4d86666b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://simsimjae.medium.com/devops%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-c50f4d86666b</a></li>\n</ul>\n"}},{"node":{"title":"[Grafana] Grafana란?","path":"/00-grafana/","date":"18. November 2020","timeToRead":4,"description":" 그라파나에 대한 기본 내용을 정리한 글입니다. ","content":"<h1 id=\"grafana란\"><a href=\"#grafana%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Grafana란.</h1>\n<p>지난 Prometheus에 이어, 모니터링에 필요한 Grafana에 대해서 한 번 공부해보겠다.</p>\n<br/>\n<h2 id=\"grafana-이해하기\"><a href=\"#grafana-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Grafana 이해하기.</h2>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99534507-da827180-29ea-11eb-9c4b-8ebb2c3f440d.png\" alt=\"image\"></p>\n<blockquote>\n<p>마치 하스스톤의 로고가 생각난다.</p>\n</blockquote>\n<p>Grafana란 메트릭/로그를 시각화하는 대시보드입니다.</p>\n<blockquote>\n<p>매트릭 : 로그와 달리 주기적으로 발생하는 타임스탬프와 보통 한두가지 숫자 값을 포함하는 이벤트.</p>\n</blockquote>\n<p>이를 좀더 자세하게 설명하면 다음과 같이 내용을 이야기할 수 있습니다. <strong>매트릭 데이터</strong>를 <strong>시각화</strong>하는데 가장 최적화된 대시보드를 제공해주는 오픈소스 툴킷입니다.</p>\n<p>특히 다양한 DB를 연결하여 DB의 데이터를 가져와 손쉽게 시각화할 수 있습니다.</p>\n<p>아래는 Grafana의 예시 화면입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99536438-b4aa9c00-29ed-11eb-84cc-68b2380c5c9c.png\" alt=\"image\"></p>\n<p><a href=\"https://play.grafana.org/d/000000012/grafana-play-home?orgId=1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Grafana 링크</a></p>\n<p>해당 링크에 들어가보면, Grafana가 제공하는 시각화를 간단하게 확인할 수 있습니다.</p>\n<p>Grafana는 시계열 매트릭 데이터 수집에 강점을 보이며, 이 강점덕분에 서버 리소스의 매트릭 정보나 로그 같은 데이터를 시각화하는데 많이 사용됩니다.</p>\n<p>추가적으로 시각화한 그래프에서 특정 수치 이상으로 값이 올라갈때, 알림을 받는 기능을 제공합니다. 이러한 강점은 인프라 운영 관점에서 굉장히 중요한 기능을 차지합니다.</p>\n<p>오픈소스 툴킷이므로 커뮤니티도 활성화 되어있으며, 일반 사용자들이 만들어놓은 대시보드를 import하고 더 나아가 커스터 마이징을 할 수 있습니다.</p>\n<p><a href=\"https://community.grafana.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Grafana Comunity</a></p>\n<p>또한 다양한 플러그인을 제공하기 때문에 Grafana 내부적으로 기능 확장에 도움이 됩니다.</p>\n<p>추가적으로 GrafanaCon 등 다양한 행사를 열면서, 해당 컨퍼런스에는 프로메테우스나 로키 등의 주제에 대해 이야기 합니다.</p>\n<p><a href=\"https://grafana.com/about/events/grafanacon/2020/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GrafanaCon</a></p>\n<h2 id=\"grafana-vs-datadog\"><a href=\"#grafana-vs-datadog\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Grafana vs Datadog</h2>\n<p>Grafana와 마찬가지로 Datadog도 클라우드 모니터링 서비스를 제공합니다.</p>\n<p>공통점</p>\n<ul>\n<li>메트릭 데이터를 시각화</li>\n<li>대시보드 구성 가능</li>\n<li>외부 통합 기능을 통해 모니터링의 영역을 확장할 수 있음.</li>\n</ul>\n<p>차이점</p>\n<ul>\n<li><strong>Datadog</strong>의 경우, 데이터를 직접 저장하고 있으나. <strong>Grafana</strong>의 경우에는 외부 데이터 소스를 정의하고 해당 데이터 소스에 쿼리를 통해서 데이터를 동적으로 가져와 시각화합니다.</li>\n<li><strong>Datadog</strong>은 모니터링 서비스를 제공하는 상용 서비스이며, <strong>Grafana</strong>는 오픈소스 프로젝트입니다.</li>\n</ul>\n<br/>\n<h2 id=\"grafana-설치-다음에\"><a href=\"#grafana-%EC%84%A4%EC%B9%98-%EB%8B%A4%EC%9D%8C%EC%97%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Grafana 설치 (다음에)</h2>\n<p>다음에 직접 구현해보면서 글을 한번 더 다루겠습니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간단하게 모니터링 시 사용되는 Prometheus, Grafana에 대해 정의나 특징으로 정리하였습니다. 이후에는 다른 방향의 글을 작성할 예정입니다.</p>\n<p>추가적으로 직접 구현해보면서, 이후의 글을 추가하겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://medium.com/finda-tech/grafana%EB%9E%80-f3c7c1551c38\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/finda-tech/grafana%EB%9E%80-f3c7c1551c38</a></li>\n<li><a href=\"https://www.44bits.io/ko/keyword/grafana\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.44bits.io/ko/keyword/grafana</a></li>\n<li><a href=\"https://blog.dalso.org/home-server/monitoring-server/3744\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://blog.dalso.org/home-server/monitoring-server/3744</a></li>\n</ul>\n"}},{"node":{"title":"[Prometheus] Prometheus란?","path":"/00-prometheus/","date":"16. November 2020","timeToRead":4,"description":" 프로메테우스에 대한 기본 내용을 정리한 글입니다. ","content":"<h1 id=\"prometheus란\"><a href=\"#prometheus%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Prometheus란.</h1>\n<p>업무를 진행하다가 모니터링 시스템에 대해서 듣기 시작했다, 그 모니터링 시스템에 대해 듣다보니 공부를 해야겠다는 생각이 들어서 글을 정리한다. 모니터링 툴로 유명한 프로메테우스, Grafana 등이 있는데 오늘은 Prometheus에 대한 글을 작성해볼려고 한다.</p>\n<br/>\n<h2 id=\"prometheus란-1\"><a href=\"#prometheus%EB%9E%80-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Prometheus란</h2>\n<p>오픈소스 시스템 모니터링 및 경고 툴킷이다. 많은 회사들이 사용하고 있으며 Kubernetes에서도 Prometheus를 사용하여 매트릭 수집 및 대시보드 구축하는 방식을 사용하고 있습니다.</p>\n<p>기능을 간략하게 보자면 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99261592-4389ae00-2860-11eb-8d93-ce2817cdc70e.png\" alt=\"Prometheus 기능\"></p>\n<p>다음은 Promethheus의 아키텍처 구조입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99261600-46849e80-2860-11eb-87ba-7d573b45dba8.png\" alt=\"Prometheus 구성\"></p>\n<p>간단하게 설명하면 다음과 같습니다</p>\n<ul>\n<li><code class=\"language-text\">Jobs/exporters</code> : 실제 매트릭을 수집하는 프로세스</li>\n<li><code class=\"language-text\">exporter`` : 매트릭을 수집하고 HTTP 통신을 통해 매트릭 데이터를 가져갈 수 있게</code>/metrics`라는 HTTP 엔드포인틀 제공</li>\n<li><code class=\"language-text\">Prometheus server</code> : 이 <code class=\"language-text\">exporter</code>의 엔드포인트로 HTTP GET 요청을 날려 내트릭 정보를 수집(Pull)한다.</li>\n<li>매트릭이란?</li>\n</ul>\n<blockquote>\n<p>매트릭이란 타임스탬프와 보통 한두가지 숫자 값을 포함하는 이벤트.</p>\n<p>로그와 달리 메트릭은 주기적으로 보냅니다. 로그는 보통 무언가가 발생했을 때, 로그 파일에 추가되며 메트릭은 종종 리소스 사용 모니터링, 데이터베이스 실행 메트릭 모니터링 등에서 사용됩니다.</p>\n</blockquote>\n<br/>\n<h2 id=\"prometheus의-특징\"><a href=\"#prometheus%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Prometheus의 특징</h2>\n<h3 id=\"장점\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>장점</h3>\n<ul>\n<li>pull 방식의 구조를 채택함으로써 모든 메트릭에 대한 데이터를 중앙 서버로 보내지않아도 됩니다.</li>\n<li>Prometheus의 특성 상, 모든 데이터를 수집하지 않고 일정 주기(default 15s)로 발생하는 메트릭을 수집하여 추이나 모니터링을 어플리케이션에 무리 없이 하기 때문에 이러한 부분에서 매력적인 솔루션입니다.</li>\n<li>Prometheus를 사용하고 있는 Vendor와 open-source들이 상당히 많다. 구조가 복잡하지 않고 간단하기 때문에 특정 솔루션에 대한 export를 하는 것이 어렵지 않습니다. 특히 Kubernetes와 Docker환경에서의 서비스의 메트릭을 수집하고 분석하는 대에 집중적으로 많이 사용됩니다.</li>\n</ul>\n<h3 id=\"단점\"><a href=\"#%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단점</h3>\n<ul>\n<li>Scale-out이 안됩니다.(억지로는 할 수 있으나 이는 clusting보다는 Prometheus에 Prometheus를 연결에 Hieracrchy 구조를 만들어서 사용해야 한다.)</li>\n<li>모든 메트릭을 전송하지 않기 때문에 \"추이\"를 보는데는 좋지 않아서, 모든 로그를 추적하고 문제를 발생했을 때 이를 검색하여 어떤 일이 있었는지 원인을 밝히고자 할때는 사용하기 힘든 솔루션입니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리</h2>\n<p>간단하게 내용에 대해서 조사했습니다. 좀 더 구현하는 방식에 대해서는 직접 Prometheus를 만들어보면서 추가하겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://medium.com/finda-tech/prometheus%EB%9E%80-cf52c9a8785f\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/finda-tech/prometheus%EB%9E%80-cf52c9a8785f</a></li>\n<li><a href=\"https://gompangs.tistory.com/entry/Prometheus-%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://gompangs.tistory.com/entry/Prometheus-%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90</a></li>\n</ul>\n"}},{"node":{"title":"[Kubernetes] Kubernetes란?","path":"/00-kubernetes/","date":"10. November 2020","timeToRead":13,"description":" 쿠버네티스에 대한 기본 내용을 정리한 글입니다. ","content":"<h1 id=\"kubernetes란\"><a href=\"#kubernetes%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Kubernetes란.</h1>\n<p>쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 오픈소스 플랫폼이이며 <strong>이식성, 확장가능성</strong>의 특징을 가집니다. 이 플랫폼은 컨테이너화된 애플리케이션을 배포하고 확장하는데 수동 프로세스가 필요하지 않습니다.</p>\n<p>이를 통해서 컨테이너를 실행하는 host 그룹을 함께 클러스팅이 가능하며, 클러스토를 쉽고 효율적으로 관리할 수 있다.</p>\n<blockquote>\n<p>용어에 대한 간단한 정리.</p>\n<ul>\n<li>컨테이너 : 호스트 OS상에 논리적인 구획(컨테이너)를 만들고, 어플리케이션을 작동시키기 위해 필요한 라이브러리나 어플리케이션 등을 하나로 모아서 마치 별도의 서버인 것처럼 사용할 수 있게 만든 것.</li>\n<li>클러스터 : 여러 대의 컴퓨터를 네트워크를 통해 하나의 단일 컴퓨터처럼 동작하도록 제작한 컴퓨터</li>\n</ul>\n<p>나중에 docker에 대해서도 추가적으로 설명하면서 더 자세하게 설명하겠습니다.</p>\n</blockquote>\n<p>쿠버네티스는 클라우드 전체로 호스트를 확장할 수 있고, 이러한 기능이 Apache Kafka 스트리밍과 같이 신속한 확장을 요구하는 클라우드 환경에서 큰 장점을 가집니다.</p>\n<br/>\n<h2 id=\"쿠버네티스의-기본-용어\"><a href=\"#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9A%A9%EC%96%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>쿠버네티스의 기본 용어</h2>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147045-cffd6a80-26c0-11eb-846e-dee35301857c.png\" alt=\"image\"></p>\n<ul>\n<li>마스터(Master) : 노드를 제어하고 전체 클러스터를 관리해주는 컨트롤러, 전체적인 제어/관리를 하기 위한 관리 서버</li>\n<li>노드(Nod) : 컨테이너가 배포될 물리 서버 또는 가상 머신이며 워커 노드(Worker Node)라고 불린다.</li>\n<li>파드(Pod) : 단일 노드에 배포된 하나 이상의 컨테이너 그룹이며, Pod라는 단위로 여러개의 컨테이너를 묶어서 파드 단위로 관리가 가능하다.</li>\n</ul>\n<br/>\n<h2 id=\"쿠버네티스의-특징\"><a href=\"#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>쿠버네티스의 특징</h2>\n<h3 id=\"1-여러회사들의-참여로-인한-큰-스케일과-커뮤니티-생태계\"><a href=\"#1-%EC%97%AC%EB%9F%AC%ED%9A%8C%EC%82%AC%EB%93%A4%EC%9D%98-%EC%B0%B8%EC%97%AC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%ED%81%B0-%EC%8A%A4%EC%BC%80%EC%9D%BC%EA%B3%BC-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0-%EC%83%9D%ED%83%9C%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 여러회사들의 참여로 인한 큰 스케일과 커뮤니티, 생태계</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147075-1fdc3180-26c1-11eb-88af-4702b0d1236e.png\" alt=\"image\"></p>\n<blockquote>\n<p>우리가 아는 많은 회사가 보인다.</p>\n</blockquote>\n<p>여러 회사의 노하우와 경험이 녹아있어서 다양한 커뮤니티와 좋은 생태계가 구성되어 있습니다. 대부분의 문제점이나 원하는 서비스를 만들려고 찾아보면 있는 것을 확인할 수 있습니다. CI(Continuous Integration), 컨테이너 서버리스, 머신러닝 등이 쿠버네티스 환경에서 잘 돌아갑니다.</p>\n<blockquote>\n<p>Kubernetes Community : <a href=\"https://kubernetes.io/ko/community/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kubernetes.io/ko/community/</a></p>\n</blockquote>\n<h3 id=\"2-다양한-배포-방식-지원\"><a href=\"#2-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%B0%B0%ED%8F%AC-%EB%B0%A9%EC%8B%9D-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 다양한 배포 방식 지원</h3>\n<p>쿠버네티스는 다양한 배포 방식을 지원합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/98945299-ae23ac80-2535-11eb-9fb2-f48b09e63f2c.png\" alt=\"image\"></p>\n<p>다음과 같이 Daemon Set, Deployment, stateful sets, Job등이 있으며, 각기 다른 특징을 가집니다.</p>\n<ul>\n<li><code class=\"language-text\">Daemont Set</code> : 디플로이먼트와 유사하게 파드를 생성하고 관리합니다. 디플로이먼트는 롤링 업데이트나 배포 일시 중지, 재개 등 배포 작업을 좀 더 세분화하여 조작하였다면, 데몬셋은 특정 노드 또는 모든 노드에 항상 실행되어야 할 특정 파드를 관리합니다.</li>\n<li><code class=\"language-text\">ReplicaSet</code> : 실행되는 파드 개수에 대한 가용성을 보증 하며 지정한 파드 개수만큼 항상 실행될 수 있도록 관리합니다.</li>\n<li><code class=\"language-text\">Deployment</code> : 레플리카셋의 상위 개념으로 볼 수도 있습니다. 레플리카셋을 생성하는 디플로이먼트를 정의할 수 있고, 배포 작업을 좀 더 세분화(롤링 업데이트 등) 하여 조작할 수 있는 기능을 제공합니다.</li>\n<li><code class=\"language-text\">Stateful Set</code> : 디플로이먼트와 유사하며 동일한 컨테이너 스펙을 기반으로 둔 파드들을 관리한다. 다만, 스테이트풀셋은 각 파드의 독자성을 유지하는 지속적인 식별자를 가집니다. (교체 불가)</li>\n<li><code class=\"language-text\">CronJob</code> : 크론잡은 지정한 일정에 특정 파드를 실행하는 잡을 실행할 수 있습니다.</li>\n<li><code class=\"language-text\">Job</code> : 잡은 하나 이상의 파드를 지정하고 지정된 수의 파드를 성공적으로 실행하도록 하는 설정, 노드의 H/W 장애나 재부팅 등으로 인해 파드가 정상 실행이 되지 않았을 경우 job은 새로운 파드를 시작하도록 할 수 있습니다.</li>\n<li><code class=\"language-text\">Replication Controller</code> : 레플리케이션컨트롤러 는 언제든지 지정된 수의 파드 레플리카가 실행 중임을 보장합니다. 즉, 레플리케이션 컨트롤러는 파드 또는 동일 종류의 파드의 셋이 항상 기동되고 사용 가능한지 확인할 수 있습니다.</li>\n</ul>\n<blockquote>\n<p>상세 설명은 해당 <a href=\"https://kubernetes.io/ko/docs/concepts/workloads/controllers/statefulset/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">여기</a> 에서...</p>\n</blockquote>\n<h3 id=\"3-ingress-기능-제공\"><a href=\"#3-ingress-%EA%B8%B0%EB%8A%A5-%EC%A0%9C%EA%B3%B5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. Ingress 기능 제공</h3>\n<p><strong>인그레스</strong>는 클러스터 외부에서 클러스터 내부 서비스로 HTTP와 HTTPS 경로를 노출합니다. 트래픽 라우팅은 인그레스 리소스에 정의된 규칙에 의해 컨트롤이 가능합니다.</p>\n<p>다음은 인스레스가 모든 트래픽을 하나의 서비스로 보내는 간단한 예시입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99082398-738a4480-2607-11eb-9741-c038299efc71.png\" alt=\"image\"></p>\n<p>인그레스는 외부에서 서비스로 접속이 가능한 URL, 로드 밸런스 트래픽, SSL / TLS 종료 그리고 이름-기반의 가상 호스팅을 제공하도록 구성할 수 있습니다. <strong>인그레스 컨트롤러</strong>는 일반적으로 로드 밸런서를 사용해서 인그레스를 수행할 책임이 있으며, 트래픽을 처리하는데 도움이 되도록 에지 라우터 또는 추가 프런트 엔드를 구성할 수도 있습니다.</p>\n<h3 id=\"4-클라우드-지원-기능\"><a href=\"#4-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%A7%80%EC%9B%90-%EA%B8%B0%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>4. 클라우드 지원 기능</h3>\n<p>쿠버네티스는 부하에 따라 자동으로 서버를 늘리는 기능인 AutoScaling이 있고, IP를 할당받아 로드밸런서로 사용할 수 있습니다.</p>\n<p>쿠버네티스는 Cloud Controller를 이용하여 클라우드 연동을 손쉽게 확장할 수 있습니다. 그 덕분에 AWS, Google Cloud, MS Azure 등을 쉽게 사용할 수 있습니다.</p>\n<h3 id=\"5-namespcae--label을-통한-구분\"><a href=\"#5-namespcae--label%EC%9D%84-%ED%86%B5%ED%95%9C-%EA%B5%AC%EB%B6%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>5. Namespcae &#x26; Label을 통한 구분</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147381-ed800380-26c3-11eb-8353-23f58c65b722.png\" alt=\"image\"></p>\n<p>하나의 클러스터를 논리적으로 구분해서 사용할 수 있습니다. 하나의 클러스터에 다양한 프레임워크와 애플리케이션을 설치하기 때문에 기본 (system, default)외에 여러 개의 네임스페이스를 사용하는 것이 일반적입니다.</p>\n<h3 id=\"6-rbacrole-based-access-control\"><a href=\"#6-rbacrole-based-access-control\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>6. RBAC(Role-based access control)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147431-3fc12480-26c4-11eb-9e76-50b1b9d780c6.png\" alt=\"image\"></p>\n<p>RBAC는 접근 권한 시스텝입니다. 각각의 리소스에 대해 유저별로 CRUD스러운 권한을 손쉽게 지정할 수 있으며, 클러스터 전체에 적용하거나 특정 네임스페이스에 적용할 수 있습니다.</p>\n<h3 id=\"7-crdcustom-resource-definitation\"><a href=\"#7-crdcustom-resource-definitation\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>7. CRD(Custom Resource Definitation)</h3>\n<p>쿠버네티스가 제공하지 않는 기능을 기본 기능과 동일한 빙식으로 적용하고 사용할 수 있는 기능입니다.</p>\n<ul>\n<li>Ex) Knative 등등</li>\n</ul>\n<h3 id=\"8-auto-scaling\"><a href=\"#8-auto-scaling\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>8. Auto Scaling</h3>\n<p>CPU, memory 사용량, 접속자 수 등을 조절할 수 있습니다. 다음과 같은 종류가 있습니다.</p>\n<ul>\n<li>HPA(Horizontal Pod Autoscaler) : 컨테이너 개수 조정</li>\n<li>VPA(Vertical Pod Autoscaler) : 컨테이너 리소스 할당량 조절</li>\n<li>CA(Cluster Autoscaler) : 서버 개수 조정</li>\n</ul>\n<h3 id=\"9-federation-multi-cluster\"><a href=\"#9-federation-multi-cluster\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>9. Federation, Multi Cluster</h3>\n<p>클라우드에 설치된 쿠버네티스 클러스와 자체 서버에 설치한 쿠버네티스를 묶어서 하나로 사용할 수 있습니다. 구글에서 발표한 Anthos를 사용하면 한 곳에서 여러 클라우드의 클러스터를 관리할 수 있습니다.</p>\n<h3 id=\"10-it-보안\"><a href=\"#10-it-%EB%B3%B4%EC%95%88\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>10. IT 보안</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147877-a98efd80-26c7-11eb-973f-58fae551a5d6.png\" alt=\"image\"></p>\n<p>컨테이너 보안은 멀티레이어 구조이므로 이는 복잡합니다. 쿠버네티스는 워크로드를 위해 규모에 맞는 컨테이너를 배포하는데 필요한 자원 및 관리 기능을 제공합니다. 이를 통해서 애플리케이션 서비스를 구축하고, 일정을 계획하고, 컨테이너를 확장해서 컨테이너 상태를 지속적으로 관리할 수 있습니다.</p>\n <br/>\n<h2 id=\"쿠버네티스의-개념\"><a href=\"#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>쿠버네티스의 개념</h2>\n<h3 id=\"desired-state\"><a href=\"#desired-state\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Desired State</h3>\n<p>쿠버네티스 공식 홈페이지의 document에서 등장하는 용어는 <strong>desired state</strong>이다. 이는 쿠버네티스를 이해하는데 가장 핵심적인 개념이다. 이는 쉽게 <strong>원하는 상태</strong>(ex. 웹서버의 갯수, 포트)를 의미합니다.</p>\n<p>쿠버네티스는 <strong>현재 상태(current state)</strong>를 지속적으로 모니터링하며, current state와 desired state 사이에 다른 부분이 있으면 이를 동일하게 만듭니다.</p>\n<p>이러한 로직으로 인해, 관리자가 서버를 배포할 때는 직접적인 명령을 하지 않고, 상태를 선언하는 방식을 사용합니다. 이 상태(desired state)를 선언하므로서, 현재 상태(current state)에서 이동합니다.</p>\n<blockquote>\n<p>핵심은 명령(imprative)이 아닌 선언(declarative)입니다.</p>\n</blockquote>\n<h3 id=\"kubernetes-object\"><a href=\"#kubernetes-object\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Kubernetes Object</h3>\n<p>쿠버네티스는 상태를 관리하기 위한 대상을 오브젝트로 정의합니다. 쿠버네티스는 여러가지의 오브젝트를 제공하고, 새로운 오브젝트를 추가하기 쉽기 때문에 확장성이 좋습니다.</p>\n<ul>\n<li>\n<p>Pod</p>\n<ul>\n<li><img src=\"https://user-images.githubusercontent.com/42582516/99166472-4e055400-2749-11eb-9ef3-05891a4762ff.png\" alt=\"image\"></li>\n<li>쿠버네티스에서 배포할 수 있는 가장 작은 단위</li>\n<li>하나 이상의 컨테이너, 스토리지, 네트워크 속성을 가짐</li>\n<li>하나의 Pod 안에 있는 컨테이너는 스토리지, 네트워크를 공유합니다.</li>\n</ul>\n</li>\n<li>\n<p>ReplicaSet</p>\n<ul>\n<li>Pod을 여러개 복제하여 관리하는 오브젝트</li>\n<li>Pod을 생성하고 개수를 유지하기 위해서 반드시 사용합니다.</li>\n<li>YAML에서 replicas의 갯수를 지정하여 Pod의 개수를 몇개 유지할 지 결정할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>Service</p>\n<ul>\n<li>네트워크와 관련된 오브젝트</li>\n<li>Pod을 외부 네트워크에 연결해주며, 여러 개의 Pod을 바라보는 내부 로드 밸런서를 생성할 때 사용</li>\n<li>서비스 디스커버리 역활도 수행합니다. (내부 DNS에 서비스 이름을 도메인으로 등록합니다.)</li>\n</ul>\n</li>\n<li>\n<p>Volume</p>\n<ul>\n<li>저장소와 관련된 오브젝트</li>\n<li>대부분으 저장 방식을 지원합니다.</li>\n</ul>\n</li>\n<li>\n<p>Object Spec - YAML</p>\n<ul>\n<li>오브젝트외 종류와 원하는 상태로 입력합니다.</li>\n<li>해당 명세는 생성, 조회, 삭제로 관리할 수 있어서 REST API로 쉽게 노출이 가능합니다.</li>\n<li>접근 권한 설정도 같은 개념을 적용하여 어떤 오브젝트에 어떤 요청을 할 수 있는지 정의할 수 있습니다.</li>\n<li>아래는 예시 YAML파일입니다.</li>\n<li>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> apps/v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Deployment\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n<span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">-</span>deployment\n<span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> nginx\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n<span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span>\n<span class=\"token key atrule\">selector</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">matchLabels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> nginx\n<span class=\"token key atrule\">template</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> nginx\n    <span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nginx\n        <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">:</span>1.7.9\n        <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">containerPort</span><span class=\"token punctuation\">:</span> <span class=\"token number\">80</span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"쿠버네티스-배포-양식\"><a href=\"#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%B0%ED%8F%AC-%EC%96%91%EC%8B%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>쿠버네티스 배포 양식</h3>\n<p>이전에 이야기 했듯이 쿠버네티스는 애플리케이션을 배포하기 위해 원하는 상태(desired state)를 다양한 오브젝트(object)에 라벨(label)을 붙여서 정의하고 API 서버에 전달하는 방식을 사용합니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>쿠버네티스에 대한 개념을 찾기 위해서, 많은 글을 읽으면서 정리했습니다. 이후에 좀 더 공부해서 부족한 내용을 좀 더 추가하겠습니다. 그리고 설치 등을 해보면서 이후에 좀 더 글을 작성하겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/</a></li>\n<li><a href=\"https://subicura.com/2019/05/19/kubernetes-basic-1.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://subicura.com/2019/05/19/kubernetes-basic-1.html</a></li>\n<li><a href=\"https://www.redhat.com/ko/topics/containers/what-is-kubernetes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/containers/what-is-kubernetes</a></li>\n<li><a href=\"https://nirsa.tistory.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://nirsa.tistory.com/</a></li>\n<li><a href=\"https://nirsa.tistory.com/129?category=871751\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://nirsa.tistory.com/129?category=871751</a></li>\n<li><a href=\"https://arisu1000.tistory.com/27862\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://arisu1000.tistory.com/27862</a></li>\n<li><a href=\"https://suhwan.dev/2019/04/22/understanding-kubernetes-design/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://suhwan.dev/2019/04/22/understanding-kubernetes-design/</a></li>\n</ul>\n"}}]}}},"context":{}}