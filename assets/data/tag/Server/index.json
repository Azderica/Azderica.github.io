{"hash":"2858839cb272bd8e3f388ae3dd5d59774a4a3863","data":{"tag":{"title":"Server","belongsTo":{"edges":[{"node":{"title":"[Network] gRPC란?","path":"/00-network-g-rpc/","date":"15. September 2021","timeToRead":6,"description":"gRPC의 개념과 HTTP API의 차이점에 대해 작성합니다.","content":"<h1 id=\"grpc\"><a href=\"#grpc\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC</h1>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133439409-25e1eb69-4d77-4428-abeb-bb20ad3ef5df.png\" alt=\"image\"></p>\n<h2 id=\"grpc란\"><a href=\"#grpc%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC란</h2>\n<ul>\n<li>gRPC는 높은 성능의 오픈소스 범용 RPC 프레임워크입니다.</li>\n<li>기본적인 개념은 RPC와 동일하지만 특징으로 HTTP/2 기반으로 양방향 스트리밍을 지원하며 메시지의 압축률과 성능이 좋습니다.</li>\n</ul>\n<h3 id=\"rpc란\"><a href=\"#rpc%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>RPC란</h3>\n<ul>\n<li>Remote Procedure Call의 약자로 프로세스간의 통신 기법 중 하나입니다.</li>\n<li>다른 프로세스에 있는 함수를 호출할 때, 마치 같은 프로세스내에 있는 것 처럼 호출가능합니다. (클라이언트는 일반 로컬 메소드처럼 사용)</li>\n<li>다양한 환경, 플랫폼에 제약없이 사용할 수 있기 때문에 분산 시스템 기법에 효과적입니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133439697-c1e7a3b7-733e-46ba-aa9b-098d580e286e.png\" alt=\"RPC\"></p>\n<blockquote>\n<p>RPC 진행 과정</p>\n</blockquote>\n<ol>\n<li>Client가 자신의 Stub을 호출합니다.</li>\n<li>Stub은 Client가 넘겨준 Parameter들을 Server와 통신할 수 있는 표준 메세지 형태로 변환한 후 Server에 메시지 전송합니다.</li>\n<li>Server측에서는 Client가 Stub을 통해 전송한 메세지를 Server의 Stub에 넘겨줍니다.</li>\n<li>Server측의 Stub은 Client가 전송한 메세지를 자신이 이해할 수 있는 형태로 변환을 해서 Client가 호출한 Method를 실행합니다.</li>\n<li>Method 실행 결과를 Stub을 통해 Client에게 전달합니다.</li>\n<li>Client는 Server와 같은 방식으로 Server가 전송한 메세지를 받고 이해햡니다.</li>\n</ol>\n<blockquote>\n<p>stub?</p>\n</blockquote>\n<p>Client와 Server가 통신할 수 있도록 메시지의 형태를 변환하는 프로그램</p>\n<br/>\n<h2 id=\"grpc의-장점\"><a href=\"#grpc%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC의 장점</h2>\n<h3 id=\"성능\"><a href=\"#%EC%84%B1%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>성능</h3>\n<ul>\n<li>효율적인 이진 메시지 형식인 Protobuf를 사용해 직렬화합니다.</li>\n<li>작은 메시지 페이로드를 발생시켜 모바일 앱과 같은 제한된 대역폭 시나리오에서 중요합니다.</li>\n<li>이진 프레이밍 및 압축, HTTP/2 프로토콜은 간단하며, 보내고 받을 때 모두 효율적입니다.</li>\n</ul>\n<h3 id=\"코드-생성\"><a href=\"#%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>코드 생성</h3>\n<ul>\n<li>gRPC 프레임워크는 코드 생성에 대한 최고 수준의 지원을 제공합니다.</li>\n<li>gRPC 프레임워크는 .proto 파일에서 서비스 기본 클래스, 메시지, 전체 클라이언트를 생성합니다.</li>\n</ul>\n<h3 id=\"엄격한-사양\"><a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%EC%82%AC%EC%96%91\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>엄격한 사양</h3>\n<ul>\n<li>gRPC는 플랫폼 및 구현에 상관없이 일치하므로 이를 준수하기만 하면 됩니다.</li>\n<li><a href=\"https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gRPC 서비스가 따라야 하는 형식에 대한 지침</a></li>\n</ul>\n<h3 id=\"스트리밍\"><a href=\"#%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>스트리밍</h3>\n<ul>\n<li>HTTP/2는 수명이 긴 실시간 통신 스트림에 대한 기초를 제공합니다.</li>\n<li>\n<p>gRPC 서비스는 모든 스트리밍 조합을 지원합니다.</p>\n<ul>\n<li>단항(스트리밍 없음), 서버-클라이언트 스트리밍, 클라이언트-서버 스트리밍, 양방향 스트리밍</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"최종-기한시간-초과-및-취소\"><a href=\"#%EC%B5%9C%EC%A2%85-%EA%B8%B0%ED%95%9C%EC%8B%9C%EA%B0%84-%EC%B4%88%EA%B3%BC-%EB%B0%8F-%EC%B7%A8%EC%86%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>최종 기한/시간 초과 및 취소</h3>\n<ul>\n<li>gRPC는 클라이언트가 RPC가 완료될 때까지대기하는 기간을 지정하도록 할 수 있습니다.</li>\n<li>최종기한이 서버에 전송되고 서버에서 최종 기한을 초과하는 경우 수행할 결정을 결정할 수 있습니다. (ex. 요청 취소 등)</li>\n<li>자식 gRPC 호출을 통해 최종 기한 및 취소를 전파하면 리소스 사용 제한이 가능합니다.</li>\n</ul>\n<br/>\n<h2 id=\"grpc가-적합한-상황인-경우\"><a href=\"#grpc%EA%B0%80-%EC%A0%81%ED%95%A9%ED%95%9C-%EC%83%81%ED%99%A9%EC%9D%B8-%EA%B2%BD%EC%9A%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC가 적합한 상황인 경우</h2>\n<h3 id=\"마이크로-서비스\"><a href=\"#%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마이크로 서비스</h3>\n<ul>\n<li>gRPC는 대기 시간이 짧고 처리량이 높은 통신을 위해 설계되었습니다.</li>\n<li>gRPC는 효율성이 중요한 경량 마이크로 서비스에 적합합니다.</li>\n</ul>\n<h3 id=\"지점간-실시간-통신\"><a href=\"#%EC%A7%80%EC%A0%90%EA%B0%84-%EC%8B%A4%EC%8B%9C%EA%B0%84-%ED%86%B5%EC%8B%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>지점간 실시간 통신</h3>\n<ul>\n<li>양방향 스트리밍을 위한 뛰어난 지원 기능을 제공합니다.</li>\n<li>gRPC 서비스는 풀링을 사용하지 않고 실시간으로 메시지 푸쉬가 가능합니다.</li>\n</ul>\n<h3 id=\"polyglot-환경\"><a href=\"#polyglot-%ED%99%98%EA%B2%BD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Polyglot 환경</h3>\n<ul>\n<li>gRPC 도구는 널리 사용되는 모든 개발 언어를 지원하여, 다중 언어 환경에서 적합합니다.</li>\n</ul>\n<h3 id=\"네트워크-제한-환경\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A0%9C%ED%95%9C-%ED%99%98%EA%B2%BD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>네트워크 제한 환경</h3>\n<ul>\n<li>gRPC 메시지는 경량 메시지 형식인 Protobuf를 사용해 직렬화됩니다.</li>\n</ul>\n<h3 id=\"ipc프로세스-간-통신\"><a href=\"#ipc%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B0%84-%ED%86%B5%EC%8B%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>IPC(프로세스 간 통신)</h3>\n<ul>\n<li><a href=\"https://docs.microsoft.com/ko-kr/aspnet/core/grpc/interprocess?view=aspnetcore-5.0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gRPC와 프로세스 간 통신</a></li>\n</ul>\n<br/>\n<h2 id=\"grpc의-약점\"><a href=\"#grpc%EC%9D%98-%EC%95%BD%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC의 약점</h2>\n<h3 id=\"제한된-브라우저-지원\"><a href=\"#%EC%A0%9C%ED%95%9C%EB%90%9C-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>제한된 브라우저 지원</h3>\n<ul>\n<li>현재 브라우저에서 gRPC 서비스를 직접 호출하는 것은 불가능합니다.</li>\n<li>gRPC는 HTTP/2 기능을 많이 사용하며 브라우저에는 웹 요청에 필요한 제어 수준을 제공하지 않습니다.</li>\n</ul>\n<h4 id=\"grpc를-브라우저-앱으로-가져오는-방법\"><a href=\"#grpc%EB%A5%BC-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%95%B1%EC%9C%BC%EB%A1%9C-%EA%B0%80%EC%A0%B8%EC%98%A4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC를 브라우저 앱으로 가져오는 방법</h4>\n<ul>\n<li><a href=\"https://grpc.io/docs/platforms/web/basics/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gRPC-Web</a></li>\n<li><a href=\"https://docs.microsoft.com/ko-kr/aspnet/core/grpc/httpapi?view=aspnetcore-5.0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gRPC에서 JSON 웹 API</a></li>\n</ul>\n<h3 id=\"사람이-읽을-수-없습니다\"><a href=\"#%EC%82%AC%EB%9E%8C%EC%9D%B4-%EC%9D%BD%EC%9D%84-%EC%88%98-%EC%97%86%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>사람이 읽을 수 없습니다.</h3>\n<ul>\n<li>gRPC 메시지는 기본적으로 Protobuf로 인코딩됩니다.</li>\n<li>이를 읽을려면 추가적인 도구가 필요합니다. (서버 리플렉션이나 gRPC 명령줄 도구)</li>\n</ul>\n<br/>\n<h2 id=\"grpc와-http-api와의-차이\"><a href=\"#grpc%EC%99%80-http-api%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC와 HTTP API와의 차이</h2>\n<table>\n<thead>\n<tr>\n<th>기능</th>\n<th>gRPC</th>\n<th>HTTP API with JSON</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>계약</td>\n<td>필수(.proto)</td>\n<td>선택 사항(Open API)</td>\n</tr>\n<tr>\n<td>프로토콜</td>\n<td>HTTP/2</td>\n<td>HTTP</td>\n</tr>\n<tr>\n<td>Payload</td>\n<td>Protobuf(소형, 이진)</td>\n<td>JSON(대형, 가독성)</td>\n</tr>\n<tr>\n<td>규범</td>\n<td>엄격한 사양</td>\n<td>느슨함, 모든 HTTP가 유효</td>\n</tr>\n<tr>\n<td>스트리밍</td>\n<td>클라이언트, 서버, 양방향</td>\n<td>클라이언트, 서버</td>\n</tr>\n<tr>\n<td>브라우저 지원</td>\n<td>아니요(gRPC-웹 필요)</td>\n<td>웹</td>\n</tr>\n<tr>\n<td>보안</td>\n<td>전송(TLS)</td>\n<td>전송(TLS)</td>\n</tr>\n<tr>\n<td>클라이언트 코드 생성</td>\n<td>예</td>\n<td>OpenAPI + 타사 도구</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"http://what-and-why-and-how.blogspot.com/2019/11/rpc-what-is-rpc-remote-procedure-call.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">What is RPC</a></li>\n<li><a href=\"https://docs.microsoft.com/ko-kr/aspnet/core/grpc/comparison?view=aspnetcore-5.0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ms docs, gRPC Service and HTTP API</a></li>\n<li><a href=\"https://medium.com/@goinhacker/microservices-with-grpc-d504133d191d\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Microservices with gRPC</a></li>\n</ul>\n"}},{"node":{"title":"[Server] 로그 분석 방법","path":"/00-analysis-log/","date":"4. April 2021","timeToRead":5,"description":"리눅스 서버와 윈도우 서버 로그 분석 방법에 대해 정리합니다.","content":"<h1 id=\"서버-로그-분석\"><a href=\"#%EC%84%9C%EB%B2%84-%EB%A1%9C%EA%B7%B8-%EB%B6%84%EC%84%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서버 로그 분석</h1>\n<p>서비스 개발을 하다보면, 장애나 이슈가 발생할 수도 있고 또한 허용되지 않은 사용자가 접근할 수도 있습니다. 이때 보통 서버의 로그를 분석하는 경우가 있는데 이에 대해 정리합니다.</p>\n<p>해당 게시글에서는 리눅스 서버와 윈도우 서버에 대해 정리합니다.</p>\n<br/>\n<h2 id=\"linux-서버\"><a href=\"#linux-%EC%84%9C%EB%B2%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Linux 서버</h2>\n<p>일반적으로 Linux / Unix 기반의 대부분 서버의 로그 파일은 \"/var/log\"에 저장됩니다. 대부분이 text 방식으로 저장되며 <code class=\"language-text\">*.log</code>의 형식을 지니고 있습니다.</p>\n<p>일반적으로 <code class=\"language-text\">cat</code>, <code class=\"language-text\">less</code> 명령어를 사용해서 확인하고, <code class=\"language-text\">*.gz</code> 파일의 경우는 <code class=\"language-text\">zcat</code>을 통해서 압축을 풀지않고 확인할 수 있습니다. 텍스트 형식이 아닌 log 파일 들은 특정 명령어를 사용해서 확인해야합니다.</p>\n<h3 id=\"linux-log-file\"><a href=\"#linux-log-file\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Linux Log File</h3>\n<p>핵심 로그파일은 다음과 같습니다.</p>\n<table>\n<thead>\n<tr>\n<th>로그이름</th>\n<th>로그 파일명</th>\n<th>설명</th>\n<th>관련 데몬</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>커널 log</strong></td>\n<td><code class=\"language-text\">/dev/console</code></td>\n<td>콘솔에 뿌려지는 로그</td>\n<td>kernel</td>\n</tr>\n<tr>\n<td><strong>시스템 log</strong></td>\n<td><code class=\"language-text\">/var/log/messages</code></td>\n<td>리눅스 커널로그 및 주 로그</td>\n<td>sysload</td>\n</tr>\n<tr>\n<td>보안 log</td>\n<td><code class=\"language-text\">/var/log/secure</code></td>\n<td>보안 인증 관련 로그</td>\n<td>xinetd</td>\n</tr>\n<tr>\n<td>메일 log</td>\n<td><code class=\"language-text\">/var/log/maillog</code></td>\n<td>메일 로그</td>\n<td>sendmail popper</td>\n</tr>\n<tr>\n<td>크론 log</td>\n<td><code class=\"language-text\">/var/log/cron</code></td>\n<td>crond에 의한 로그</td>\n<td>crond</td>\n</tr>\n<tr>\n<td>부팅 log</td>\n<td><code class=\"language-text\">/var/log/boot.log</code></td>\n<td>시스템 부팅시의 로그</td>\n<td>kernel</td>\n</tr>\n<tr>\n<td>커널 부트 메시지 log</td>\n<td><code class=\"language-text\">/var/dmesg</code></td>\n<td>부팅될 당시의 각종 메시지들 저장</td>\n<td>kernel</td>\n</tr>\n<tr>\n<td>커널 log</td>\n<td><code class=\"language-text\">/var/log/wtmp</code></td>\n<td>시스템 전체 로그인 기록 저장</td>\n<td>kernel</td>\n</tr>\n<tr>\n<td>커널 log</td>\n<td><code class=\"language-text\">/var/log/utmp</code></td>\n<td>현재 로그인 사용자에 대한 기록, 사용자 ip를 저장</td>\n<td>kernel</td>\n</tr>\n<tr>\n<td>FTP log</td>\n<td><code class=\"language-text\">/var/log/xferlog</code></td>\n<td>ftp 로그</td>\n<td>ftp</td>\n</tr>\n<tr>\n<td><strong>웹 log</strong></td>\n<td><code class=\"language-text\">/var/log/httpd/access_log</code></td>\n<td>아파치(웹서버) 로그 저장</td>\n<td>httpd</td>\n</tr>\n<tr>\n<td>웹 log</td>\n<td><code class=\"language-text\">/var/log/httpd/error_log</code></td>\n<td>아파치(웹서버) 에러 저장</td>\n<td>httpd</td>\n</tr>\n<tr>\n<td>네임서버 log</td>\n<td><code class=\"language-text\">/var/log/named.log</code></td>\n<td>네임서버( 로그</td>\n<td>name</td>\n</tr>\n</tbody>\n</table>\n<p>이 중 핵심적인 로그를 더 자세하게 보면 다음과 같습니다.</p>\n<h3 id=\"콘솔-로그-devconsole\"><a href=\"#%EC%BD%98%EC%86%94-%EB%A1%9C%EA%B7%B8-devconsole\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>콘솔 로그 (/dev/console)</h3>\n<ul>\n<li>커널에 관련된 내용을 시스템 콘솔에 뿌려주는 로그입니다.</li>\n<li>messages 내용과 일치하는 것은 아니지만 <strong>시스템에 관련된 중요한 내용</strong>(시스템 풀, 다운 등)에 대한 로그를 확인할 수 있습니다.</li>\n<li>/dev/console을 통해서 콘솔로 로그를 뿌려줍니다.</li>\n</ul>\n<h3 id=\"시스템-로그-varlogmessages\"><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%A1%9C%EA%B7%B8-varlogmessages\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>시스템 로그 (/var/log/messages)</h3>\n<ul>\n<li>접속 시 인증에 대한 것, 메일에 관한 내용, 시스템에 관한 변경사항 등인 시스템에 대한 전반적인 로그를 기록합니다.</li>\n<li>시스템 관리자가 가장 신경써야하는 로그 파일이며, 보안사고 발생 시 가장 먼저 분석하는 파일입니다.</li>\n<li>su(root 권한)에 대한 실패 로그와, 데몬 비활성 로그, 부팅 실패 로그와 같이 다양한 로그들이 필요합니다.</li>\n<li><code class=\"language-text\">dmesg</code>를 사용하면 명령어를 확인할 수 있습니다.</li>\n</ul>\n<h3 id=\"보안-로그-varlogsecure\"><a href=\"#%EB%B3%B4%EC%95%88-%EB%A1%9C%EA%B7%B8-varlogsecure\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>보안 로그 (/var/log/secure)</h3>\n<ul>\n<li>모든 접속과 관련하여 언제 어디서 어떤 서비스를 사용했는지 기록합니다.</li>\n<li>login, tcp_wrappers, xinetd 관련 로그들이 남습니다.</li>\n</ul>\n<br/>\n<h2 id=\"window-서버\"><a href=\"#window-%EC%84%9C%EB%B2%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Window 서버</h2>\n<p>일반적으로 윈도우 서버는 IIS 서버로 돌아가고, 많은 회사들이 리눅스 서버를 사용하지만 가끔 사용하는 서버가 있어서 이에 대해서 정리합니다. (그 예외에 속하는 회사이지만...)</p>\n<p>IIS 서버에 접속하는 방법은 다음과 같습니다.</p>\n<ul>\n<li><code class=\"language-text\">제어판</code> => <code class=\"language-text\">관리도구</code> => <code class=\"language-text\">이벤트뷰어</code></li>\n</ul>\n<p>해당 이벤트 로그에 접속하여서, <strong>Windows 로그</strong> 중 중요한 것은 다음과 같습니다.</p>\n<h3 id=\"응용프로그램-로그\"><a href=\"#%EC%9D%91%EC%9A%A9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EB%A1%9C%EA%B7%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>응용프로그램 로그</h3>\n<ul>\n<li>응용프로그램 구동 중 특이사항이 발생될 때 저장되는 로그입니다.</li>\n</ul>\n<h3 id=\"보안-로그\"><a href=\"#%EB%B3%B4%EC%95%88-%EB%A1%9C%EA%B7%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>보안 로그</h3>\n<ul>\n<li>윈도우 보안과 관련된 정보들이 저장되는 로그입니다.</li>\n<li>사용자가 지정한 특정 작업을 수행할 때, 항목이 기록됩니다.</li>\n<li>성공한 작업과 실패한 작업을 모두 감사합니다.</li>\n<li>다른 로그와 다르게 보안 로그는 감사정책이 설정되어야만 기록이 됩니다.</li>\n</ul>\n<h3 id=\"시스템-로그\"><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%A1%9C%EA%B7%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>시스템 로그</h3>\n<ul>\n<li>윈도우 시스템을 구동하거나 운영하면서 발생된 충돌이나 에러 등이 저장되는 로그입니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리</h2>\n<p>간단하게 로그 파일을 정리했습니다. 좀 더 자세하게 보기위해서는 아래의 출처를 참고하면 좋을 듯합니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://blog.naver.com/PostView.nhn?blogId=kdi0373&#x26;logNo=220522832069\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">리눅스 로그파일 종류 및 분석</a></li>\n<li><a href=\"https://blog.naver.com/kdi0373/220524577856\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">윈도우 로그파일 종류 및 분석</a></li>\n</ul>\n"}},{"node":{"title":"[Database] CAP 정리","path":"/00-db-cap/","date":"9. February 2021","timeToRead":4,"description":"CAP 이론에 대해 정리합니다.","content":"<h1 id=\"cap-정리\"><a href=\"#cap-%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CAP 정리</h1>\n<p>DB에 대해 공부하다 보면, CAP 이론에 대해 듣게 됩니다. 비록 이야기가 조금 있기는 하지만 그래도 CAP에 대해 개념을 정리합니다.</p>\n<br/>\n<h2 id=\"cap-란\"><a href=\"#cap-%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CAP 란.</h2>\n<p>CAP이론(Brewer's theorem)은 Network로 연결된 분산된 데이터베이스 시스템은 일관성(Consistency), 가용성(Availability), 분할 내구성(Partition Tolerance)의 3가지 특성 중 2가지 특성만을 충족할 수 있고 3가지를 모두 충족할 수는 없다는 이론입니다.</p>\n<h3 id=\"c일관성-consistency\"><a href=\"#c%EC%9D%BC%EA%B4%80%EC%84%B1-consistency\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>C(<strong>일관성</strong>, Consistency)</h3>\n<ul>\n<li>일관성을 가진다는 것은 모든 데이터를 요청할 때 응답으로 가장 최신의 변경된 데이터를 리턴 또는 실패를 리턴합니다.</li>\n<li>모든 읽기에 대해서 DB노드가 항상 동일한 데이터를 가지고 있어야한다는 의미입니다.</li>\n</ul>\n<h3 id=\"a가용성-availability\"><a href=\"#a%EA%B0%80%EC%9A%A9%EC%84%B1-availability\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>A(<strong>가용성</strong>, Availability)</h3>\n<ul>\n<li>가용성은 모든 요청에 대해서 정상적인 응답을 합니다.</li>\n<li>클러스터의 노드 일부에서 장애가 발생해도 READ나 WRITE 등의 동작은 항상 성공적으로 리턴되어야합니다.</li>\n</ul>\n<h3 id=\"p분할내성-partition-tolerance\"><a href=\"#p%EB%B6%84%ED%95%A0%EB%82%B4%EC%84%B1-partition-tolerance\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>P(<strong>분할내성</strong>, Partition tolerance)</h3>\n<ul>\n<li>메시지 전달이 실패하는 시스템 일부가 망가져도 시스템이 계속 동작할 수 있습니다.</li>\n<li>분할 내구성이란 Node간의 통신 장애가 발생하더라도 동작해야합니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107368608-19285380-6b24-11eb-95b2-846fea107c43.png\" alt=\"image\"></p>\n<p>다만, 현재의 DB와는 문제가 있다는 이야기는 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107371626-d1a3c680-6b27-11eb-9d32-1edebb653aed.png\" alt=\"image\"></p>\n<br/>\n<h2 id=\"일반적으로\"><a href=\"#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9C%BC%EB%A1%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>일반적으로</h2>\n<h3 id=\"cpconsistency--partition-tolerance\"><a href=\"#cpconsistency--partition-tolerance\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CP(Consistency &#x26; Partition Tolerance)</h3>\n<ul>\n<li>어떤 상황에서도 안정적으로 시스템은 운영되지만 Consistency가 보장되지 않는다면 Error를 반환합니다.</li>\n<li><strong>매 순간 Read / Write 에 따른 정합성이 일치할 필요가 있는 경우 적합한 형태입니다.</strong></li>\n</ul>\n<h3 id=\"apavailability--partition-tolerance\"><a href=\"#apavailability--partition-tolerance\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>AP(Availability &#x26; Partition Tolerance)</h3>\n<ul>\n<li>어떤 상황에서도 안정적으로 시스템은 운영됩니다.</li>\n<li>데이터와 상관없이 안정적인 응답을 받을 수 있습니다.</li>\n<li>다만 데이터의 정합성에 대한 보장은 불가능합니다.</li>\n<li><strong>결과적으로 일관성이 보장되는 Eventual Consistency를 보장할 수 있는 시스템에 알맞는 형태입니다.</strong></li>\n</ul>\n<h3 id=\"대부분은\"><a href=\"#%EB%8C%80%EB%B6%80%EB%B6%84%EC%9D%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>대부분은...</h3>\n<ul>\n<li>사실 대부분 CP, AP 시스템은 없고 대부분 CP와 AP의 어느 중간 쯤에 존재합니다.</li>\n<li>예제에 봤듯이 configuration에 따라 변하기도 하고, 이론 자체에서 한계점도 존재합니다.</li>\n<li>가장 큰 문제는 P에 대한 명확한 정의가 부족합니다.</li>\n<li>기존의 문제를 해결하기 위해 PACELC 이론이 등장하였습니다.</li>\n</ul>\n<br/>\n<h2 id=\"pacelc-이론\"><a href=\"#pacelc-%EC%9D%B4%EB%A1%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PACELC 이론</h2>\n<p>다음과 같은 요소로 표현됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107372209-7faf7080-6b28-11eb-897d-461cc4b64a86.png\" alt=\"pacelc\"></p>\n<h3 id=\"pacelc-구성\"><a href=\"#pacelc-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PACELC 구성</h3>\n<p>PACELC는 크게 4가지로 구성됩니다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>구성</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Partition</td>\n<td>Availability</td>\n<td>가용성</td>\n</tr>\n<tr>\n<td></td>\n<td>Consistency</td>\n<td>일관성</td>\n</tr>\n<tr>\n<td>Else</td>\n<td>Latency</td>\n<td>시간 지연</td>\n</tr>\n<tr>\n<td></td>\n<td>Consistency</td>\n<td>일관성</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"pacelc-대입\"><a href=\"#pacelc-%EB%8C%80%EC%9E%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PACELC 대입</h3>\n<p>이를 기존의 DB에 대입시키면 다음과 같이 볼 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107372699-0bc19800-6b29-11eb-96f0-957e59da40b8.png\" alt=\"pacelc-db\"></p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>CAP 이론과 PACELC 이론에 대한 개념을 잡았습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://jins-dev.tistory.com/entry/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%98%EA%B2%BD-Distributed-System-%EC%97%90%EC%84%9C-BASE-%EC%9B%90%EC%B9%99%EA%B3%BC-CAP-%EC%A0%95%EB%A6%AC\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://jins-dev.tistory.com/entry/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%98%EA%B2%BD-Distributed-System-%EC%97%90%EC%84%9C-BASE-%EC%9B%90%EC%B9%99%EA%B3%BC-CAP-%EC%A0%95%EB%A6%AC</a></li>\n<li><a href=\"https://sabarada.tistory.com/91\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://sabarada.tistory.com/91</a></li>\n<li><a href=\"https://m.blog.naver.com/PostView.nhn?blogId=windfalcon1&#x26;logNo=220402574806&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.blog.naver.com/PostView.nhn?blogId=windfalcon1&#x26;logNo=220402574806&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F</a></li>\n</ul>\n"}},{"node":{"title":"[Network] Cacti란?","path":"/00-network-cacti/","date":"31. January 2021","timeToRead":2,"description":"Cacti에 대해 작성합니다.","content":"<h1 id=\"cacti\"><a href=\"#cacti\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cacti</h1>\n<p>엄청 오래된 모니터링 툴이지만, 직접 설치를 하지 않더라도 어떤 개념인지는 알아야겠다는 생각이 있어 정리합니다.</p>\n<h2 id=\"cacti란\"><a href=\"#cacti%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cacti란</h2>\n<ul>\n<li>SNMP 프로토콜을 사용하는 네트워크 <strong>모니터링 툴</strong>입니다.</li>\n<li>관리 및 사용은 브라우저를 통해 이뤄지고, 모든 관리 데이터들은 MySQL을 이용하여 저장됩니다.</li>\n<li>Poller는 주어진 대상 시스템을 조회하여 가져온 결과를 RRD 파일에 저장하고 이 정보를 통해 그래프를 만드는데도 사용됩니다.</li>\n</ul>\n<p><a href=\"https://docs.cacti.net/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">공식 Document</a></p>\n<br/>\n<h2 id=\"cacti의-작업\"><a href=\"#cacti%EC%9D%98-%EC%9E%91%EC%97%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cacti의 작업</h2>\n<h3 id=\"data-retrieval\"><a href=\"#data-retrieval\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Retrieval</h3>\n<ul>\n<li>poller를 사용해서 데이터를 검색합니다.</li>\n<li>Poller는 Unix의 Crontab과 같은 스케쥴러를 수행합니다.</li>\n<li>\n<p>Cacti는 원격 대상의 데이터 검색에 네트워크 관리 프로토콜인 SNMP를 사용합니다.</p>\n<ul>\n<li>Cacti는 SNMP를 사용할 수 있는 모든 디바이스를 모니터링 할 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"data-storage\"><a href=\"#data-storage\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Storage</h3>\n<ul>\n<li>Cacti를 데이터를 저장하기 위해 RRDTool을 사용합니다.</li>\n<li>히스토리 데이터는 공간 절약을 위해 압축합니다.</li>\n</ul>\n<h3 id=\"data-presentation\"><a href=\"#data-presentation\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Presentation</h3>\n<ul>\n<li>그래프 함수로 보여줄 수 있습니다.</li>\n<li>그래프에 다양한 항목을 표현할 수 있고 어떤 플랫폼에서든 거의 모든 브라우저에서 액세스할 수 있습니다.</li>\n<li>Cacti는 PHP로 주로 작성되어 있습니다.</li>\n</ul>\n<br/>\n<h2 id=\"cacti-설치\"><a href=\"#cacti-%EC%84%A4%EC%B9%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cacti 설치</h2>\n<h3 id=\"일반적인-사용-명령어\"><a href=\"#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%82%AC%EC%9A%A9-%EB%AA%85%EB%A0%B9%EC%96%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>일반적인 사용 명령어</h3>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> cacti</code></pre>\n<p><a href=\"https://yongho1037.tistory.com/553\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">좀 더 자세하게 보기위해서는...</a></p>\n<p>위 글을 참고하면서 사용하면 좋을 듯합니다.</p>\n<h3 id=\"redis-사용\"><a href=\"#redis-%EC%82%AC%EC%9A%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 사용</h3>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> -u cacti php /usr/share/cacti/scripts/ss_get_by_ssh.php --type redis --host <span class=\"token number\">127.0</span>.0.1 --items ln,lo</code></pre>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://yongho1037.tistory.com/553\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://yongho1037.tistory.com/553</a></li>\n<li><a href=\"https://docs.cacti.net/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://docs.cacti.net/</a></li>\n<li><a href=\"https://www.percona.com/doc/percona-monitoring-plugins/1.1/cacti/redis-templates.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.percona.com/doc/percona-monitoring-plugins/1.1/cacti/redis-templates.html</a></li>\n<li><a href=\"https://server-talk.tistory.com/148\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://server-talk.tistory.com/148</a></li>\n</ul>\n"}},{"node":{"title":"[Network] NGINX란?","path":"/00-network-nginx/","date":"14. January 2021","timeToRead":3,"description":"NGINX에 대해 작성합니다.","content":"<h1 id=\"nginx란\"><a href=\"#nginx%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nginx란.</h1>\n<h2 id=\"nignx의-정의\"><a href=\"#nignx%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nignx의 정의.</h2>\n<p>Nginx는 가벼움과 높은 성능을 목표로 하는 웹서버 소프트웨어입니다.</p>\n<p>이러한 Nginx는 트래픽이 많은 웹사이트를 위해 확장성을 위해 설계한 비동기 이벤트 기반 구조를 가지고 있습니다.</p>\n<p>일반적으로 <strong>웹 서버, 리버스 프록시 및 메일 프록시</strong> 기능을 가집니다.</p>\n<br/>\n<h2 id=\"apache-vs-nginx\"><a href=\"#apache-vs-nginx\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Apache VS Nginx</h2>\n<p>주로 Nginx는 Apache 서버와 비교를 하는데, 현재는 Nginx가 1위를 차지하고 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104517057-bd5bcf00-5638-11eb-8e24-859c5bf2ee88.png\" alt=\"server-rank\"></p>\n<blockquote>\n<p>Apache</p>\n</blockquote>\n<ul>\n<li>쓰레드 / 프로세스 기반 구조로 요청 하나당 쓰레드 하나가 처리하는 구조입니다.</li>\n<li>사용자가 많으면 많은 쓰레드가 생성되고, 메모리와 CPU 낭비가 심합니다.</li>\n</ul>\n<blockquote>\n<p>Nginx</p>\n</blockquote>\n<ul>\n<li>비동기 Event-Driven 기반의 구조입니다.</li>\n<li>다수의 연결을 효과적으로 처리가능합니다.</li>\n<li>대부분의 코어 모듈이 Apache보다 적은 리소스로 더 빠르게 동작가능합니다.</li>\n<li>더 작은 쓰레드로 클라이언트의 요청들을 처리 가능합니다.</li>\n</ul>\n<p>Apache와 Nginx의 가장 큰 차이는 Thread 방식과 Event-drive의 차이입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104517420-4bd05080-5639-11eb-92a5-dc3f78cc5891.png\" alt=\"Thread-VS-Event-Driven\"></p>\n<p>다음 그림처럼 쓰레드 기반은 하나의 커넥션 당 하나의 쓰레드를 사용하지만, Event-driven 방식은 여러 커넥션을 모두 Event-Handler를 통해 비동기 방식으로 처리해서 먼저 처리되는 것부터 로직이 진행됩니다.</p>\n<br/>\n<h2 id=\"nginx-활용\"><a href=\"#nginx-%ED%99%9C%EC%9A%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nginx 활용</h2>\n<p>Nginx은 다음과 같은 기능으로 사용할 수 있습니다.</p>\n<ul>\n<li>\n<p>HTTP Server</p>\n<ul>\n<li>정적 파일을 처리하는 web server의 역할을 수행합니다.</li>\n</ul>\n</li>\n<li>\n<p>Reverse proxy server</p>\n<ul>\n<li>클라이언트의 요청을 Application server에 배분합니다.</li>\n<li>클라이언트 80포트 요청을 8080, 8081 등 여러 Application server로 보내줍니다.</li>\n<li>각 application server에 요청을 배분해서 부하를 분산합니다. (load balancing)</li>\n</ul>\n</li>\n<li>Mail proxy server</li>\n<li>Generic TCP/UDP proxy server</li>\n</ul>\n<br/>\n<h2 id=\"nginx-proxy\"><a href=\"#nginx-proxy\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nginx Proxy</h2>\n<p>node.js에서 nginx.conf를 파일을 수정하여 아래처럼 수정하면됩니다.</p>\n<pre class=\"language-conf\"><code class=\"language-conf\">server {\n  listen    81;\n  server_name localhost;\n\n  location / {\n    proxy_pass http://127.0.0.1:3000/;\n  }\n}</code></pre>\n<p>다음과 같이 수정을 하게 되면, 81번 포트로 접속을 해도 3000번 포트의 서버에 접속이 되게됩니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>오늘은 간략하게 Nginx에 대해 정리해보았습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"http://nginx.org/en/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://nginx.org/en/</a></li>\n<li><a href=\"https://news.netcraft.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://news.netcraft.com/</a></li>\n<li><a href=\"https://smjeon.dev/etc/nginx/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://smjeon.dev/etc/nginx/</a></li>\n<li><a href=\"https://m.blog.naver.com/jhc9639/220967352282\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.blog.naver.com/jhc9639/220967352282</a></li>\n</ul>\n"}},{"node":{"title":"[Network] GSLB란?","path":"/00-network-gslb/","date":"11. January 2021","timeToRead":4,"description":"GSLB에 대해 작성합니다.","content":"<h1 id=\"gslb란\"><a href=\"#gslb%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GSLB란?</h1>\n<p>로드밸런서 관련 이야기를 하면서 어쩌면 한번 쯤 GSLB에 대해 들어봤을 수 있다. 회사에서는 F5나, Citrix와 같이 여러 GSLB를 사용하고 있는데 오늘은 이에 대해 한번 정리해봅니다.</p>\n<h2 id=\"gslb의-정의\"><a href=\"#gslb%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GSLB의 정의</h2>\n<p>GLSB는 Global Service Load Balancing의 약자로, <strong>비지니스 연속성 및 재해 복구에 사용되는 기술들의 집합</strong>입니다,</p>\n<p>이러한 GLSB는 다음과 같은 기능을 제공하여, 지능적 DNS 서비스라고도 불리기도 합니다.</p>\n<ul>\n<li>\n<p>재난 복구 (disaster recovery)</p>\n<ul>\n<li>실패에 대해 대체할 수 있는 서버를 제공합니다.</li>\n</ul>\n</li>\n<li>\n<p>부하 분산 (load sharing)</p>\n<ul>\n<li>많은 트래픽을 여러 서버로 분산합니다.</li>\n</ul>\n</li>\n<li>\n<p>성능 (performance)</p>\n<ul>\n<li>client의 위치나 네트워크를 기반으로 최적의 성능을 낼 서버를 선택합니다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"glsb의-동작\"><a href=\"#glsb%EC%9D%98-%EB%8F%99%EC%9E%91\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GLSB의 동작</h2>\n<p>다음과 같은 순서로 진행됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104177144-adcb6300-544b-11eb-8ce7-4cbeef9c7480.png\" alt=\"GLSB-logic\"></p>\n<p>각 서버마다 Health Check를 하고 운영가능한 서버의 IP를 반환합니다.</p>\n<br/>\n<h2 id=\"glsb-vs-dns\"><a href=\"#glsb-vs-dns\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GLSB vs DNS</h2>\n<p>GLSB와 DNS를 비교하면 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104177295-e53a0f80-544b-11eb-8cb4-71d51475305d.png\" alt=\"GLSB-vs-DNS\"></p>\n<p>이를 표로 표현하면 다음과 같습니다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>GLSB</th>\n<th>DNS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>재해복구</td>\n<td>- 모니터링(Health Check) 실패한 IP는 응답에서 제외합니다.</td>\n<td>- 서버의 상황을 알 수 없습니다.</td>\n</tr>\n<tr>\n<td>로드밸런싱</td>\n<td>- 서버를 모니터링 해서 로드가 적은 서버의 IP를 반환합니다.</td>\n<td>- Round Robin 방식을 사용합니다. 정교한 로드밸런싱이 되지않습니다.</td>\n</tr>\n<tr>\n<td>레이턴시 기반</td>\n<td>- 유저에게 더 적은 latency를 가지는 서버로 연결합니다.</td>\n<td>- 네트워크상 멀리 떨어진 위치의 서버에 연결가능합니다.</td>\n</tr>\n<tr>\n<td>위치기반 서비스</td>\n<td>- 유저의 지역 정보에 기반하여, 해당 지역을 서버스하는 서버로 연결합니다.</td>\n<td>- Round Robin</td>\n</tr>\n</tbody>\n</table>\n<br/>\n<h2 id=\"gslb-주요-기술\"><a href=\"#gslb-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EC%88%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GSLB 주요 기술</h2>\n<h3 id=\"health-check\"><a href=\"#health-check\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Health Check</h3>\n<ul>\n<li>등록된 호스트들에 대해 주기적으로 health check를 수행합니다.</li>\n<li>호스트가 실패하는 경우, DNS 응답에서 해당 호스트를 제거합니다.</li>\n<li>실패한 호스트로의 접근을 막아서 서버의 가용성을 높입니다.</li>\n</ul>\n<h3 id=\"ttltime-to-live\"><a href=\"#ttltime-to-live\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>TTL(Time to Live)</h3>\n<ul>\n<li>DNS에서 권한을 가진 네임 서버는 특정 레코드에 대해 TTL를 설정할 수 있습니다.</li>\n<li>캐시 네임서버는 TTL 동안 캐시에 저장하고, Client로부터 요청이 오면 캐시에 저장된 값을 반환합니다.</li>\n<li>TTL값이 너무 크면, GLSB의 상태 정보가 제때 동기화되지 못합니다.</li>\n<li>TTL값이 너무 짧으면, 네임서버에 오는 부담감이 커집니다.</li>\n</ul>\n<h3 id=\"네트워크-거리와-지역\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B1%B0%EB%A6%AC%EC%99%80-%EC%A7%80%EC%97%AD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>네트워크 거리와 지역</h3>\n<ul>\n<li>주기적으로 성능을 측정하고 결과를 저장합니다.</li>\n<li>DNS 질의에 대해 지리적으로 가까운 서버를 반환하거나 네트워크 거리가 가까운 서버를 반환합니다.</li>\n<li>지리적으로 가까운 서버는 RTT(Round Trip Time)도 짧기 때문에 동일한 결과를 반환하는 경우가 많습니다.</li>\n</ul>\n<br/>\n<h2 id=\"대표적인-서비스\"><a href=\"#%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>대표적인 서비스</h2>\n<ul>\n<li>AWS : Route53</li>\n<li>Google Cloud : Cloud Load Balancing</li>\n<li>Azure : Traffic Manager</li>\n<li>Naver : Global Route Manager</li>\n<li>F5</li>\n<li>Citrix</li>\n</ul>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간단하게 GSLB에 대해 정리했습니다. 잘못된 부분 있으면 편하게 알려주세요.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://ckddn9496.tistory.com/33\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ckddn9496.tistory.com/33</a></li>\n<li><a href=\"https://nesoy.github.io/articles/2020-01/GSLB\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://nesoy.github.io/articles/2020-01/GSLB</a></li>\n<li><a href=\"https://blog.naver.com/n_cloudplatform/221206343859\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://blog.naver.com/n_cloudplatform/221206343859</a></li>\n<li><a href=\"https://www.joinc.co.kr/w/man/12/GSLB\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.joinc.co.kr/w/man/12/GSLB</a></li>\n<li><a href=\"https://cloud.kt.com/portal/ktcloudportal.epc.productintro.gslb.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cloud.kt.com/portal/ktcloudportal.epc.productintro.gslb.html</a></li>\n<li><a href=\"https://cwiki.apache.org/confluence/display/CLOUDSTACK/GSLB+%28Global+Server+Load+Balancing%29+Functional+specification+and+Design+Document\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cwiki.apache.org/confluence/display/CLOUDSTACK/GSLB+%28Global+Server+Load+Balancing%29+Functional+specification+and+Design+Document</a></li>\n<li><a href=\"https://www.netmanias.com/ko/post/blog/5620/dns-data-center-gslb-network-protocol/global-server-load-balancing-for-enterprise-part-1-concept-workflow\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.netmanias.com/ko/post/blog/5620/dns-data-center-gslb-network-protocol/global-server-load-balancing-for-enterprise-part-1-concept-workflow</a></li>\n<li><a href=\"https://cloud.kt.com/portal/ktcloudportal.epc.productintro.gslb.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cloud.kt.com/portal/ktcloudportal.epc.productintro.gslb.html</a></li>\n</ul>\n"}},{"node":{"title":"[Server] IDC란?","path":"/00-server-idc/","date":"30. December 2020","timeToRead":2,"description":"IDC에 대한 개념을 정리합니다. ","content":"<h1 id=\"idc\"><a href=\"#idc\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>IDC</h1>\n<p>회사에서 서버에 대한 이야기를 하다보면, IDC에 대한 이야기가 나올 때가 있습니다. 그 때, IDC가 무슨의미일까라는 생각이 들어 정리합니다.</p>\n<h2 id=\"idc의-정의\"><a href=\"#idc%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>IDC의 정의</h2>\n<ul>\n<li>IDC는 Internet Data Center의 약자로, <strong>서버 컴퓨터와 네트워크 회선 등을 제공하는 시설</strong>입니다.</li>\n<li>일반적으로 서버를 한곳으로 모아서 집중할 필요가 있을 때 설립하는 구조로 보통 운영에 필요한 서버 컴퓨터(Server Computer)와 네트워크(Network) 회선 등을 제공하므로 <strong>서버 호텔(Server Hotel)</strong> 이라고 불리기도 합니다.</li>\n</ul>\n<h3 id=\"idc의-특징\"><a href=\"#idc%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>IDC의 특징</h3>\n<ul>\n<li>많은 회사에서 IDC는 매우 중요한 시설입니다. IDC는 <strong>네트워크 속도</strong>와 <strong>관리의 이점</strong>을 가집니다.</li>\n<li>\n<p>IDC는 <strong>정전 등으로 인해 서버가 멈추면 안되기 때문에 절대 정전되지 않도록 설계</strong>되어 있습니다.</p>\n<ul>\n<li>만에 하나를 대비하기 위해 IDC는 전력 공급 업체로부터 우선적으로 전력을 공급받기도 하고, 또는 여러 발전소에서 전력을 공급받을 수 있게 설계하고 때로는 자가발전 등의 설비를 준비해놓습니다.</li>\n</ul>\n</li>\n<li>과거의 IDC는 서버 컴퓨터를 모두 운영하는 구조였으나 현재는 불필요한 서버의 유지비용은 부담되므로 이에 따라 서버 운용 비용을 내리기 위해 IDC의 서버를 임대하기도 합니다.</li>\n</ul>\n<br/>\n<h2 id=\"idc가-왜-필요하나요\"><a href=\"#idc%EA%B0%80-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%98%EB%82%98%EC%9A%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>IDC가 왜 필요하나요?</h2>\n<ul>\n<li>네트워크 속도의 장점을 가집니다.</li>\n<li>관리에서 유리합니다.</li>\n</ul>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://kdtidc.kr/wp/idc/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">IDC란?</a></li>\n<li><a href=\"https://dany-it.tistory.com/172\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">IDC 개념과 사용이유</a></li>\n</ul>\n"}},{"node":{"title":"[Network] CDN이란?","path":"/00-network-cdn/","date":"28. December 2020","timeToRead":5,"description":" CDN에 대해 작성합니다.","content":"<h1 id=\"cdn이란\"><a href=\"#cdn%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CDN이란?</h1>\n<p>롤을 좋아하시는 분 들 중, 저번 큰 이슈 중 하나로 CDN 서버가 나가서 대회가 중단되었던 사례가 있습니다.</p>\n<p>일반적으로 사용자가 많은 사이트나, 서버에서는 거의 대부분 CDN을 사용합니다. 저희 회사에서 배포하는 서비스 또한 CDN을 당연히 쓰고 있고 이에 대한 개념을 아는 것은 거의 필수라고 볼 수 있습니다. 그에 따라 한번 내용을 정리해볼려고합니다.</p>\n<br/>\n<h2 id=\"cdn의-정의\"><a href=\"#cdn%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CDN의 정의</h2>\n<p>CDN(Contents Delivery Network)은 <strong>물리적으로 멀리 떨어져있는 사용자에게 컨텐츠 제공자의 컨텐츠를 더 빠르게 제공할 수 있는 기술</strong>을 의미합니다.</p>\n<p>일반적으로 우리가 많이 보는 넷플릭스와 같이 큰 영상 데이터를 스트리밍해서 사용자에게 보내줘야하는 경우에는 이러한 CDN은 반드시 필요한 기술입니다.</p>\n<p>좀 더 자세하게 설명하자면, 기본적으로 사용자는 원격에 있는 서버(Origin Server)로 부터 Content(Ex. Web Object, Video, Music, Image 등등)을 다운 받을때는 가까이에서 받는것보다 시간이 오래걸립니다. 따라서 사용자와 가까운 곳에 위치한 Cache Server에 Content를 저장(캐싱)하고 Content 요청시에 Cache Server에 응답을 주는 기술입니다.</p>\n<p>즉, CDN은 <strong>콘텐츠를 전송하도록 최적화된 전세계적으로 촘촘히 분산된 서버로 이루어진 플랫폼</strong>입니다. 이 <strong>CDN은 Origin이라고 불리는 콘텐츠 서버와 엔드유저(Client) 사이에서 컨텐츠를 저장</strong>하는 역할을 합니다.</p>\n<br/>\n<h2 id=\"cdn의-이용시-장점\"><a href=\"#cdn%EC%9D%98-%EC%9D%B4%EC%9A%A9%EC%8B%9C-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CDN의 이용시 장점</h2>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103219584-7942ac00-4961-11eb-9011-4e76f394c548.png\" alt=\"CDN 장점\"></p>\n<p>일반적으로 CDN을 사용하지 않으면 Origin 서버의 경우에는 모든 클라이언트의 요청에 일일이 응답해야합니다. 이는 막대한 트래픽을 유발하고, 장애 발생확률을 높입니다.</p>\n<p>CDN을 이용하면 다음과 같은 장점을 가집니다.</p>\n<ul>\n<li>\n<p>성능</p>\n<ul>\n<li>온라인 콘텐츠가 빠르게 전송시킬 수 있습니다.</li>\n<li>해당 Origin 서버가 여러 위치에 CDN을 설치해놓으면 해당 위치에서 신규 콘텐츠를 요청하는 경우, 가까운 곳에서 직접 액세스가 가능하고 이를 통해서 수백, 수천 킬로미터의 왕복시간을 절약할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>가용성</p>\n<ul>\n<li>여러 트래픽 급증, 서버 중단 등의 이슈에서도 클라이언트에게 콘텐츠를 제공할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>보안</p>\n<ul>\n<li>보안적인 지원이 많이 들어가는 CDN을 사용하는 경우, CDN은 악성 유저들의 공격을 막음으로서 사용자들을 보호할 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"cdn의-작동원리\"><a href=\"#cdn%EC%9D%98-%EC%9E%91%EB%8F%99%EC%9B%90%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CDN의 작동원리.</h2>\n<p>CDN은 다음과 같이 작동합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103219998-7b593a80-4962-11eb-9b95-290c39678b9c.png\" alt=\"CDN 작동원리\"></p>\n<ol>\n<li>일반적으로 웹 브라우저가 실행되는 디바이스인 PC나 모바일에서 사용자가 접근해서 필요한 콘텐츠를 요청합니다.</li>\n<li>대부분의 CDN의 경우, 각 요청이 발생시 가장 가까운 위치에 최적으로 배치된 CDN 서버에 클라이언트가 매핑되고 해당 서버는 이 데이터를전송합니다.</li>\n<li>오래된 CDN의 경우, 요청 프록시를 통해서 Origin 서버에 콘텐츠를 요청하고 새로운 콘텐츠로 저장합니다.</li>\n</ol>\n<br/>\n<h2 id=\"cdn-캐싱-방식의-종류\"><a href=\"#cdn-%EC%BA%90%EC%8B%B1-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CDN 캐싱 방식의 종류</h2>\n<p>Content 캐싱은 Static과 Dynamic으로 나눌 수 있습니다.</p>\n<h3 id=\"static-caching\"><a href=\"#static-caching\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Static Caching</h3>\n<ul>\n<li>사용자 요청이 없어도 Origin Server에 있는 Content를 운영자가 미리 Cache Server에 복사합니다,</li>\n<li>따라서 사용자가 Cache Server에서 Content를 요청시 반드시 해당 컨텐츠는 Cache Server에 있습니다.</li>\n<li>대부분의 국내 CDN은 이 방식을 선호합니다.</li>\n</ul>\n<h3 id=\"dynamic-caching\"><a href=\"#dynamic-caching\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Dynamic Caching</h3>\n<ul>\n<li>최초 Cache Server에는 Content가 없습니다.</li>\n<li>사용자가 Content를 요청하면, 해당 Content가 있는지 확인하고 없으면 Origin Server로부터 다운로드 받습니다</li>\n<li>이후 동일 Content 요청을 받은 경우, 저정(캐싱)된 Content를 사용자에게 전달합니다. (Cache Hit)</li>\n<li>각 Content는 일정시간(TTL)이 지나면 Content Server에서 삭제될 수 있고 혹은 Origin Server를 통해서 Content 최신화 된 이후 계속 가지고 있을 수 있습니다.</li>\n<li>Global CDN 업체의 경우에는 일반적으로 이 방식을 선호합니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>오늘은 간단하게, CDN에 대해 정리해보았습니다. 많은 회사에서 CDN을 쓰고 있고 이에 따라 이정도의 개념은 알고 있는 것이 좋은 것 같습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://cdn.hosting.kr/cdn%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cdn.hosting.kr/cdn%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/</a></li>\n<li><a href=\"https://goddaehee.tistory.com/173\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://goddaehee.tistory.com/173</a></li>\n<li><a href=\"https://brownbears.tistory.com/408\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://brownbears.tistory.com/408</a></li>\n</ul>\n"}},{"node":{"title":"[Server] 토큰 기반 인증과 JWT","path":"/00-server-jwt/","date":"25. December 2020","timeToRead":10,"description":" 토큰 기반 인증과 JWT에 대해 알아보겠습니다. ","content":"<h1 id=\"jwt\"><a href=\"#jwt\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JWT</h1>\n<p>최근 업무에서 긴급 이슈가 있었는데, 그 자세한 내용을 설명할 수는 없으나 가장 큰 원인 중 하나는 토큰 이슈였습니다. 그에 따라 오늘 토큰 기반의 인증과 가장 유명한 JWT(Json Web Token)에 대해 정리해볼려고 합니다.</p>\n<br/>\n<h2 id=\"토큰token-기반-인증\"><a href=\"#%ED%86%A0%ED%81%B0token-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>토큰(Token) 기반 인증</h2>\n<p>토큰 기반의 인증은 모던 웹서비스에서 많이 사용됩니다. 특히 API를 사용하는 웹서비스를 개발해야한다면 토큰을 사용하는 방법이 가장 좋습니다.</p>\n<h3 id=\"기존-서버-기반-인증\"><a href=\"#%EA%B8%B0%EC%A1%B4-%EC%84%9C%EB%B2%84-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>기존 서버 기반 인증</h3>\n<p>기존의 서버 기반의 인증은 다음과 같은 구조를 가지고 있었습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103119059-06ada400-46b5-11eb-8e01-e1e841b40823.png\" alt=\"서버기반인증\"></p>\n<p>하지만 이러한 서버 기반의 인증은 다음과 같은 문제를 가집니다. (그러나 아직 사용하는 곳도 많습니다.)</p>\n<ul>\n<li>\n<p>세션</p>\n<ul>\n<li>유저가 인증을 할 때, 서버는 이 기록을 서버에 저장합니다. (= 세션)</li>\n<li>로그인 중인 유저가 늘어날 수록 서버의 램이 과부화됩니다. (DB에 저장하면 DB 성능의 무리가 오게됩니다.)</li>\n</ul>\n</li>\n<li>\n<p>확장성</p>\n<ul>\n<li>세션을 사용하는 경우에는 더 많은 트래픽을 감당하기 위해 여러개의 프로세스를 돌리거나, 여러 서버 컴퓨터를 추가하는 것이 어려워집니다.</li>\n</ul>\n</li>\n<li>\n<p>CORS(Cross-Origin Resource Sharing)</p>\n<ul>\n<li>일반적으로 쿠키는 단일 도메인 및 서브 도메인엣만 작동하도록 설계되어 있는데 이러한 쿠키를 여러 도메인에서 관리하는 것은 번거롭습니다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"토큰-기반-시스템의-작동-원리\"><a href=\"#%ED%86%A0%ED%81%B0-%EA%B8%B0%EB%B0%98-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>토큰 기반 시스템의 작동 원리.</h4>\n<p>토큰 기반 시스템은 <strong>stateless</strong>(상태를 유지하지 않음) 합니다. 이 덕분에 위에서 발생한 문제들이 해결됩니다.</p>\n<p>토큰 기반 시스템은 다음과 같이 작동합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103119347-4c1ea100-46b6-11eb-9a90-a7fab5edbc1b.png\" alt=\"토큰기반인증\"></p>\n<p>이를 순서로 나타내면 다음과 같습니다.</p>\n<ol>\n<li>유저가 <strong>로그인</strong>을 합니다.</li>\n<li>서버가 <strong>계정정보를 검증</strong>합니다.</li>\n<li>계정 정보가 정확한 경우, 서버측에서 <strong>signed 토큰을 발급</strong>해줍니다.</li>\n<li>클라이언트 측에서는 전달받은 <strong>토큰을 저장</strong>하고, 서버 <strong>요청마다 토큰을 함께 서버에 전달</strong>합니다.</li>\n<li>서버는 <strong>토큰을 검증</strong>하고 <strong>요청에 응답</strong>합니다.</li>\n</ol>\n<h3 id=\"토큰-기반-서비스를-선택하는-이유\"><a href=\"#%ED%86%A0%ED%81%B0-%EA%B8%B0%EB%B0%98-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>토큰 기반 서비스를 선택하는 이유.</h3>\n<p>일반적으로 토큰 기반의 인증 시스템은 다음의 장점을 가집니다.</p>\n<ul>\n<li>\n<p>Stateless 서버</p>\n<ul>\n<li>Stateful 서버 : 클라이언트에게 요청받을때마다, 클라이언트의 상태를 계속 유지합니다. 세션에 로그인 정보 등을 저장하고 계속 활용합니다.</li>\n<li><strong>Stateless 서버</strong> : 상태를 유지 하지 않는 서버. 상태정보를 저장하지 않고, 서버는 클라이언트측에서 들어오는 요청만으로 작업을 진행, 이 경우에는 클라이언트와 서버의 연결고리가 없으므로 <strong>서버의 확장성에서 장점</strong>을 가집니다.</li>\n</ul>\n</li>\n<li>\n<p>모바일 어플리케이션에 적합</p>\n<ul>\n<li>만약에 Android와 IOS에서 작동하는 어플리케이션을 개발할 때, 안전한 API를 만들기 위해서는 쿠키 등은 좋은 해결책이 될 수 없습니다. (쿠키 컨테이너를 사용해야하기 때문에...)</li>\n</ul>\n</li>\n<li>\n<p>인증정보를 다른 어플리케이션으로 전달</p>\n<ul>\n<li>대표적인 서비스로 OAuth 등이 있습니다. 구글이나 페이스북, 카카오톡, 네이버와 같은 소셜 계정을 통해 다른 웹서비스에서도 로그인 가능합니다.</li>\n</ul>\n</li>\n<li>\n<p>보안</p>\n<ul>\n<li>토큰 기반의 인증을 통해서 어플리케이션의 보안을 높일 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"토큰-기반-서비스의-장점\"><a href=\"#%ED%86%A0%ED%81%B0-%EA%B8%B0%EB%B0%98-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>토큰 기반 서비스의 장점.</h3>\n<p>따라서 토큰 기반의 서비스는 다음과 같은 장점을 가집니다.</p>\n<ul>\n<li>\n<p>무상태이며 확장성을 가짐</p>\n<ul>\n<li>기존에 설명한 것처럼 많은 리소스 소모를 줄일 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>보안성</p>\n<ul>\n<li>쿠키를 사용하지 않으므로 쿠키 취약점을 방지할 수 있습니다.</li>\n<li>다만 토큰도 취약점이 존재합니다.</li>\n</ul>\n</li>\n<li>\n<p>확장성(Extensibility)</p>\n<ul>\n<li>토큰을 통해 다른 서비스에 권한을 공유함으로서 사업이나 분야를 확장할 수 있습니다.</li>\n<li>토큰에 선택적인 권한만 부여하여 발급할 수도 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>여러 플랫폼 및 도메인</p>\n<ul>\n<li>토큰만 유효하다면 여러 플랫폼과 도메인에서 사용할 수 있습니다.</li>\n<li>서버측 어플리케이션 응답부분에 다음 헤더만 포함하면 <code class=\"language-text\">Access-Control-Allow-Origin: *</code> 서버에서는 쉽게 정리할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>웹 표준 기반</p>\n<ul>\n<li>JWT는 웹 표준에 등록되어 있기 때문에 여러 환경에서 지원이 됩니다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"jwtjson-web-token\"><a href=\"#jwtjson-web-token\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JWT(Json Web Token)</h2>\n<p>그렇다면 메인 디쉬인 JWT(Json Web Token)에 대해 이야기를 해보겠습니다.</p>\n<p><strong>JWT(JSON Web Token)</strong> 은 웹표준(RFC 7519)으로 두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적인 (self-contained) 방식으로 정보를 안정성 있게 전달합니다.</p>\n<p>JSON은 다음과 같은 특징을 유지합니다.</p>\n<ul>\n<li>수많은 프로그래밍 언어에서 지원됩니다. (대부분의 주류 프로그래밍 언어에서 지원)</li>\n<li>\n<p>자가 수용적 (self-contained)</p>\n<ul>\n<li>JWT는 필요한 모든 정보를 가지고 있습니다.</li>\n<li>토큰, 토큰에 대한 기본정보, 전달할 정보, signature 등을 가지고 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>쉽게 전달 될 수 있습니다.</p>\n<ul>\n<li>JWT는 자가수용적으로 두 개체 사이에서 손쉽게 전달된다.</li>\n<li>웹 서버의 경우 HTTP의 헤더에 넣어서 전달할 수 있고, ULR의 파라미터로도 전달 가능합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jwt의-정의\"><a href=\"#jwt%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JWT의 정의</h3>\n<p>JWT는 <code class=\"language-text\">.</code> 을 구분자로 3가지의 문자열로 되어있습니다. 구조는 다음과 같이 이루어졌습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103124452-24860380-46cb-11eb-827e-b1d02001516f.png\" alt=\"jwt\"></p>\n<p>JWT 토큰을 만들때는 JWT를 담당하는 라이브러리가 자동으로 인코딩 및 해싱 작업을 해줍니다.</p>\n<h4 id=\"헤더\"><a href=\"#%ED%97%A4%EB%8D%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>헤더</h4>\n<p><strong>Header</strong>는 <strong>typ</strong>과 <strong>alg</strong> 의 두가지 정보를 지니고 있습니다.</p>\n<ul>\n<li><strong>typ</strong> : 토큰의 타입을 지정 - JWT</li>\n<li><strong>alg</strong> : 해싱 알고리즘을 지정 - HMAC SHA256이나 RSA가 주로 사용, signature에서 사용</li>\n</ul>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"typ\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"JWT\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"alg\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"HS256\"</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>인코딩에 대한 코드 예시입니다.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> header <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">typ</span><span class=\"token operator\">:</span> <span class=\"token string\">'JWT'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">alg</span><span class=\"token operator\">:</span> <span class=\"token string\">'HS256'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// encode to base64</span>\n<span class=\"token keyword\">const</span> encodedPayload <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Buffer</span><span class=\"token punctuation\">(</span><span class=\"token known-class-name class-name\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">stringify</span><span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token method function property-access\">toString</span><span class=\"token punctuation\">(</span><span class=\"token string\">'base64'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token method function property-access\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'='</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span></code></pre>\n<h4 id=\"정보payload\"><a href=\"#%EC%A0%95%EB%B3%B4payload\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>정보(payload)</h4>\n<p><strong>payload</strong> 부분에는 토큰에 담을 정보가 있습니다. 여기에 담는 정보의 한 조각을 클레임(<strong>claim</strong>) 이라고 부르며, 이는 <code class=\"language-text\">name/value</code>의 한쌍으로 이뤄져 있습니다.</p>\n<p>클레임은 크게 3가지(등록-registered, 공개-public, 비공개-private)로 분류됩니다.</p>\n<h5 id=\"1-등록된-registered클레임\"><a href=\"#1-%EB%93%B1%EB%A1%9D%EB%90%9C-registered%ED%81%B4%EB%A0%88%EC%9E%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 등록된 (registered)클레임</h5>\n<p>등록된 클레임들은 이름이 이미 정해진 클레임이며, 모두 선택적입니다.</p>\n<ul>\n<li><code class=\"language-text\">iss</code> : 토큰 발급자 (issuer)</li>\n<li><code class=\"language-text\">sub</code> : 토큰 제목 (subject)</li>\n<li><code class=\"language-text\">aud</code> : 토큰 대상자 (audience)</li>\n<li><code class=\"language-text\">exp</code> : 토큰의 만료시간 (expiration), NumericDate</li>\n<li><code class=\"language-text\">nbf</code> : 토큰 활성 날짜</li>\n<li><code class=\"language-text\">iat</code> : 토큰이 발급된 시간, 나이를 확인할 수 있습니다.</li>\n<li><code class=\"language-text\">jti</code> : JWT의 고유 식별자, 중복처리를 방지하기 위해서 사용합니다.</li>\n</ul>\n<h5 id=\"2-공개-public-클레임\"><a href=\"#2-%EA%B3%B5%EA%B0%9C-public-%ED%81%B4%EB%A0%88%EC%9E%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 공개 (public) 클레임</h5>\n<p>공개 클레임들은 충돌이 방지된 이름을 가지고 있습니다. 일반적으로 충돌을 막기 위해 클레임을 URI 형식으로 짓습니다.</p>\n<h5 id=\"3-비공개-private-클레임\"><a href=\"#3-%EB%B9%84%EA%B3%B5%EA%B0%9C-private-%ED%81%B4%EB%A0%88%EC%9E%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 비공개 (private) 클레임</h5>\n<p>등록된 클레임도 아니고 공개된 클레임이 아닙니다. 일반적으로 서버 협의에 사용되는 클레임입니다.</p>\n<p>예제 payload는 다음과 같습니다.</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"iss\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"github.com\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"https://Azderica.github.io/is_admin\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token property\">\"username\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Azderica\"</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>마찬가지로 위의 코드처럼 encode 할 수 있습니다.</p>\n<h4 id=\"서명signature\"><a href=\"#%EC%84%9C%EB%AA%85signature\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서명(signature)</h4>\n<p>JSON Web Token의 마지막 부분은 서명(signature)입니다. 서명은 헤더의 인코딩 값과 정보의 인코딩 값을 합쳐서 주어진 비밀키로 해쉬를 하여 생성</p>\n<p>서명 부분을 만드는 슈도코드(pseudocode)의 구조는 다음과 같습니다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code></pre>\n<p>이렇게 만든 해쉬를 <code class=\"language-text\">base64</code> 형태로 나타냅니다.</p>\n<h3 id=\"jwt는-언제-사용하지\"><a href=\"#jwt%EB%8A%94-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JWT는 언제 사용하지?</h3>\n<ul>\n<li>\n<p>회원 인증</p>\n<ul>\n<li>JWT를 사용하는 가장 흔한 시나리오입니다.</li>\n<li>유저가 로그인 시, 서버는 유저의 정보에 기반한 토큰을 발급하여 유저에게 전달하고 이후 요청시 JWT를 포함하여 전달합니다.</li>\n<li>서버측에서 유저의 세션을 유지할 필요가 없어서 리소스를 아낄 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>정보 교류</p>\n<ul>\n<li>JWT는 두 개체 사이에서 안정성있게 정보를 교환하기에 좋은 방법</li>\n<li>정보가 sign이 되어있기 때문에 정보가 조작되지 않았는지를 검증할 수 있음.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>토큰 기반의 인증 시스템과 JWT에 대해 알아보았습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://velopert.com/2350\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velopert.com/2350</a></li>\n<li><a href=\"https://velopert.com/2389\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velopert.com/2389</a></li>\n<li><a href=\"http://www.opennaru.com/opennaru-blog/jwt-json-web-token/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://www.opennaru.com/opennaru-blog/jwt-json-web-token/</a></li>\n</ul>\n"}},{"node":{"title":"[Server] 서버리스 아키텍처에 대한 기초 지식","path":"/00-server-serverless/","date":"25. November 2020","timeToRead":13,"description":" 서버리스와 서버 아키텍처에 대한 기본 내용을 정리한 글입니다. ","content":"<h1 id=\"서버리스-아키텍처에-대하여\"><a href=\"#%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서버리스 아키텍처에 대하여</h1>\n<p>회사에서 개발과 관련해서 이야기를 하는데, CaaS, FaaS, BaaS 등에 대한 이야기를 듣게 되었다. 생각해보니 이름만 들어보고 한 번도 제대로 알아본적이 없어서 이번기회에 정리합니다.</p>\n<p>서버리스(Serverless)란 말 그대로 서버가 없다는 의미는 아닙니다. 다만, 특정 작업을 수행하기 위해서 컴퓨터 혹은 가상머신에 서버를 설정할 필요없이 다른 서비스(BaaS, FaaS) 등에 의존해서 작업을 처리합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100229273-5474a680-2f67-11eb-8a3a-467c9f409a72.png\" alt=\"image\"></p>\n<blockquote>\n<p>들어가기에 앞서서 간단한 발전 과정은 다음과 같습니다.</p>\n</blockquote>\n<p><br/>></p>\n<h2 id=\"기존-애플리케이션\"><a href=\"#%EA%B8%B0%EC%A1%B4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>기존 애플리케이션</h2>\n<h3 id=\"1-자체-설계\"><a href=\"#1-%EC%9E%90%EC%B2%B4-%EC%84%A4%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 자체 설계</h3>\n<p>시스템에서 필요한 모든 인프라를 직접 관리합니다. 기존의 <strong>전산실</strong>로 이해하면 됩니다.</p>\n<ul>\n<li>필요한 모든 인프라를 직접 관리. 예를 들어 기업 전산실에서 서버 및 하드웨어, 네트워크, 운영체제 등을 갖추어 모두 직접 처리해야합니다.</li>\n<li>시스템이 커질 수록 유지할 관리자가 필요하고, 이에 따른 비용이 발생합니다.</li>\n</ul>\n<h3 id=\"2-iaasinfrastructure-as-a-service\"><a href=\"#2-iaasinfrastructure-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. IaaS(Infrastructure as a Service)</h3>\n<p>AWS, Azure 등의 서비스에서 제공하는 서비스입니다. 서버자원, 네트워크, 전력 등의 인프라를 직접 구축할 필요없이 이러한 <strong>인프라를 가상화</strong>하여 관리하기 쉽게 해주는 서비스를 제공합니다.</p>\n<p>사용자는 해당 서비스를 통해서 관리자패널에서 인프라를 구성하면 됩니다. 사용자는 가상머신을 만들고 네트워크를 설정하고, 하드웨어를 설정하고, 운영체제를 설치해서 애플리케이션을 구동합니다.</p>\n<h3 id=\"3-paasplatform-as-a-service\"><a href=\"#3-paasplatform-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. PaaS(Platform as a Service)</h3>\n<p>IaaS에서 좀 더 추상화된 모델입니다. 네트워크, OS, 런타임을 제공합니다. 사용자는 애플리케이션만 배포하면 바로 구동할 수 있습니다. 또한 Auto Scaling 및 Load Balacing도 손쉽게 적용가능합니다.</p>\n<p>예시로는 다음과 같습니다.</p>\n<ul>\n<li>AWS Elastic Beanstalk, Azure App Servies 등등</li>\n</ul>\n<br/>\n<h2 id=\"servless\"><a href=\"#servless\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Servless</h2>\n<ul>\n<li>서버리스는 애플리케이션 개발자가 서버를 프로비저닝하거나 애플리케이션의 확장을 관리할 필요가 없습니다.</li>\n</ul>\n<blockquote>\n<p>프로비저닝(Provisioning) : 사용자의 요구에 맞게 시스템을 할당하고 배치, 배포한 이후 필요시에 시스템을 즉시 사용할 수 있는 상태로 미리 준비해놓는 것입니다.</p>\n</blockquote>\n<ul>\n<li>서버가 없다는 뜻은 아니며, 작업을 처리하는 서버는 있지만 서버를 관리할 필요가 없습니다.</li>\n<li>대표적으로 <strong>BaaS</strong> 와 <strong>FaaS</strong>로 나눠집니다.</li>\n</ul>\n<h3 id=\"1-baasbackend-as-a-service\"><a href=\"#1-baasbackend-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. BaaS(Backend as a Service)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100353200-82beb880-3031-11eb-89d9-5a361d5f88c4.png\" alt=\"image\"></p>\n<ul>\n<li>애플리케이션에서 일반 사용자가 보는 영역은 프론트엔드, 관리자가 보는 영역은 백엔드로 불립니다. <strong>이때 BaaS는 백엔드인 관리자 영역을 모듈화하여 서비스</strong>로 제공합니다.</li>\n<li>백엔드 개발(데이터 저장, 다른 기기로 접근, 파일 공유 등)이 필요한 경우, 개발자가 이러한 모든 서비스를 구축하기 어려워서, BaaS를 통해서 개발 시간을 단축합니다.</li>\n<li>IaaS, PaaS가 서버 인프라를 대체하는 정도였다면, <strong>BaaS와 FaaS는 서버 운영까지 맡기는 서비스</strong>입니다.</li>\n<li>대표적인 서비스로는 <strong>Firebase</strong>가 있습니다.</li>\n</ul>\n<p><strong>장점</strong></p>\n<ul>\n<li>개발 시간의 단축</li>\n<li>서버 확장의 불필요함</li>\n<li>백엔드에 대한 지식이 부족하더라도 빠른 속도로 개발이 가능</li>\n<li>토이 프로젝트, 소규모 프로젝트에서는 백엔드로 유용하게 사용가능</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>\n<p>클라이언트 위주의 코드</p>\n<ul>\n<li>백엔드 로직이 클라이언트 쪽에 구현됨 (보안 등의 큰 이슈)</li>\n<li>Firebase SDK를 통해 서버쪽에서 개발할 수 있지만, 이보다는 직접 구현이 좋습니다.</li>\n<li>데이터단의 로직이 변경되면 클라이언트 코드 수정이 이루어집니다.</li>\n</ul>\n</li>\n<li>\n<p>가격</p>\n<ul>\n<li>Firebase의 경우 초반에는 무료이지만, 앱의 규모가 커지면 비싸집니다.</li>\n<li>서비스 규모가 늘어날 수록 직접 구현의 장점이 가능합니다.</li>\n</ul>\n</li>\n<li>\n<p>복잡한 쿼리가 불가능함</p>\n<ul>\n<li>Firebase는 데이터 베이스가 하나의 큰 Json 형식으로 구조화 되어 있습니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-faasfunction-as-a-service\"><a href=\"#2-faasfunction-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. FaaS(Function as a Service)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100354291-468c5780-3033-11eb-8d18-e6b0ba4fdf20.png\" alt=\"image\"></p>\n<ul>\n<li>코드, <strong>함수</strong>를 서비스로 제공합니다. 애플리케이션 개발에서 함수를 실행하기 위해 서버를 올리고 런타임을 구성하고 코드를 배포해서 실행해야 하는 일련의 과정을 없애고 원하는 로직을 함수로 등록만 해놓으면 특정 이벤트시 함수가 실행되고 종료됩니다.</li>\n<li>서버가 계속 대기하면서 사용자의 요청하는 것이 아니라, 이벤트가 발생했을 때만 함수가 실행되기 때문에 함수가 실행되는 시간 및 호출된 횟수만큼만 비용을 지불합니다.</li>\n<li>PaaS의 경우는 전체 애플리케이션을 배포하여 서버에서 애플리케이션이 계속 돌아가지만, FaaS는 애플리케이션을 더 작게 쪼갠 함수를 배포하며, 특정 이벤트가 발생했을 때만 실행되고 종료됩니다.</li>\n<li>주로 서비스 사이의 간단한 작업을 처리하는 용도로 쓰이며, BaaS와 결합해서 사용하기 좋습니다. 대표적인 예시로는 AWS Lambda, 구글의 Knative, Nuclio 등이 있습니다.</li>\n</ul>\n<p><strong>장점</strong></p>\n<ul>\n<li>\n<p>비용</p>\n<ul>\n<li>특정 작업을 하기위해 서버를 준비하고 켜놓는 것이 아니라면, 필요시만 호출되기 때문에 많은 비용을 절감할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>인프라 관리</p>\n<ul>\n<li>네트워크, 장비 등에 대해 신경쓸 필요가 없습니다.</li>\n</ul>\n</li>\n<li>\n<p>인프라 보안</p>\n<ul>\n<li>리눅스 업데이트, 취약점 보안 패치 등에 큰 신경을 쓰지 않다도 됩니다.</li>\n</ul>\n</li>\n<li>\n<p>확장성</p>\n<ul>\n<li>확장성에서 굉장히 유연합니다. (AutoScaling 등의 필요없습니다. 그저 호출만 될뿐...)</li>\n</ul>\n</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>\n<p>제한</p>\n<ul>\n<li>함수에서 사용할 수 있는 자원의 제한이 존재합니다.</li>\n<li>웹소켓과 같이 계속 켜놓는 것은 사용하기 힘듭니다.</li>\n</ul>\n</li>\n<li>제공사에 대한 강한 의존</li>\n<li>\n<p>로컬 데이터 사용 불가능</p>\n<ul>\n<li>함수들은 무상태이기 때문에 이 데이터를 로컬 스토리지에 쓸수없습니다. (물론, AWS는 S3, Azure는 Storage를 사용 가능합니다.)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-정리\"><a href=\"#3-%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 정리</h3>\n<p>Serverless의 특징은 다음과 같습니다.</p>\n<ul>\n<li>\n<p>Cold Start</p>\n<ul>\n<li>클라우드 업체는 자원을 효율적으로 관리하기 위해 일정 기간 행위가 없는 사용자에게는 컴퓨팅 파워를 제공하지않습니다.</li>\n<li>비활성 함수가 갑자기 호출되면 서버가 준비되는 지연 시간이 발생하여 애플리케이션 성능에 영향을 줄 수도 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>Stateless</p>\n<ul>\n<li>함수가 없는 경우에는 모든 리소스 종류가 존재하지 않습니다.</li>\n<li>세션을 보존해야하는 경우에는 DB에 저장하는 것이 좋습니다.</li>\n</ul>\n</li>\n<li>\n<p>일시적 컨테이너</p>\n<ul>\n<li>특정 이벤트가 발생하는 일정 기간 동안에만 컨테이너에 배포되고, 그 이후는 자원이 없습니다.</li>\n<li><strong>큰 요구사항이 필요한 경우에는 적합하지 않습니다.</strong></li>\n</ul>\n</li>\n<li>\n<p>언어지원</p>\n<ul>\n<li>AWS Lambda: Node.js, Python, Java, C#, Go</li>\n<li>MS Azure: C#, Javascript, F#, Python, Batch, PHP, PowerShell</li>\n<li>Google Function: Node.js, Python, Javascript</li>\n</ul>\n</li>\n<li>\n<p>NoSQL</p>\n<ul>\n<li>함수는 제한된 데이터베이스 색인(Index)을 구성하기 때문에 서버리스 아키텍처에서 관계형 데이터베이스를 사용하면 동시 연결 수 제한으로 확장성과 성능 문제가 발생합니다.</li>\n<li>따라서 RDBMS 보다는 <strong>NoSQL</strong>이 적합합니다.</li>\n</ul>\n</li>\n</ul>\n<p>그러나. 현재는 Stateless, 일시적 컨테이너에 따른 특징으로 인해 <strong>큰 프로젝트에는 적합하지 않습니다.</strong></p>\n<br/>\n<h2 id=\"그-외\"><a href=\"#%EA%B7%B8-%EC%99%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>그 외.</h2>\n<h3 id=\"1-caascontainer-as-as-service\"><a href=\"#1-caascontainer-as-as-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. CaaS(Container as as Service)</h3>\n<p>컨테이너 기반 추상화를 통해 사용자가 애플리케이션을 배포하고 관리하도록 지원하는 클라우드 서비스 컴퓨팅 모델입니다. 제공없체는 컨테이너가 배포 및 관리되는 프레임워크 또는 오케스트레이션 플랫폼을 제공합니다.</p>\n<blockquote>\n<p>오케스트레이션(orchestration)이란?</p>\n<ul>\n<li>Container orchestration이란 컨테이너의 배포, 관리, 확장 및 네트워킹을 자동화합니다.</li>\n</ul>\n</blockquote>\n<p>클라우드 서비스의 범위에서 CaaS는 IaaS의 하위집합으로 간주되며 I<strong>aaS와 서비스 플랫폼인 PaaS 사이</strong>에 존재한다고 이해하면 됩니다.</p>\n<p>컨테이너를 사용하므로 다음과 같은 특징을 가집니다.</p>\n<ul>\n<li>이식성 : private, public 등의 다양한 환경에서 배포가능</li>\n<li>확장성 : 컨테이너의 수를 늘려서 확장할 수 있습니다.</li>\n<li>효율성 : 컨테이너는 별도의 운영체제가 필요없으므로 가상 머신(VM)보다 리소스가 적게 필요합니다.</li>\n<li>보안강화 : 컨테이너는 격리되어 있으므로 다른 컨테이너에 영향을 주지 않습니다.</li>\n<li>속도 : 운영 체제에 구애받지 않기 때문에 시작과 종료시간이 짧습니다.</li>\n</ul>\n<p>이와 같은 환경에서는 <strong>쿠버네티스</strong>를 사용하는 것이 좋습니다.</p>\n<p>쿠버네티스에 대한 간단한 정리는 아래의 링크를 보시면 좋을 듯합니다.</p>\n<p>: <a href=\"https://Azderica.github.io/backend/2020/11/10/backend-kubernetes-study/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">쿠버네티스란?</a></p>\n<h3 id=\"2dbaasdatabase-as-a-service\"><a href=\"#2dbaasdatabase-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2.DBaaS(Database as a Service)</h3>\n<p>DBaaS는 <strong>클라우드 아키텍처</strong>로서 데이터베이스 서비스 프로바이더가 하나 아싱의 서비스 소비자에게 데이터베이스 서비스를 제공하는 아키텍처, 운영 전략입니다.</p>\n<p>다음과 같은 요구사항을 만족합니다.</p>\n<ul>\n<li>리소스의 빠른 제공 및 Self-Service 동작, 데이터베이스 관리</li>\n<li>데이터베이스 서비스 사용량에 기반한 Show-back 리포트와 Charge-back 기능을 제공합니다.</li>\n</ul>\n<p>이러한 특성을 바탕으로 DBaaS는 클라우드 서비스를 통해 자원의 탄력적인 운용과 확장가능, 자동화된 자원 관리, 용량 설정 및 설계의 기능을 제공합니다.</p>\n<p>이러한 기능은 다음의 장점을 가집니다.</p>\n<ul>\n<li>비용절감</li>\n<li>\n<p>서비스 수준향상</p>\n<ul>\n<li>Self-Service Provising, 관리</li>\n<li>미리 약속된 서비스 정의</li>\n<li>Metering 및 Chargeback을 통한 IT 비용 및 활용도 측정 가능</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"정리\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>정리.</h2>\n<p>간단하게 서버리스 아키텍처에 대해 정리하였습니다. 흔히 듣던, IaaS, BaaS, PaaS, FaaS에 대해 간단하게 정리해보았고, 최근에 들었던 CaaS에 대해서도 간단하게 조사했습니다.</p>\n<p>이후 부족한 내용이나 보완되어야하는 내용이 있다면 편하게 이야기주세요.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://velopert.com/3543\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velopert.com/3543</a></li>\n<li><a href=\"https://stonesteel1023.github.io/TIL181109/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://stonesteel1023.github.io/TIL181109/</a></li>\n<li><a href=\"https://m.blog.naver.com/PostView.nhn?blogId=shakey7&#x26;logNo=221739057486&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.blog.naver.com/PostView.nhn?blogId=shakey7&#x26;logNo=221739057486&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F</a></li>\n<li><a href=\"https://www.redhat.com/ko/topics/cloud-computing/what-is-caas\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/cloud-computing/what-is-caas</a></li>\n</ul>\n"}},{"node":{"title":"[Elastic Search] Elastic Search란?","path":"/00-elasticsearch/","date":"16. November 2020","timeToRead":9,"description":" 엘라스틱서치에 대한 기본 내용을 정리한 글입니다. ","content":"<h1 id=\"elasticsearch\"><a href=\"#elasticsearch\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Elasticsearch.</h1>\n<p>오늘은 Elasticsearch에 대한 기본적인 내용을 정리합니다.</p>\n<h2 id=\"elasticsearch란\"><a href=\"#elasticsearch%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Elasticsearch란?</h2>\n<p><strong>Elasticsearch는 Apache Lucene(아파치 루씬)을 기반으로 한 Java 오픈소스 분산 검색 엔진입니다.</strong></p>\n<p>Elasticsearch는 방대한 양의 데이터를 거의 실시간(NRT, Near Real Time)으로 저장, 검색, 분석할 수 있습니다. 이러한 Elasticsearch는 검색을 위해 단독으로 쓰이기도 하며, <strong>ELK</strong> 스택으로 사용되기도 합니다.</p>\n<p>먼저 Elasticsearch에 본격적으로 들어가기 앞서서, ELK란 (Elasticsearch, Logstatsh, Kibnana)을 의미합니다.</p>\n<p>간단하게 ELK 스택을 설명하면 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99964448-9e7a5280-2dd6-11eb-9bdc-1ae7cf9f2498.png\" alt=\"image\"></p>\n<ul>\n<li>\n<p>Logstash</p>\n<ul>\n<li>다양한 소스(DB, csv파일 등)의 로그나 트랜잭션 데이터를 수집, 집계, 파싱하여 Elasticsearch로 전달합니다.</li>\n</ul>\n</li>\n<li>\n<p>Elasticsearch</p>\n<ul>\n<li>Logstash로 받은 데이터를 검색 및 집계하여 필요한 관심 정보를 받습니다.</li>\n</ul>\n</li>\n<li>\n<p>Kibana</p>\n<ul>\n<li>Elasticsearch의 검색 결과를 통해 데이터를 시각화하고 모니터링합니다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"elasticsearch-용어-정의\"><a href=\"#elasticsearch-%EC%9A%A9%EC%96%B4-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Elasticsearch 용어 정의</h2>\n<h3 id=\"논리적-구조\"><a href=\"#%EB%85%BC%EB%A6%AC%EC%A0%81-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>논리적 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99964489-b05bf580-2dd6-11eb-9962-78eae078e84b.png\" alt=\"image\"></p>\n<h4 id=\"도큐먼트document\"><a href=\"#%EB%8F%84%ED%81%90%EB%A8%BC%ED%8A%B8document\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>도큐먼트(Document)</h4>\n<ul>\n<li>Elasticsearch 데이터 최소 단위(RDBMS의 Row와 비슷)하고, JSON 오브젝트 중 하나입니다.</li>\n<li>하나의 Document는 다양한 필드로 구성되어 있으며, Document 내부에 Document가 들어갈 수도 있습니다.</li>\n</ul>\n<h4 id=\"타입type\"><a href=\"#%ED%83%80%EC%9E%85type\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>타입(Type)</h4>\n<ul>\n<li>여러개의 Document가 모여서 한 개의 Type을 이룹니다.(RDBMS의 테이블과 비슷)</li>\n<li><strong>Elasticsearch 7.0부터 사라졌습니다.</strong></li>\n</ul>\n<h4 id=\"필드field\"><a href=\"#%ED%95%84%EB%93%9Cfield\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>필드(Field)</h4>\n<ul>\n<li>Document에 들어가는 데이터 타입(RDBMS의 column)와 비슷합니다.</li>\n<li>Elasticsearch의 필드는 RDBMS보다 동적입니다. 즉. 하나의 데이터 타임만 가질 수 있는 RDBMS와 달리, 하나의 필드가 여러개의 타입을 가질 수 있습니다.</li>\n</ul>\n<h4 id=\"매핑mapping\"><a href=\"#%EB%A7%A4%ED%95%91mapping\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>매핑(Mapping)</h4>\n<ul>\n<li>매핑(Mapping)은 필드와 필드의 속성을 정의합니다.</li>\n<li>매핑 정보에 여러가지 데이터 타입 지정이 가능하지만 필드명 자체는 중복이 불가능합니다.</li>\n</ul>\n<h4 id=\"인덱스index\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4index\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>인덱스(Index)</h4>\n<ul>\n<li>여러개의 Type이 모여 한 개의 Index를 이룹니다.(RDBMS의 Database와 비슷)</li>\n<li>Elasticsearch 6.1 부터는 <strong>하나의 Index</strong>는 <strong>하나의 Type</strong>만 가집니다.(Database + Table과 비슷)</li>\n<li>Elasticsearch를 클러스터(분산환경)을 구성하는 경우, Index는 여러 노드에 분산 저장 및 관리가 됩니다.</li>\n<li>기본 설정은 5개의 Primary Shard와 1개의 Replica Shard로 생성됩니다. 옵션 값으로 변경 가능합니다.</li>\n</ul>\n<h3 id=\"물리적-구조\"><a href=\"#%EB%AC%BC%EB%A6%AC%EC%A0%81-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>물리적 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99964072-15fbb200-2dd6-11eb-9485-1887247ebdb4.png\" alt=\"image\"></p>\n<h4 id=\"노드node\"><a href=\"#%EB%85%B8%EB%93%9Cnode\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>노드(Node)</h4>\n<ul>\n<li>노드는 Elasticsearch 클러스터에 포함된 <strong>단일 서버</strong>로서 데이터를 저장하고 클러스터의 색인화 및 검색 기능에 참여합니다. 노드는 클러스터처럼 이름으로 식별됩니다.</li>\n<li>\n<p>일반적으로 노드의 종류는 다음과 같습니다.</p>\n<ul>\n<li>\n<p>마스터 노드(Master node)</p>\n<ul>\n<li><strong>클러스터 관리 노드</strong></li>\n<li>노드 추가/제거, 인덱스 생성/삭제 등 클러스터의 전반적 관리를 담당합니다.</li>\n<li>여러개의 마스터 노드를 설정하면 하나의 마스터 노드로 작동됩니다.</li>\n<li><code class=\"language-text\">elasticsearch.yml</code> 에서 <code class=\"language-text\">node.master:true</code>로 설정합니다.</li>\n</ul>\n</li>\n<li>\n<p>데이터 노드(Data node)</p>\n<ul>\n<li><strong>데이터(Document)가 저장되는 노드</strong></li>\n<li>물리적인 공간인 샤드가 배치되는 노드</li>\n<li>색인/검색/통계 등 데이터 작업 수행(리소스가 소모가 심해 모니터링이 필요합니다.)</li>\n<li>마스터와는 분리할 필요가 있습니다.</li>\n<li><code class=\"language-text\">elasticsearch.yml</code>의 <code class=\"language-text\">node.data : true</code>로 설정합니다.</li>\n</ul>\n</li>\n<li>\n<p>코디네이팅 노드(Coordinating Node)</p>\n<ul>\n<li><strong>사용자의 요청을 받고 Round Robin 방식으로 분산시켜주는 노드</strong></li>\n<li>클러스터에 관련된 것은 마스터노드로, 데이터와 관련된 것은 데이터 노드로 넘깁니다.</li>\n<li><code class=\"language-text\">elasticsearch.yml</code> 내부의 노드 종류 관련 옵션을 전부 <code class=\"language-text\">false</code>로 설정합니다.</li>\n</ul>\n</li>\n<li>\n<p>인제스트 노드(Ingest node) :</p>\n<ul>\n<li><strong>문서 전처리 작업을 수행</strong></li>\n<li>인덱스 생성 전 문서의 형식을 변경할 수 있습니다.</li>\n<li><code class=\"language-text\">elasticsearch.yml</code>의 <code class=\"language-text\">node.ingest:true</code>로 설정합니다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"샤드shard\"><a href=\"#%EC%83%A4%EB%93%9Cshard\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>샤드(Shard)</h4>\n<ul>\n<li><strong>인덱스 내부에는 색인된 데이터</strong>들이 존재하며, 이 데이터들은 하나로 뭉쳐서 존재하지 않으며 물리적인 공간에 여러개의 부분들로 나눠 존재하는데 이 부분을 샤드라고 합니다.</li>\n<li>Elasticsearch는 인덱스를 여러 샤드로 나누어 저장하기 때문에, 콘텐츠 볼륨의 수평 분할/확장이 가능하고 병렬화를 통해 성능 및 처리량을 늘릴 수 있습니다.</li>\n<li>\n<p>샤드는 프라이머리와 레플리카로 구분됩니다.</p>\n<ul>\n<li>\n<p>Prmiary Shard</p>\n<ul>\n<li><strong>데이터의 원본</strong></li>\n<li>엘러스틱서치에서 데이터 업데이트 요청을 날리면 반드시 Primary Shard로 요청이 가고, 해당 내용은 Replica로 복제됩니다.</li>\n<li>검색 성능 향샹을 위해 클러스터의 샤드 갯수를 조절합니다.</li>\n</ul>\n</li>\n<li>\n<p>Replica Shard</p>\n<ul>\n<li><strong>Primary Shard의 복제품</strong></li>\n<li>기존 원본 데이터가 무너졌을 때, 그 대신 쓰면서 장애 극복 역할은 수행</li>\n<li>기본적으로 Primary Shard와 동일한 노드에 배정되지 않습니다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"세그먼트segment\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8segment\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>세그먼트(Segment)</h4>\n<ul>\n<li><strong>세그먼트는 Elasticsearch에서 문서의 빠른 검색을 위해 설계된 자료구조</strong></li>\n<li>각 샤드는 다수의 세그먼트로 구성되어 있습니다.</li>\n<li>Elasticsearch에서 데이터(Document)를 저장하면, 엘라스틱서치는 이것을 메모리에 모아두고 새로운 세그먼트를 디스크에 기록하여 검색을 refresh합니다. 이를 통해 새로운 검색 가능한 세그먼트가 만들어집니다.</li>\n<li>샤드에서 검색 시, 각 세그먼트에서 검색하여 결과를 조합한 후 최종 결과를 해당 샤드의 결과로 리턴합니다.</li>\n<li>세그먼트는 불변의 성질을 가지고 있어서 데이터가 업데이트되면, 삭제되었다는 마크만 하고 새로운 데이터를 가르킵니다. 삭제되었다고 마크된 데이터는 디스크에 남아있다가, 이후에 성능에 영향을 미치지 않는 선에서 삭제됩니다.</li>\n</ul>\n<br/>\n<h2 id=\"elasticsearch의-특징\"><a href=\"#elasticsearch%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Elasticsearch의 특징</h2>\n<h3 id=\"분산-확장성-병렬처리\"><a href=\"#%EB%B6%84%EC%82%B0-%ED%99%95%EC%9E%A5%EC%84%B1-%EB%B3%91%EB%A0%AC%EC%B2%98%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>분산, 확장성, 병렬처리</h3>\n<ul>\n<li>Elasticsearch는 규모가 수평적으로 늘어나도록 설계하기 때문에, 더 많은 용량이 필요하면 그저 노드를 추가해서 클러스터가 인식할 수 있게 하여 추가적인 하드웨어로 이용할 수 있도록 하면 됩니다.</li>\n<li>따라서 확장성 등에서 큰 이점을 가집니다. (같은 클러스터 내이고 초기설정이 그대로라면 노드끼리 연결되지만, 다른 클러스터에 있다면 설정을 해줘야합니다.)</li>\n</ul>\n<h3 id=\"고가용성\"><a href=\"#%EA%B3%A0%EA%B0%80%EC%9A%A9%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>고가용성</h3>\n<ul>\n<li>동작중에 죽은 노드를 감지하고 삭제하며 사용자의 데이터가 안전하고 접근가능하도록 유지합니다.</li>\n<li>동작 중에 일부 노드에 문제가 생기더라도 문제없이 서비스를 제공합니다.</li>\n</ul>\n<h3 id=\"멀티-태넌시\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%83%9C%EB%84%8C%EC%8B%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>멀티 태넌시</h3>\n<ul>\n<li>클러스터는 여러개의 인덱스를 관리할 수 있습니다.</li>\n<li>클러스터는 독립된 하나의 쿼리 또는 그룹 쿼리로 여러 인덱스의 데이터를 검색할 수 있습니다.</li>\n</ul>\n<h3 id=\"전문full-text-검색\"><a href=\"#%EC%A0%84%EB%AC%B8full-text-%EA%B2%80%EC%83%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>전문(Full text) 검색</h3>\n<ul>\n<li>Elasticsearch는 강력한 전문 검색을 지원합니다.</li>\n</ul>\n<h3 id=\"문서-중심\"><a href=\"#%EB%AC%B8%EC%84%9C-%EC%A4%91%EC%8B%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>문서 중심</h3>\n<ul>\n<li>Elasticsearch는 복잡한 요소들을 구조화된 JSON 문서 형식으로 지원합니다.</li>\n<li>모든 필드는 기본적으로 인덱싱되며, 모든 인덱스들은 단일 쿼리로 빠르게 사용할 수 있습니다.</li>\n</ul>\n<h3 id=\"schema-free\"><a href=\"#schema-free\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Schema free</h3>\n<ul>\n<li>JSON 문서 구조를 통해서 데이터를 인덱싱하고 검색할 수 있습니다.</li>\n<li>사용자의 데이터가 어떻게 인덱싱 될 것인지를 커스터마이징할 수 있습니다.</li>\n</ul>\n<h3 id=\"restful-api\"><a href=\"#restful-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Restful api</h3>\n<ul>\n<li>\n<p>HTTP를 통한 JSON형식의 간단한 RESTful API를 제공하여 여러 다른 API도 제공합니다.</p>\n<ul>\n<li>ex) Java, JS, Groovy, PHP, Perl, Python, Ruby 등등</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간단하게 내용적으로 Elasticsearch에 대해 정리했습니다. 다음에는 Elasticsearch를 직접 구현해보고, 또한 Kibana와 Logstatsh 등 ELK 스택에 대한 내용을 보충하여 정리하였습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://twofootdog.tistory.com/53\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://twofootdog.tistory.com/53</a></li>\n<li><a href=\"https://www.elastic.co/kr/what-is/elasticsearch\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.elastic.co/kr/what-is/elasticsearch</a></li>\n<li><a href=\"https://victorydntmd.tistory.com/308\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://victorydntmd.tistory.com/308</a></li>\n<li><a href=\"https://blog.naver.com/archinitus/80205377502\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://blog.naver.com/archinitus/80205377502</a></li>\n<li><a href=\"https://velog.io/@lsmin0703/ElasticSearch-1-%EA%B0%9C%EB%85%90\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@lsmin0703/ElasticSearch-1-%EA%B0%9C%EB%85%90</a></li>\n<li><a href=\"https://victorydntmd.tistory.com/308\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://victorydntmd.tistory.com/308</a></li>\n</ul>\n"}}]}}},"context":{}}