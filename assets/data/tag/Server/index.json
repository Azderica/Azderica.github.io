{"hash":"78233c70288de5cc80ede0d03ef7918cb4b6eee5","data":{"tag":{"title":"Server","belongsTo":{"edges":[{"node":{"title":"[Architeture] 서버리스 아키텍처에 대한 기초 지식","path":"/00-architecture-serverless/","date":"25. November 2020","timeToRead":13,"description":" 서버리스와 서버 아키텍처에 대한 기본 내용을 정리한 글입니다. ","content":"<h1 id=\"서버리스-아키텍처에-대하여\"><a href=\"#%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서버리스 아키텍처에 대하여</h1>\n<p>회사에서 개발과 관련해서 이야기를 하는데, CaaS, FaaS, BaaS 등에 대한 이야기를 듣게 되었다. 생각해보니 이름만 들어보고 한 번도 제대로 알아본적이 없어서 이번기회에 정리합니다.</p>\n<p>서버리스(Serverless)란 말 그대로 서버가 없다는 의미는 아닙니다. 다만, 특정 작업을 수행하기 위해서 컴퓨터 혹은 가상머신에 서버를 설정할 필요없이 다른 서비스(BaaS, FaaS) 등에 의존해서 작업을 처리합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100229273-5474a680-2f67-11eb-8a3a-467c9f409a72.png\" alt=\"image\"></p>\n<blockquote>\n<p>들어가기에 앞서서 간단한 발전 과정은 다음과 같습니다.</p>\n</blockquote>\n<p><br/>></p>\n<h2 id=\"기존-애플리케이션\"><a href=\"#%EA%B8%B0%EC%A1%B4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>기존 애플리케이션</h2>\n<h3 id=\"1-자체-설계\"><a href=\"#1-%EC%9E%90%EC%B2%B4-%EC%84%A4%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 자체 설계</h3>\n<p>시스템에서 필요한 모든 인프라를 직접 관리합니다. 기존의 <strong>전산실</strong>로 이해하면 됩니다.</p>\n<ul>\n<li>필요한 모든 인프라를 직접 관리. 예를 들어 기업 전산실에서 서버 및 하드웨어, 네트워크, 운영체제 등을 갖추어 모두 직접 처리해야합니다.</li>\n<li>시스템이 커질 수록 유지할 관리자가 필요하고, 이에 따른 비용이 발생합니다.</li>\n</ul>\n<h3 id=\"2-iaasinfrastructure-as-a-service\"><a href=\"#2-iaasinfrastructure-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. IaaS(Infrastructure as a Service)</h3>\n<p>AWS, Azure 등의 서비스에서 제공하는 서비스입니다. 서버자원, 네트워크, 전력 등의 인프라를 직접 구축할 필요없이 이러한 <strong>인프라를 가상화</strong>하여 관리하기 쉽게 해주는 서비스를 제공합니다.</p>\n<p>사용자는 해당 서비스를 통해서 관리자패널에서 인프라를 구성하면 됩니다. 사용자는 가상머신을 만들고 네트워크를 설정하고, 하드웨어를 설정하고, 운영체제를 설치해서 애플리케이션을 구동합니다.</p>\n<h3 id=\"3-paasplatform-as-a-service\"><a href=\"#3-paasplatform-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. PaaS(Platform as a Service)</h3>\n<p>IaaS에서 좀 더 추상화된 모델입니다. 네트워크, OS, 런타임을 제공합니다. 사용자는 애플리케이션만 배포하면 바로 구동할 수 있습니다. 또한 Auto Scaling 및 Load Balacing도 손쉽게 적용가능합니다.</p>\n<p>예시로는 다음과 같습니다.</p>\n<ul>\n<li>AWS Elastic Beanstalk, Azure App Servies 등등</li>\n</ul>\n<br/>\n<h2 id=\"servless\"><a href=\"#servless\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Servless</h2>\n<ul>\n<li>서버리스는 애플리케이션 개발자가 서버를 프로비저닝하거나 애플리케이션의 확장을 관리할 필요가 없습니다.</li>\n</ul>\n<blockquote>\n<p>프로비저닝(Provisioning) : 사용자의 요구에 맞게 시스템을 할당하고 배치, 배포한 이후 필요시에 시스템을 즉시 사용할 수 있는 상태로 미리 준비해놓는 것입니다.</p>\n</blockquote>\n<ul>\n<li>서버가 없다는 뜻은 아니며, 작업을 처리하는 서버는 있지만 서버를 관리할 필요가 없습니다.</li>\n<li>대표적으로 <strong>BaaS</strong> 와 <strong>FaaS</strong>로 나눠집니다.</li>\n</ul>\n<h3 id=\"1-baasbackend-as-a-service\"><a href=\"#1-baasbackend-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. BaaS(Backend as a Service)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100353200-82beb880-3031-11eb-89d9-5a361d5f88c4.png\" alt=\"image\"></p>\n<ul>\n<li>애플리케이션에서 일반 사용자가 보는 영역은 프론트엔드, 관리자가 보는 영역은 백엔드로 불립니다. <strong>이때 BaaS는 백엔드인 관리자 영역을 모듈화하여 서비스</strong>로 제공합니다.</li>\n<li>백엔드 개발(데이터 저장, 다른 기기로 접근, 파일 공유 등)이 필요한 경우, 개발자가 이러한 모든 서비스를 구축하기 어려워서, BaaS를 통해서 개발 시간을 단축합니다.</li>\n<li>IaaS, PaaS가 서버 인프라를 대체하는 정도였다면, <strong>BaaS와 FaaS는 서버 운영까지 맡기는 서비스</strong>입니다.</li>\n<li>대표적인 서비스로는 <strong>Firebase</strong>가 있습니다.</li>\n</ul>\n<p><strong>장점</strong></p>\n<ul>\n<li>개발 시간의 단축</li>\n<li>서버 확장의 불필요함</li>\n<li>백엔드에 대한 지식이 부족하더라도 빠른 속도로 개발이 가능</li>\n<li>토이 프로젝트, 소규모 프로젝트에서는 백엔드로 유용하게 사용가능</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>\n<p>클라이언트 위주의 코드</p>\n<ul>\n<li>백엔드 로직이 클라이언트 쪽에 구현됨 (보안 등의 큰 이슈)</li>\n<li>Firebase SDK를 통해 서버쪽에서 개발할 수 있지만, 이보다는 직접 구현이 좋습니다.</li>\n<li>데이터단의 로직이 변경되면 클라이언트 코드 수정이 이루어집니다.</li>\n</ul>\n</li>\n<li>\n<p>가격</p>\n<ul>\n<li>Firebase의 경우 초반에는 무료이지만, 앱의 규모가 커지면 비싸집니다.</li>\n<li>서비스 규모가 늘어날 수록 직접 구현의 장점이 가능합니다.</li>\n</ul>\n</li>\n<li>\n<p>복잡한 쿼리가 불가능함</p>\n<ul>\n<li>Firebase는 데이터 베이스가 하나의 큰 Json 형식으로 구조화 되어 있습니다. </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-faasfunction-as-a-service\"><a href=\"#2-faasfunction-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. FaaS(Function as a Service)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/100354291-468c5780-3033-11eb-8d18-e6b0ba4fdf20.png\" alt=\"image\"></p>\n<ul>\n<li>코드, <strong>함수</strong>를 서비스로 제공합니다. 애플리케이션 개발에서 함수를 실행하기 위해 서버를 올리고 런타임을  구성하고 코드를 배포해서 실행해야 하는 일련의 과정을 없애고 원하는 로직을 함수로 등록만 해놓으면 특정 이벤트시 함수가 실행되고 종료됩니다.</li>\n<li>서버가 계속 대기하면서 사용자의 요청하는 것이 아니라, 이벤트가 발생했을 때만 함수가 실행되기 때문에 함수가 실행되는 시간 및 호출된 횟수만큼만 비용을 지불합니다.</li>\n<li>PaaS의 경우는 전체 애플리케이션을 배포하여 서버에서 애플리케이션이 계속 돌아가지만, FaaS는 애플리케이션을 더 작게 쪼갠 함수를 배포하며, 특정 이벤트가 발생했을 때만 실행되고 종료됩니다.</li>\n<li>주로 서비스 사이의 간단한 작업을 처리하는 용도로 쓰이며, BaaS와 결합해서 사용하기 좋습니다. 대표적인 예시로는 AWS Lambda, 구글의 Knative, Nuclio 등이 있습니다.</li>\n</ul>\n<p><strong>장점</strong></p>\n<ul>\n<li>\n<p>비용</p>\n<ul>\n<li>특정 작업을 하기위해 서버를 준비하고 켜놓는 것이 아니라면, 필요시만 호출되기 때문에 많은 비용을 절감할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>인프라 관리</p>\n<ul>\n<li>네트워크, 장비 등에 대해 신경쓸 필요가 없습니다.</li>\n</ul>\n</li>\n<li>\n<p>인프라 보안</p>\n<ul>\n<li>리눅스 업데이트, 취약점 보안 패치 등에 큰 신경을 쓰지 않다도 됩니다.</li>\n</ul>\n</li>\n<li>\n<p>확장성</p>\n<ul>\n<li>확장성에서 굉장히 유연합니다. (AutoScaling 등의 필요없습니다. 그저 호출만 될뿐...)</li>\n</ul>\n</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>\n<p>제한</p>\n<ul>\n<li>함수에서 사용할 수 있는 자원의 제한이 존재합니다.</li>\n<li>웹소켓과 같이 계속 켜놓는 것은 사용하기 힘듭니다.</li>\n</ul>\n</li>\n<li>제공사에 대한 강한 의존</li>\n<li>\n<p>로컬 데이터 사용 불가능</p>\n<ul>\n<li>함수들은 무상태이기 때문에 이 데이터를 로컬 스토리지에 쓸수없습니다. (물론, AWS는 S3, Azure는 Storage를 사용 가능합니다.)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-정리\"><a href=\"#3-%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 정리</h3>\n<p>Serverless의 특징은 다음과 같습니다.</p>\n<ul>\n<li>\n<p>Cold Start</p>\n<ul>\n<li>클라우드 업체는 자원을 효율적으로 관리하기 위해 일정 기간 행위가 없는 사용자에게는 컴퓨팅 파워를 제공하지않습니다.</li>\n<li>비활성 함수가 갑자기 호출되면 서버가 준비되는 지연 시간이 발생하여 애플리케이션 성능에 영향을 줄 수도 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>Stateless</p>\n<ul>\n<li>함수가 없는 경우에는 모든 리소스 종류가 존재하지 않습니다.</li>\n<li>세션을 보존해야하는 경우에는 DB에 저장하는 것이 좋습니다.</li>\n</ul>\n</li>\n<li>\n<p>일시적 컨테이너</p>\n<ul>\n<li>특정 이벤트가 발생하는 일정 기간 동안에만 컨테이너에 배포되고, 그 이후는 자원이 없습니다.</li>\n<li><strong>큰 요구사항이 필요한 경우에는 적합하지 않습니다.</strong></li>\n</ul>\n</li>\n<li>\n<p>언어지원</p>\n<ul>\n<li>AWS Lambda: Node.js, Python, Java, C#, Go</li>\n<li>MS Azure: C#, Javascript, F#, Python, Batch, PHP, PowerShell</li>\n<li>Google Function: Node.js, Python, Javascript</li>\n</ul>\n</li>\n<li>\n<p>NoSQL</p>\n<ul>\n<li>함수는 제한된 데이터베이스 색인(Index)을 구성하기 때문에 서버리스 아키텍처에서 관계형 데이터베이스를 사용하면 동시 연결 수 제한으로 확장성과 성능 문제가 발생합니다.</li>\n<li>따라서 RDBMS 보다는 <strong>NoSQL</strong>이 적합합니다.</li>\n</ul>\n</li>\n</ul>\n<p>그러나. 현재는 Stateless, 일시적 컨테이너에 따른 특징으로 인해 <strong>큰 프로젝트에는 적합하지 않습니다.</strong></p>\n<br/>\n<h2 id=\"그-외\"><a href=\"#%EA%B7%B8-%EC%99%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>그 외.</h2>\n<h3 id=\"1-caascontainer-as-as-service\"><a href=\"#1-caascontainer-as-as-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. CaaS(Container as as Service)</h3>\n<p>컨테이너 기반 추상화를 통해 사용자가 애플리케이션을 배포하고 관리하도록 지원하는 클라우드 서비스 컴퓨팅 모델입니다. 제공없체는 컨테이너가 배포 및 관리되는 프레임워크 또는 오케스트레이션 플랫폼을 제공합니다.</p>\n<blockquote>\n<p>오케스트레이션(orchestration)이란?</p>\n<ul>\n<li>Container orchestration이란 컨테이너의 배포, 관리, 확장 및 네트워킹을 자동화합니다.</li>\n</ul>\n</blockquote>\n<p>클라우드 서비스의 범위에서 CaaS는 IaaS의 하위집합으로 간주되며 I<strong>aaS와 서비스 플랫폼인 PaaS 사이</strong>에 존재한다고 이해하면 됩니다.</p>\n<p>컨테이너를 사용하므로 다음과 같은 특징을 가집니다.</p>\n<ul>\n<li>이식성 : private, public 등의 다양한 환경에서 배포가능</li>\n<li>확장성 : 컨테이너의 수를 늘려서 확장할 수 있습니다.</li>\n<li>효율성 : 컨테이너는 별도의 운영체제가 필요없으므로 가상 머신(VM)보다 리소스가 적게 필요합니다.</li>\n<li>보안강화 : 컨테이너는 격리되어 있으므로 다른 컨테이너에 영향을 주지 않습니다.</li>\n<li>속도 : 운영 체제에 구애받지 않기 때문에 시작과 종료시간이 짧습니다.</li>\n</ul>\n<p>이와 같은 환경에서는 <strong>쿠버네티스</strong>를 사용하는 것이 좋습니다.</p>\n<p>쿠버네티스에 대한 간단한 정리는 아래의 링크를 보시면 좋을 듯합니다.</p>\n<p>: <a href=\"https://azderica.github.io/backend/2020/11/10/backend-kubernetes-study/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">쿠버네티스란?</a></p>\n<h3 id=\"2dbaasdatabase-as-a-service\"><a href=\"#2dbaasdatabase-as-a-service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2.DBaaS(Database as a Service)</h3>\n<p>DBaaS는 <strong>클라우드 아키텍처</strong>로서 데이터베이스 서비스 프로바이더가 하나 아싱의 서비스 소비자에게 데이터베이스 서비스를 제공하는 아키텍처, 운영 전략입니다.</p>\n<p>다음과 같은 요구사항을 만족합니다.</p>\n<ul>\n<li>리소스의 빠른 제공 및 Self-Service 동작, 데이터베이스 관리</li>\n<li>데이터베이스 서비스 사용량에 기반한 Show-back 리포트와 Charge-back 기능을 제공합니다.</li>\n</ul>\n<p>이러한 특성을 바탕으로 DBaaS는 클라우드 서비스를 통해 자원의 탄력적인 운용과 확장가능, 자동화된 자원 관리, 용량 설정 및 설계의 기능을 제공합니다.</p>\n<p>이러한 기능은 다음의 장점을 가집니다.</p>\n<ul>\n<li>비용절감</li>\n<li>\n<p>서비스 수준향상</p>\n<ul>\n<li>Self-Service Provising, 관리</li>\n<li>미리 약속된 서비스 정의</li>\n<li>Metering 및 Chargeback을 통한 IT 비용 및 활용도 측정 가능</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"정리\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>정리.</h2>\n<p>간단하게 서버리스 아키텍처에 대해 정리하였습니다. 흔히 듣던, IaaS, BaaS, PaaS, FaaS에 대해 간단하게 정리해보았고, 최근에 들었던 CaaS에 대해서도 간단하게 조사했습니다.</p>\n<p>이후 부족한 내용이나 보완되어야하는 내용이 있다면 편하게 이야기주세요.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://velopert.com/3543\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velopert.com/3543</a></li>\n<li><a href=\"https://stonesteel1023.github.io/TIL181109/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://stonesteel1023.github.io/TIL181109/</a></li>\n<li><a href=\"https://m.blog.naver.com/PostView.nhn?blogId=shakey7&#x26;logNo=221739057486&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.blog.naver.com/PostView.nhn?blogId=shakey7&#x26;logNo=221739057486&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F</a></li>\n<li><a href=\"https://www.redhat.com/ko/topics/cloud-computing/what-is-caas\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/cloud-computing/what-is-caas</a></li>\n</ul>\n"}},{"node":{"title":"[Elastic Search] Elastic Search란?","path":"/00-elasticsearch/","date":"16. November 2020","timeToRead":9,"description":" 엘라스틱서치에 대한 기본 내용을 정리한 글입니다. ","content":"<h1 id=\"elasticsearch\"><a href=\"#elasticsearch\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Elasticsearch.</h1>\n<p>오늘은 Elasticsearch에 대한 기본적인 내용을 정리합니다.</p>\n<h2 id=\"elasticsearch란\"><a href=\"#elasticsearch%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Elasticsearch란?</h2>\n<p><strong>Elasticsearch는 Apache Lucene(아파치 루씬)을 기반으로 한 Java 오픈소스 분산 검색 엔진입니다.</strong></p>\n<p>Elasticsearch는 방대한 양의 데이터를 거의 실시간(NRT, Near Real Time)으로 저장, 검색, 분석할 수 있습니다. 이러한 Elasticsearch는 검색을 위해 단독으로 쓰이기도 하며, <strong>ELK</strong> 스택으로 사용되기도 합니다.</p>\n<p>먼저 Elasticsearch에 본격적으로 들어가기 앞서서, ELK란 (Elasticsearch, Logstatsh, Kibnana)을 의미합니다.</p>\n<p>간단하게 ELK 스택을 설명하면 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99964448-9e7a5280-2dd6-11eb-9bdc-1ae7cf9f2498.png\" alt=\"image\"></p>\n<ul>\n<li>\n<p>Logstash</p>\n<ul>\n<li>다양한 소스(DB, csv파일 등)의 로그나 트랜잭션 데이터를 수집, 집계, 파싱하여 Elasticsearch로 전달합니다.</li>\n</ul>\n</li>\n<li>\n<p>Elasticsearch</p>\n<ul>\n<li>Logstash로 받은 데이터를 검색 및 집계하여 필요한 관심 정보를 받습니다.</li>\n</ul>\n</li>\n<li>\n<p>Kibana</p>\n<ul>\n<li>Elasticsearch의 검색 결과를 통해 데이터를 시각화하고 모니터링합니다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"elasticsearch-용어-정의\"><a href=\"#elasticsearch-%EC%9A%A9%EC%96%B4-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Elasticsearch 용어 정의</h2>\n<h3 id=\"논리적-구조\"><a href=\"#%EB%85%BC%EB%A6%AC%EC%A0%81-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>논리적 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99964489-b05bf580-2dd6-11eb-9962-78eae078e84b.png\" alt=\"image\"></p>\n<h4 id=\"도큐먼트document\"><a href=\"#%EB%8F%84%ED%81%90%EB%A8%BC%ED%8A%B8document\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>도큐먼트(Document)</h4>\n<ul>\n<li>Elasticsearch 데이터 최소 단위(RDBMS의 Row와 비슷)하고, JSON 오브젝트 중 하나입니다.</li>\n<li>하나의 Document는 다양한 필드로 구성되어 있으며, Document 내부에 Document가 들어갈 수도 있습니다.</li>\n</ul>\n<h4 id=\"타입type\"><a href=\"#%ED%83%80%EC%9E%85type\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>타입(Type)</h4>\n<ul>\n<li>여러개의 Document가 모여서 한 개의 Type을 이룹니다.(RDBMS의 테이블과 비슷)</li>\n<li><strong>Elasticsearch 7.0부터 사라졌습니다.</strong></li>\n</ul>\n<h4 id=\"필드field\"><a href=\"#%ED%95%84%EB%93%9Cfield\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>필드(Field)</h4>\n<ul>\n<li>Document에 들어가는 데이터 타입(RDBMS의 column)와 비슷합니다. </li>\n<li>Elasticsearch의 필드는 RDBMS보다 동적입니다. 즉. 하나의 데이터 타임만 가질 수 있는 RDBMS와 달리, 하나의 필드가 여러개의 타입을 가질 수 있습니다.  </li>\n</ul>\n<h4 id=\"매핑mapping\"><a href=\"#%EB%A7%A4%ED%95%91mapping\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>매핑(Mapping)</h4>\n<ul>\n<li>매핑(Mapping)은 필드와 필드의 속성을 정의합니다.</li>\n<li>매핑 정보에 여러가지 데이터 타입 지정이 가능하지만 필드명 자체는 중복이 불가능합니다.</li>\n</ul>\n<h4 id=\"인덱스index\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4index\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>인덱스(Index)</h4>\n<ul>\n<li>여러개의 Type이 모여 한 개의 Index를 이룹니다.(RDBMS의 Database와 비슷)</li>\n<li>Elasticsearch 6.1 부터는 <strong>하나의 Index</strong>는 <strong>하나의 Type</strong>만 가집니다.(Database + Table과 비슷)</li>\n<li>Elasticsearch를 클러스터(분산환경)을 구성하는 경우, Index는 여러 노드에 분산 저장 및 관리가 됩니다.</li>\n<li>기본 설정은 5개의 Primary Shard와 1개의 Replica Shard로 생성됩니다. 옵션 값으로 변경 가능합니다.</li>\n</ul>\n<h3 id=\"물리적-구조\"><a href=\"#%EB%AC%BC%EB%A6%AC%EC%A0%81-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>물리적 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99964072-15fbb200-2dd6-11eb-9485-1887247ebdb4.png\" alt=\"image\"></p>\n<h4 id=\"노드node\"><a href=\"#%EB%85%B8%EB%93%9Cnode\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>노드(Node)</h4>\n<ul>\n<li>노드는 Elasticsearch 클러스터에 포함된 <strong>단일 서버</strong>로서 데이터를 저장하고 클러스터의 색인화 및 검색 기능에 참여합니다. 노드는 클러스터처럼 이름으로 식별됩니다.</li>\n<li>\n<p>일반적으로 노드의 종류는 다음과 같습니다.</p>\n<ul>\n<li>\n<p>마스터 노드(Master node)</p>\n<ul>\n<li><strong>클러스터 관리 노드</strong></li>\n<li>노드 추가/제거, 인덱스 생성/삭제 등 클러스터의 전반적 관리를 담당합니다.</li>\n<li>여러개의 마스터 노드를 설정하면 하나의 마스터 노드로 작동됩니다.</li>\n<li><code class=\"language-text\">elasticsearch.yml</code> 에서 <code class=\"language-text\">node.master:true</code>로 설정합니다.</li>\n</ul>\n</li>\n<li>\n<p>데이터 노드(Data node)</p>\n<ul>\n<li><strong>데이터(Document)가 저장되는 노드</strong></li>\n<li>물리적인 공간인 샤드가 배치되는 노드</li>\n<li>색인/검색/통계 등 데이터 작업 수행(리소스가 소모가 심해 모니터링이 필요합니다.)</li>\n<li>마스터와는 분리할 필요가 있습니다.</li>\n<li><code class=\"language-text\">elasticsearch.yml</code>의 <code class=\"language-text\">node.data : true</code>로 설정합니다.</li>\n</ul>\n</li>\n<li>\n<p>코디네이팅 노드(Coordinating Node)</p>\n<ul>\n<li><strong>사용자의 요청을 받고 Round Robin 방식으로 분산시켜주는 노드</strong></li>\n<li>클러스터에 관련된 것은 마스터노드로, 데이터와 관련된 것은 데이터 노드로 넘깁니다.</li>\n<li><code class=\"language-text\">elasticsearch.yml</code> 내부의 노드 종류 관련 옵션을 전부 <code class=\"language-text\">false</code>로 설정합니다.</li>\n</ul>\n</li>\n<li>\n<p>인제스트 노드(Ingest node) : </p>\n<ul>\n<li><strong>문서 전처리 작업을 수행</strong></li>\n<li>인덱스 생성 전 문서의 형식을 변경할 수 있습니다.</li>\n<li><code class=\"language-text\">elasticsearch.yml</code>의 <code class=\"language-text\">node.ingest:true</code>로 설정합니다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"샤드shard\"><a href=\"#%EC%83%A4%EB%93%9Cshard\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>샤드(Shard)</h4>\n<ul>\n<li><strong>인덱스 내부에는 색인된 데이터</strong>들이 존재하며, 이 데이터들은 하나로 뭉쳐서 존재하지 않으며 물리적인 공간에 여러개의 부분들로 나눠 존재하는데 이 부분을 샤드라고 합니다.</li>\n<li>Elasticsearch는 인덱스를 여러 샤드로 나누어 저장하기 때문에, 콘텐츠 볼륨의 수평 분할/확장이 가능하고 병렬화를 통해 성능 및 처리량을 늘릴 수 있습니다.</li>\n<li>\n<p>샤드는 프라이머리와 레플리카로 구분됩니다.</p>\n<ul>\n<li>\n<p>Prmiary Shard</p>\n<ul>\n<li><strong>데이터의 원본</strong></li>\n<li>엘러스틱서치에서 데이터 업데이트 요청을 날리면 반드시 Primary Shard로 요청이 가고, 해당 내용은 Replica로 복제됩니다.</li>\n<li>검색 성능 향샹을 위해 클러스터의 샤드 갯수를 조절합니다.</li>\n</ul>\n</li>\n<li>\n<p>Replica Shard</p>\n<ul>\n<li><strong>Primary Shard의 복제품</strong></li>\n<li>기존 원본 데이터가 무너졌을 때, 그 대신 쓰면서 장애 극복 역할은 수행</li>\n<li>기본적으로 Primary Shard와 동일한 노드에 배정되지 않습니다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"세그먼트segment\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8segment\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>세그먼트(Segment)</h4>\n<ul>\n<li><strong>세그먼트는 Elasticsearch에서 문서의 빠른 검색을 위해 설계된 자료구조</strong></li>\n<li>각 샤드는 다수의 세그먼트로 구성되어 있습니다.</li>\n<li>Elasticsearch에서 데이터(Document)를 저장하면, 엘라스틱서치는 이것을 메모리에 모아두고 새로운 세그먼트를 디스크에 기록하여 검색을 refresh합니다. 이를 통해 새로운 검색 가능한 세그먼트가 만들어집니다.</li>\n<li>샤드에서 검색 시, 각 세그먼트에서 검색하여 결과를 조합한 후 최종 결과를 해당 샤드의 결과로 리턴합니다.</li>\n<li>세그먼트는 불변의 성질을 가지고 있어서 데이터가 업데이트되면, 삭제되었다는 마크만 하고 새로운 데이터를 가르킵니다. 삭제되었다고 마크된 데이터는 디스크에 남아있다가, 이후에 성능에 영향을 미치지 않는 선에서 삭제됩니다.</li>\n</ul>\n<br/>\n<h2 id=\"elasticsearch의-특징\"><a href=\"#elasticsearch%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Elasticsearch의 특징</h2>\n<h3 id=\"분산-확장성-병렬처리\"><a href=\"#%EB%B6%84%EC%82%B0-%ED%99%95%EC%9E%A5%EC%84%B1-%EB%B3%91%EB%A0%AC%EC%B2%98%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>분산, 확장성, 병렬처리</h3>\n<ul>\n<li>Elasticsearch는 규모가 수평적으로 늘어나도록 설계하기 때문에, 더 많은 용량이 필요하면 그저 노드를 추가해서 클러스터가 인식할 수 있게 하여 추가적인 하드웨어로 이용할 수 있도록 하면 됩니다.</li>\n<li>따라서 확장성 등에서 큰 이점을 가집니다. (같은 클러스터 내이고 초기설정이 그대로라면 노드끼리 연결되지만, 다른 클러스터에 있다면 설정을 해줘야합니다.)</li>\n</ul>\n<h3 id=\"고가용성\"><a href=\"#%EA%B3%A0%EA%B0%80%EC%9A%A9%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>고가용성</h3>\n<ul>\n<li>동작중에 죽은 노드를 감지하고 삭제하며 사용자의 데이터가 안전하고 접근가능하도록 유지합니다.</li>\n<li>동작 중에 일부 노드에 문제가 생기더라도 문제없이 서비스를 제공합니다.</li>\n</ul>\n<h3 id=\"멀티-태넌시\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%83%9C%EB%84%8C%EC%8B%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>멀티 태넌시</h3>\n<ul>\n<li>클러스터는 여러개의 인덱스를 관리할 수 있습니다.</li>\n<li>클러스터는 독립된 하나의 쿼리 또는 그룹 쿼리로 여러 인덱스의 데이터를 검색할 수 있습니다.</li>\n</ul>\n<h3 id=\"전문full-text-검색\"><a href=\"#%EC%A0%84%EB%AC%B8full-text-%EA%B2%80%EC%83%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>전문(Full text) 검색</h3>\n<ul>\n<li>Elasticsearch는 강력한 전문 검색을 지원합니다.</li>\n</ul>\n<h3 id=\"문서-중심\"><a href=\"#%EB%AC%B8%EC%84%9C-%EC%A4%91%EC%8B%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>문서 중심</h3>\n<ul>\n<li>Elasticsearch는 복잡한 요소들을 구조화된 JSON 문서 형식으로 지원합니다.</li>\n<li>모든 필드는 기본적으로 인덱싱되며, 모든 인덱스들은 단일 쿼리로 빠르게 사용할 수 있습니다.</li>\n</ul>\n<h3 id=\"schema-free\"><a href=\"#schema-free\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Schema free</h3>\n<ul>\n<li>JSON 문서 구조를 통해서 데이터를 인덱싱하고 검색할 수 있습니다.</li>\n<li>사용자의 데이터가 어떻게 인덱싱 될 것인지를 커스터마이징할 수 있습니다.</li>\n</ul>\n<h3 id=\"restful-api\"><a href=\"#restful-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Restful api</h3>\n<ul>\n<li>\n<p>HTTP를 통한 JSON형식의 간단한 RESTful API를 제공하여 여러 다른 API도 제공합니다.</p>\n<ul>\n<li>ex) Java, JS, Groovy, PHP, Perl, Python, Ruby 등등</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간단하게 내용적으로 Elasticsearch에 대해 정리했습니다. 다음에는 Elasticsearch를 직접 구현해보고, 또한 Kibana와 Logstatsh 등 ELK 스택에 대한 내용을 보충하여 정리하였습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://twofootdog.tistory.com/53\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://twofootdog.tistory.com/53</a></li>\n<li><a href=\"https://www.elastic.co/kr/what-is/elasticsearch\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.elastic.co/kr/what-is/elasticsearch</a></li>\n<li><a href=\"https://victorydntmd.tistory.com/308\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://victorydntmd.tistory.com/308</a></li>\n<li><a href=\"https://blog.naver.com/archinitus/80205377502\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://blog.naver.com/archinitus/80205377502</a></li>\n<li><a href=\"https://velog.io/@lsmin0703/ElasticSearch-1-%EA%B0%9C%EB%85%90\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@lsmin0703/ElasticSearch-1-%EA%B0%9C%EB%85%90</a></li>\n<li><a href=\"https://victorydntmd.tistory.com/308\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://victorydntmd.tistory.com/308</a></li>\n</ul>\n"}}]}}},"context":{}}