{"hash":"c252e7650a6691103be74bcadb51dd243a8d98c2","data":{"tag":{"title":"Network","belongsTo":{"edges":[{"node":{"title":"[Network] gRPC란?","path":"/00-network-g-rpc/","date":"15. September 2021","timeToRead":6,"description":"gRPC의 개념과 HTTP API의 차이점에 대해 작성합니다.","content":"<h1 id=\"grpc\"><a href=\"#grpc\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC</h1>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133439409-25e1eb69-4d77-4428-abeb-bb20ad3ef5df.png\" alt=\"image\"></p>\n<h2 id=\"grpc란\"><a href=\"#grpc%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC란</h2>\n<ul>\n<li>gRPC는 높은 성능의 오픈소스 범용 RPC 프레임워크입니다.</li>\n<li>기본적인 개념은 RPC와 동일하지만 특징으로 HTTP/2 기반으로 양방향 스트리밍을 지원하며 메시지의 압축률과 성능이 좋습니다.</li>\n</ul>\n<h3 id=\"rpc란\"><a href=\"#rpc%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>RPC란</h3>\n<ul>\n<li>Remote Procedure Call의 약자로 프로세스간의 통신 기법 중 하나입니다.</li>\n<li>다른 프로세스에 있는 함수를 호출할 때, 마치 같은 프로세스내에 있는 것 처럼 호출가능합니다. (클라이언트는 일반 로컬 메소드처럼 사용)</li>\n<li>다양한 환경, 플랫폼에 제약없이 사용할 수 있기 때문에 분산 시스템 기법에 효과적입니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/133439697-c1e7a3b7-733e-46ba-aa9b-098d580e286e.png\" alt=\"RPC\"></p>\n<blockquote>\n<p>RPC 진행 과정</p>\n</blockquote>\n<ol>\n<li>Client가 자신의 Stub을 호출합니다.</li>\n<li>Stub은 Client가 넘겨준 Parameter들을 Server와 통신할 수 있는 표준 메세지 형태로 변환한 후 Server에 메시지 전송합니다.</li>\n<li>Server측에서는 Client가 Stub을 통해 전송한 메세지를 Server의 Stub에 넘겨줍니다.</li>\n<li>Server측의 Stub은 Client가 전송한 메세지를 자신이 이해할 수 있는 형태로 변환을 해서 Client가 호출한 Method를 실행합니다.</li>\n<li>Method 실행 결과를 Stub을 통해 Client에게 전달합니다.</li>\n<li>Client는 Server와 같은 방식으로 Server가 전송한 메세지를 받고 이해햡니다.</li>\n</ol>\n<blockquote>\n<p>stub?</p>\n</blockquote>\n<p>Client와 Server가 통신할 수 있도록 메시지의 형태를 변환하는 프로그램</p>\n<br/>\n<h2 id=\"grpc의-장점\"><a href=\"#grpc%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC의 장점</h2>\n<h3 id=\"성능\"><a href=\"#%EC%84%B1%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>성능</h3>\n<ul>\n<li>효율적인 이진 메시지 형식인 Protobuf를 사용해 직렬화합니다.</li>\n<li>작은 메시지 페이로드를 발생시켜 모바일 앱과 같은 제한된 대역폭 시나리오에서 중요합니다.</li>\n<li>이진 프레이밍 및 압축, HTTP/2 프로토콜은 간단하며, 보내고 받을 때 모두 효율적입니다.</li>\n</ul>\n<h3 id=\"코드-생성\"><a href=\"#%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>코드 생성</h3>\n<ul>\n<li>gRPC 프레임워크는 코드 생성에 대한 최고 수준의 지원을 제공합니다.</li>\n<li>gRPC 프레임워크는 .proto 파일에서 서비스 기본 클래스, 메시지, 전체 클라이언트를 생성합니다.</li>\n</ul>\n<h3 id=\"엄격한-사양\"><a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%EC%82%AC%EC%96%91\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>엄격한 사양</h3>\n<ul>\n<li>gRPC는 플랫폼 및 구현에 상관없이 일치하므로 이를 준수하기만 하면 됩니다.</li>\n<li><a href=\"https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gRPC 서비스가 따라야 하는 형식에 대한 지침</a></li>\n</ul>\n<h3 id=\"스트리밍\"><a href=\"#%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>스트리밍</h3>\n<ul>\n<li>HTTP/2는 수명이 긴 실시간 통신 스트림에 대한 기초를 제공합니다.</li>\n<li>\n<p>gRPC 서비스는 모든 스트리밍 조합을 지원합니다.</p>\n<ul>\n<li>단항(스트리밍 없음), 서버-클라이언트 스트리밍, 클라이언트-서버 스트리밍, 양방향 스트리밍</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"최종-기한시간-초과-및-취소\"><a href=\"#%EC%B5%9C%EC%A2%85-%EA%B8%B0%ED%95%9C%EC%8B%9C%EA%B0%84-%EC%B4%88%EA%B3%BC-%EB%B0%8F-%EC%B7%A8%EC%86%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>최종 기한/시간 초과 및 취소</h3>\n<ul>\n<li>gRPC는 클라이언트가 RPC가 완료될 때까지대기하는 기간을 지정하도록 할 수 있습니다.</li>\n<li>최종기한이 서버에 전송되고 서버에서 최종 기한을 초과하는 경우 수행할 결정을 결정할 수 있습니다. (ex. 요청 취소 등)</li>\n<li>자식 gRPC 호출을 통해 최종 기한 및 취소를 전파하면 리소스 사용 제한이 가능합니다.</li>\n</ul>\n<br/>\n<h2 id=\"grpc가-적합한-상황인-경우\"><a href=\"#grpc%EA%B0%80-%EC%A0%81%ED%95%A9%ED%95%9C-%EC%83%81%ED%99%A9%EC%9D%B8-%EA%B2%BD%EC%9A%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC가 적합한 상황인 경우</h2>\n<h3 id=\"마이크로-서비스\"><a href=\"#%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마이크로 서비스</h3>\n<ul>\n<li>gRPC는 대기 시간이 짧고 처리량이 높은 통신을 위해 설계되었습니다.</li>\n<li>gRPC는 효율성이 중요한 경량 마이크로 서비스에 적합합니다.</li>\n</ul>\n<h3 id=\"지점간-실시간-통신\"><a href=\"#%EC%A7%80%EC%A0%90%EA%B0%84-%EC%8B%A4%EC%8B%9C%EA%B0%84-%ED%86%B5%EC%8B%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>지점간 실시간 통신</h3>\n<ul>\n<li>양방향 스트리밍을 위한 뛰어난 지원 기능을 제공합니다.</li>\n<li>gRPC 서비스는 풀링을 사용하지 않고 실시간으로 메시지 푸쉬가 가능합니다.</li>\n</ul>\n<h3 id=\"polyglot-환경\"><a href=\"#polyglot-%ED%99%98%EA%B2%BD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Polyglot 환경</h3>\n<ul>\n<li>gRPC 도구는 널리 사용되는 모든 개발 언어를 지원하여, 다중 언어 환경에서 적합합니다.</li>\n</ul>\n<h3 id=\"네트워크-제한-환경\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A0%9C%ED%95%9C-%ED%99%98%EA%B2%BD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>네트워크 제한 환경</h3>\n<ul>\n<li>gRPC 메시지는 경량 메시지 형식인 Protobuf를 사용해 직렬화됩니다.</li>\n</ul>\n<h3 id=\"ipc프로세스-간-통신\"><a href=\"#ipc%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B0%84-%ED%86%B5%EC%8B%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>IPC(프로세스 간 통신)</h3>\n<ul>\n<li><a href=\"https://docs.microsoft.com/ko-kr/aspnet/core/grpc/interprocess?view=aspnetcore-5.0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gRPC와 프로세스 간 통신</a></li>\n</ul>\n<br/>\n<h2 id=\"grpc의-약점\"><a href=\"#grpc%EC%9D%98-%EC%95%BD%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC의 약점</h2>\n<h3 id=\"제한된-브라우저-지원\"><a href=\"#%EC%A0%9C%ED%95%9C%EB%90%9C-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>제한된 브라우저 지원</h3>\n<ul>\n<li>현재 브라우저에서 gRPC 서비스를 직접 호출하는 것은 불가능합니다.</li>\n<li>gRPC는 HTTP/2 기능을 많이 사용하며 브라우저에는 웹 요청에 필요한 제어 수준을 제공하지 않습니다.</li>\n</ul>\n<h4 id=\"grpc를-브라우저-앱으로-가져오는-방법\"><a href=\"#grpc%EB%A5%BC-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%95%B1%EC%9C%BC%EB%A1%9C-%EA%B0%80%EC%A0%B8%EC%98%A4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC를 브라우저 앱으로 가져오는 방법</h4>\n<ul>\n<li><a href=\"https://grpc.io/docs/platforms/web/basics/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gRPC-Web</a></li>\n<li><a href=\"https://docs.microsoft.com/ko-kr/aspnet/core/grpc/httpapi?view=aspnetcore-5.0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gRPC에서 JSON 웹 API</a></li>\n</ul>\n<h3 id=\"사람이-읽을-수-없습니다\"><a href=\"#%EC%82%AC%EB%9E%8C%EC%9D%B4-%EC%9D%BD%EC%9D%84-%EC%88%98-%EC%97%86%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>사람이 읽을 수 없습니다.</h3>\n<ul>\n<li>gRPC 메시지는 기본적으로 Protobuf로 인코딩됩니다.</li>\n<li>이를 읽을려면 추가적인 도구가 필요합니다. (서버 리플렉션이나 gRPC 명령줄 도구)</li>\n</ul>\n<br/>\n<h2 id=\"grpc와-http-api와의-차이\"><a href=\"#grpc%EC%99%80-http-api%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>gRPC와 HTTP API와의 차이</h2>\n<table>\n<thead>\n<tr>\n<th>기능</th>\n<th>gRPC</th>\n<th>HTTP API with JSON</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>계약</td>\n<td>필수(.proto)</td>\n<td>선택 사항(Open API)</td>\n</tr>\n<tr>\n<td>프로토콜</td>\n<td>HTTP/2</td>\n<td>HTTP</td>\n</tr>\n<tr>\n<td>Payload</td>\n<td>Protobuf(소형, 이진)</td>\n<td>JSON(대형, 가독성)</td>\n</tr>\n<tr>\n<td>규범</td>\n<td>엄격한 사양</td>\n<td>느슨함, 모든 HTTP가 유효</td>\n</tr>\n<tr>\n<td>스트리밍</td>\n<td>클라이언트, 서버, 양방향</td>\n<td>클라이언트, 서버</td>\n</tr>\n<tr>\n<td>브라우저 지원</td>\n<td>아니요(gRPC-웹 필요)</td>\n<td>웹</td>\n</tr>\n<tr>\n<td>보안</td>\n<td>전송(TLS)</td>\n<td>전송(TLS)</td>\n</tr>\n<tr>\n<td>클라이언트 코드 생성</td>\n<td>예</td>\n<td>OpenAPI + 타사 도구</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"http://what-and-why-and-how.blogspot.com/2019/11/rpc-what-is-rpc-remote-procedure-call.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">What is RPC</a></li>\n<li><a href=\"https://docs.microsoft.com/ko-kr/aspnet/core/grpc/comparison?view=aspnetcore-5.0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ms docs, gRPC Service and HTTP API</a></li>\n<li><a href=\"https://medium.com/@goinhacker/microservices-with-grpc-d504133d191d\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Microservices with gRPC</a></li>\n</ul>\n"}},{"node":{"title":"[Network] Cacti란?","path":"/00-network-cacti/","date":"31. January 2021","timeToRead":2,"description":"Cacti에 대해 작성합니다.","content":"<h1 id=\"cacti\"><a href=\"#cacti\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cacti</h1>\n<p>엄청 오래된 모니터링 툴이지만, 직접 설치를 하지 않더라도 어떤 개념인지는 알아야겠다는 생각이 있어 정리합니다.</p>\n<h2 id=\"cacti란\"><a href=\"#cacti%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cacti란</h2>\n<ul>\n<li>SNMP 프로토콜을 사용하는 네트워크 <strong>모니터링 툴</strong>입니다.</li>\n<li>관리 및 사용은 브라우저를 통해 이뤄지고, 모든 관리 데이터들은 MySQL을 이용하여 저장됩니다.</li>\n<li>Poller는 주어진 대상 시스템을 조회하여 가져온 결과를 RRD 파일에 저장하고 이 정보를 통해 그래프를 만드는데도 사용됩니다.</li>\n</ul>\n<p><a href=\"https://docs.cacti.net/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">공식 Document</a></p>\n<br/>\n<h2 id=\"cacti의-작업\"><a href=\"#cacti%EC%9D%98-%EC%9E%91%EC%97%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cacti의 작업</h2>\n<h3 id=\"data-retrieval\"><a href=\"#data-retrieval\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Retrieval</h3>\n<ul>\n<li>poller를 사용해서 데이터를 검색합니다.</li>\n<li>Poller는 Unix의 Crontab과 같은 스케쥴러를 수행합니다.</li>\n<li>\n<p>Cacti는 원격 대상의 데이터 검색에 네트워크 관리 프로토콜인 SNMP를 사용합니다.</p>\n<ul>\n<li>Cacti는 SNMP를 사용할 수 있는 모든 디바이스를 모니터링 할 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"data-storage\"><a href=\"#data-storage\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Storage</h3>\n<ul>\n<li>Cacti를 데이터를 저장하기 위해 RRDTool을 사용합니다.</li>\n<li>히스토리 데이터는 공간 절약을 위해 압축합니다.</li>\n</ul>\n<h3 id=\"data-presentation\"><a href=\"#data-presentation\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Presentation</h3>\n<ul>\n<li>그래프 함수로 보여줄 수 있습니다.</li>\n<li>그래프에 다양한 항목을 표현할 수 있고 어떤 플랫폼에서든 거의 모든 브라우저에서 액세스할 수 있습니다.</li>\n<li>Cacti는 PHP로 주로 작성되어 있습니다.</li>\n</ul>\n<br/>\n<h2 id=\"cacti-설치\"><a href=\"#cacti-%EC%84%A4%EC%B9%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Cacti 설치</h2>\n<h3 id=\"일반적인-사용-명령어\"><a href=\"#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%82%AC%EC%9A%A9-%EB%AA%85%EB%A0%B9%EC%96%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>일반적인 사용 명령어</h3>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> cacti</code></pre>\n<p><a href=\"https://yongho1037.tistory.com/553\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">좀 더 자세하게 보기위해서는...</a></p>\n<p>위 글을 참고하면서 사용하면 좋을 듯합니다.</p>\n<h3 id=\"redis-사용\"><a href=\"#redis-%EC%82%AC%EC%9A%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Redis 사용</h3>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> -u cacti php /usr/share/cacti/scripts/ss_get_by_ssh.php --type redis --host <span class=\"token number\">127.0</span>.0.1 --items ln,lo</code></pre>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://yongho1037.tistory.com/553\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://yongho1037.tistory.com/553</a></li>\n<li><a href=\"https://docs.cacti.net/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://docs.cacti.net/</a></li>\n<li><a href=\"https://www.percona.com/doc/percona-monitoring-plugins/1.1/cacti/redis-templates.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.percona.com/doc/percona-monitoring-plugins/1.1/cacti/redis-templates.html</a></li>\n<li><a href=\"https://server-talk.tistory.com/148\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://server-talk.tistory.com/148</a></li>\n</ul>\n"}},{"node":{"title":"[Network] NAT 개념잡기?","path":"/00-network-nat/","date":"26. January 2021","timeToRead":4,"description":"NAT의 개념을 잡습니다.","content":"<h1 id=\"nat\"><a href=\"#nat\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NAT</h1>\n<h2 id=\"nat의-개념\"><a href=\"#nat%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NAT의 개념</h2>\n<p>NAT는 Network Address Translate의 약자로서, 네트워크 주소를 변환하는 역할을 합니다. 좀 더 자세하게 이야기 하자면 IP패킷의 TCP/UDP 포트 숫자 및 목적지의 IP 주로를 재기록 하면서 라우터를 통해서 네트워크 트래픽을 주고 받는 기술입니다.</p>\n<p>일반적으올 border router의 기능을 수행하는 데, 이는 <strong>내부 망에서는 사설 IP 주소를 사용하여 통신을 하고 외부와의 통신에는 NAT를 거쳐 공인 IP 주소로 자동 변환하는 역할</strong>을 수행합니다.</p>\n<br/>\n<h2 id=\"nat-사용-이유\"><a href=\"#nat-%EC%82%AC%EC%9A%A9-%EC%9D%B4%EC%9C%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NAT 사용 이유</h2>\n<p>NAT를 이용하는 이유는 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 통해서 사용하여 인터넷에 접속하기 위함입니다.</p>\n<p>NAT는 IPv4의 주소 부족 문제를 해결하기 위해서 고려했으며, 사설 네트워크 주소를 사용하는 망(private)에서 외부의 공인망(public)과의 통신을 위해서 네트워크 주소를 변환하는 것입니다.</p>\n<br/>\n<h2 id=\"nat-동작-원리\"><a href=\"#nat-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NAT 동작 원리</h2>\n<p>NAT는 1:1의 주소 매핑을 수행하기 때문에 NAT 라우터로 들어온 inside -> outside 패킷만이 주소 전환의 대상이 됩니다. IP의 헤더부분을 체크하여, NAT 테이블에 의해 해당 주소로 바꾼다음 checksum을 다시 계산하여 IP의 헤더를 바꾸는 방법으로 동작합니다.</p>\n<p>Application Layer까지 NAT 주소 전환이 반영이 되어야하므로, NAT는 IP 주소의 참조내용을 담고 있는 Application data 부분을 새로운 주소로 변환하여 수행합니다.</p>\n<br/>\n<h2 id=\"nat의-변환-방식\"><a href=\"#nat%EC%9D%98-%EB%B3%80%ED%99%98-%EB%B0%A9%EC%8B%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NAT의 변환 방식</h2>\n<h3 id=\"full-cone-natone-to-one-nat\"><a href=\"#full-cone-natone-to-one-nat\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Full-cone NAT(one-to-one NAT)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/105776816-9b553b80-5fac-11eb-9bca-3a04d0cacd06.png\" alt=\"Full-cone NAT(one-to-one NAT)\"></p>\n<h3 id=\"address-restricted-cone-nat\"><a href=\"#address-restricted-cone-nat\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>(Address)-restricted-cone NAT</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/105776803-95f7f100-5fac-11eb-8223-59f548991746.png\" alt=\"(Address)-restricted-cone NAT\"></p>\n<h3 id=\"port-restricted-cone-nat\"><a href=\"#port-restricted-cone-nat\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Port-restricted cone NAT</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/105776834-a0b28600-5fac-11eb-822a-6a628272c2e1.png\" alt=\"Port-restricted cone NAT\"></p>\n<h3 id=\"symmetric-nat\"><a href=\"#symmetric-nat\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Symmetric NAT</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/105776840-a5773a00-5fac-11eb-81d5-26e2d2c58443.png\" alt=\"Symmetric NAT\"></p>\n<br/>\n<h2 id=\"nat의-장단점\"><a href=\"#nat%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NAT의 장단점</h2>\n<h3 id=\"nat의-장점\"><a href=\"#nat%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NAT의 장점</h3>\n<ul>\n<li>\n<p>인터넷의 공인 IP주소를 절약할 수 있습니다.</p>\n<ul>\n<li>공인 IP를 다수가 함께 사용할 수 있으므로 이를 절약할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>공공망고 연결되는 사용자들의 고유한 사설망을 침입자들로 부터 보호할 수 있습니다.</p>\n<ul>\n<li>공개된 인터넷과 사설망 사이에 방화벽을 설치하여 외부공격으로부터 사용자의 통신망을 보호할 수 있습니다.</li>\n<li>NAT 설정 시, 라우터는 자신에게 할당된 공인 IP주소만 외부로 알려지고 내부에서는 사설 IP를 사용하기 때문에 외부침입자는 사설 IP를 몰라 공격이 힘들어집니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"nat의-단점\"><a href=\"#nat%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NAT의 단점</h3>\n<ul>\n<li>Ent-to-End간의 추적(IP Trace)가 어려워집니다. 여러 개의 NAT 라우터에 의해 multiple NAT 가 적용되면 추적이 더 어려워집니다. (보안측에서는 장점입니다)</li>\n<li>NAT 라우터를 거치는 모든 패킷을 scan해야해서 switching path delay 가 길어집니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간단하게 NAT에 대해서 정리했습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%EC%A3%BC%EC%86%8C_%EB%B3%80%ED%99%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%EC%A3%BC%EC%86%8C_%EB%B3%80%ED%99%98</a></li>\n<li><a href=\"https://m.blog.naver.com/PostView.nhn?blogId=ssdyka&#x26;logNo=221376674886&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.blog.naver.com/PostView.nhn?blogId=ssdyka&#x26;logNo=221376674886&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F</a></li>\n<li><a href=\"https://jwprogramming.tistory.com/30\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://jwprogramming.tistory.com/30</a></li>\n</ul>\n"}},{"node":{"title":"[Network] LDAP이란?","path":"/00-network-ldap/","date":"19. January 2021","timeToRead":5,"description":"LDAP에 대해 작성합니다.","content":"<h1 id=\"ldap\"><a href=\"#ldap\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAP</h1>\n<p>LDAP의 개념은 들어본 사람도 있을 것이고 들어보지 못한 사람도 있을 것입니다. 업무에 대해 진행을 하다가 LDAP에 대해 들어보게 되었고 처음 듣는 개념이라 한 번 정리가 필요하다는 생각이 필요했습니다.</p>\n<br/>\n<h2 id=\"ldap의-개념\"><a href=\"#ldap%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAP의 개념</h2>\n<p>LDAP이란 <code class=\"language-text\">Lightweight Directory Access Protocol</code>의 약자로 이를 해석하면 경량 디렉터리 액세스 프로토콜로 해석됩니다. 간단하게 이야기하면 TCP/IP 위에서 <strong>디렉터리 서비스를 조회하고 수정하는 응용 프로토콜</strong>입니다.</p>\n<ul>\n<li>디렉토리 : 논리, 계급 방식 속에서 조직화된 비슷한 특성을 가진 객체들의 모임</li>\n</ul>\n<p>일반적으로 LDAP은 인증을 위한 다른 서비스에서 자주 사용됩니다. 또한 LDAP의 배치는 최상위 수준의 계급을 구조화하기 위해 도메인 이름을 사용하는데 디렉토리가 깊어질수록 이를 대표하는 항목이 나타납니다.</p>\n<p>LDAP의 개념을 이해하기 위해서는 DAP에 대해서 알면 좋습니다. X.500의 DAP은 OSI 7 계층의 전체 프로토콜 스택을 지원하는데 너무 무거운 프로토콜입니다. 그래서 <strong>DAP의 복잡성을 줄이고 TCP/IP 레이어에서 가볍게 조작할 수 있는 프로토콜, 저장소로서 특정화된 데이터베이스이며 write 작업보다는 read 작업에 적합</strong>한 것으로 탄생한 것이 LDAP입니다.</p>\n<blockquote>\n<p>X.500</p>\n</blockquote>\n<p>X.500은 전자 디렉토리 서비스를 전달하는 컴퓨터 네트워크 표준입니다. 좀 더 자세하게 알기위해서는 <code class=\"language-text\">Directory Service</code>의 개념에 대해서 이해해야하는데, 이는 <strong>OSI 7 Layer의 응용계층에 속하는 프로토콜로서 정보통신 서비스에 필요한 정보를 데이터베이스화하여 효율적으로 관리하고 사용자가 편리하게 접근하는 기능을 제공하는 서비스</strong>입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104970027-836e3c80-5a2d-11eb-8a53-ebf697fe300d.png\" alt=\"Directory-service\"></p>\n<p>Dircetory Service는 다음과 같은 형태를 가지고 있습니다.</p>\n<ul>\n<li><code class=\"language-text\">DUA</code> : Directory User Agent, 사용자와 디렉토리 간의 인터페이스 역할 수행 프로세스</li>\n<li><code class=\"language-text\">DSA</code> : Directory System Agent, 디렉토리 내 사용자의 요구 프로세스</li>\n</ul>\n<br/>\n<h2 id=\"ldap의-구성\"><a href=\"#ldap%EC%9D%98-%EA%B5%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAP의 구성</h2>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104970321-5f5f2b00-5a2e-11eb-8e6d-b064167a8c52.png\" alt=\"ldap-component\"></p>\n<p>LDAP의 요청은 사용자나 응용프로그램에서 요청시 LDAP을 통해서 LDAP서버에 전달됩니다. 서버는 요청을 처리 후 다시 LDAP을 통해서 요청자에게 결과를 전송합니다. 기존의 DAP과 다르게 TCP/IP 상에서 운영됩니다.</p>\n<br/>\n<h2 id=\"ldap의-구조\"><a href=\"#ldap%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAP의 구조</h2>\n<p>LDAP의 구조는 크게 4가지로 구분됩니다.</p>\n<p>너무 깊게 들어가면 내용적으로 이해하기 힘들 것 같아 개념만 정리하겠습니다.</p>\n<h3 id=\"information-모델\"><a href=\"#information-%EB%AA%A8%EB%8D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Information 모델</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104970313-58d0b380-5a2e-11eb-9115-a9c1a527bc38.png\" alt=\"ldap-hierarchical\"></p>\n<p><strong>정의</strong> : LDAP의 데이터에 대한 종류와 디렉토리에 저장되는 정보에 대한 기본 단위를 정의합니다. 기본적으로 Entries, Attributes, Values 3가지로 정의됩니다.</p>\n<ul>\n<li>Entry : 디렉토리 정보에 대한 기본단위</li>\n<li>Attribute : Entry를 구성하는 단위</li>\n<li>Value : Attribute의 실질적인 데이터</li>\n</ul>\n<h3 id=\"naming-모델\"><a href=\"#naming-%EB%AA%A8%EB%8D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Naming 모델</h3>\n<p><strong>정의</strong> : 데이터를 어떻게 구성하고 참조할 것인지에 대해 정의합니다.</p>\n<h3 id=\"functional-모델\"><a href=\"#functional-%EB%AA%A8%EB%8D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Functional 모델</h3>\n<p><strong>정의</strong> : 디렉토리 트리의 데이터에 접근하는 방법에 대해 정의합니다. 크게 3가지 그룹으로 구성합니다.</p>\n<ul>\n<li>Interrogation(질문) 작업 : 디렉토리 Entry를 검색 및 비교하는 기능</li>\n<li>Update(갱신) 작업 : 디렉토리 Entry의 추가, 삭제, 변경 등의 기능</li>\n<li>Authentication(인증) 및 Control(제어) 작업 : 클라이언트의 확인 및 제어 기능(Bind, Unbind, Abandon)</li>\n</ul>\n<h3 id=\"secruity-모델\"><a href=\"#secruity-%EB%AA%A8%EB%8D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Secruity 모델</h3>\n<p>인증된 접근만 디렉토리 내 정보를 제공합니다.</p>\n<br/>\n<h2 id=\"ldap-version\"><a href=\"#ldap-version\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAP Version</h2>\n<p>현재 version 3까지 나왔습니다.</p>\n<h3 id=\"ldapv1-vs-ldap-v2\"><a href=\"#ldapv1-vs-ldap-v2\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAPv1 vs LDAP v2</h3>\n<ul>\n<li>LDAPv2는 인증과정없이 LDAP 서버에 Bind 되는 것이 허용됩니다.</li>\n<li>READ, List Operation이 삭제되었습니다.</li>\n<li>클라이언트는 오직 하나의 서버에만 연결가능하도록 바뀌었습니다.(DAP의 Referral 기능을 제공하지않습니다.)</li>\n</ul>\n<h3 id=\"ldapv2-vs-ldap-v3\"><a href=\"#ldapv2-vs-ldap-v3\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LDAPv2 vs LDAP v3</h3>\n<ul>\n<li>Referral을 통해서 분산 기능이 생겼습니다.</li>\n<li>사용자 정의 Attribute와 Object 생성이 가능합니다.</li>\n<li>UTF-8 Encoding을 이용해서 언어를 표현하는 제약이 완화되었고 다양한 언어 사용이 가능합니다.</li>\n<li>사용자 정의 Matching Rule이 생성 가능합니다.</li>\n<li>보안성이 올라갔습니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간략하게 개념을 잡는다고 생각하고 내용을 정리했습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://ldap.or.kr/ldap-%EC%9D%B4%EB%9E%80/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ldap.or.kr/ldap-%EC%9D%B4%EB%9E%80/</a></li>\n<li><a href=\"https://velog.io/@kante/LDAP-%EC%9D%B4%EB%9E%80\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@kante/LDAP-%EC%9D%B4%EB%9E%80</a></li>\n<li><a href=\"https://medium.com/@hmj2088/ldap-dc771e2704a9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/@hmj2088/ldap-dc771e2704a9</a></li>\n</ul>\n"}},{"node":{"title":"[Network] NGINX란?","path":"/00-network-nginx/","date":"14. January 2021","timeToRead":3,"description":"NGINX에 대해 작성합니다.","content":"<h1 id=\"nginx란\"><a href=\"#nginx%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nginx란.</h1>\n<h2 id=\"nignx의-정의\"><a href=\"#nignx%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nignx의 정의.</h2>\n<p>Nginx는 가벼움과 높은 성능을 목표로 하는 웹서버 소프트웨어입니다.</p>\n<p>이러한 Nginx는 트래픽이 많은 웹사이트를 위해 확장성을 위해 설계한 비동기 이벤트 기반 구조를 가지고 있습니다.</p>\n<p>일반적으로 <strong>웹 서버, 리버스 프록시 및 메일 프록시</strong> 기능을 가집니다.</p>\n<br/>\n<h2 id=\"apache-vs-nginx\"><a href=\"#apache-vs-nginx\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Apache VS Nginx</h2>\n<p>주로 Nginx는 Apache 서버와 비교를 하는데, 현재는 Nginx가 1위를 차지하고 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104517057-bd5bcf00-5638-11eb-8e24-859c5bf2ee88.png\" alt=\"server-rank\"></p>\n<blockquote>\n<p>Apache</p>\n</blockquote>\n<ul>\n<li>쓰레드 / 프로세스 기반 구조로 요청 하나당 쓰레드 하나가 처리하는 구조입니다.</li>\n<li>사용자가 많으면 많은 쓰레드가 생성되고, 메모리와 CPU 낭비가 심합니다.</li>\n</ul>\n<blockquote>\n<p>Nginx</p>\n</blockquote>\n<ul>\n<li>비동기 Event-Driven 기반의 구조입니다.</li>\n<li>다수의 연결을 효과적으로 처리가능합니다.</li>\n<li>대부분의 코어 모듈이 Apache보다 적은 리소스로 더 빠르게 동작가능합니다.</li>\n<li>더 작은 쓰레드로 클라이언트의 요청들을 처리 가능합니다.</li>\n</ul>\n<p>Apache와 Nginx의 가장 큰 차이는 Thread 방식과 Event-drive의 차이입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104517420-4bd05080-5639-11eb-92a5-dc3f78cc5891.png\" alt=\"Thread-VS-Event-Driven\"></p>\n<p>다음 그림처럼 쓰레드 기반은 하나의 커넥션 당 하나의 쓰레드를 사용하지만, Event-driven 방식은 여러 커넥션을 모두 Event-Handler를 통해 비동기 방식으로 처리해서 먼저 처리되는 것부터 로직이 진행됩니다.</p>\n<br/>\n<h2 id=\"nginx-활용\"><a href=\"#nginx-%ED%99%9C%EC%9A%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nginx 활용</h2>\n<p>Nginx은 다음과 같은 기능으로 사용할 수 있습니다.</p>\n<ul>\n<li>\n<p>HTTP Server</p>\n<ul>\n<li>정적 파일을 처리하는 web server의 역할을 수행합니다.</li>\n</ul>\n</li>\n<li>\n<p>Reverse proxy server</p>\n<ul>\n<li>클라이언트의 요청을 Application server에 배분합니다.</li>\n<li>클라이언트 80포트 요청을 8080, 8081 등 여러 Application server로 보내줍니다.</li>\n<li>각 application server에 요청을 배분해서 부하를 분산합니다. (load balancing)</li>\n</ul>\n</li>\n<li>Mail proxy server</li>\n<li>Generic TCP/UDP proxy server</li>\n</ul>\n<br/>\n<h2 id=\"nginx-proxy\"><a href=\"#nginx-proxy\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nginx Proxy</h2>\n<p>node.js에서 nginx.conf를 파일을 수정하여 아래처럼 수정하면됩니다.</p>\n<pre class=\"language-conf\"><code class=\"language-conf\">server {\n  listen    81;\n  server_name localhost;\n\n  location / {\n    proxy_pass http://127.0.0.1:3000/;\n  }\n}</code></pre>\n<p>다음과 같이 수정을 하게 되면, 81번 포트로 접속을 해도 3000번 포트의 서버에 접속이 되게됩니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>오늘은 간략하게 Nginx에 대해 정리해보았습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"http://nginx.org/en/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://nginx.org/en/</a></li>\n<li><a href=\"https://news.netcraft.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://news.netcraft.com/</a></li>\n<li><a href=\"https://smjeon.dev/etc/nginx/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://smjeon.dev/etc/nginx/</a></li>\n<li><a href=\"https://m.blog.naver.com/jhc9639/220967352282\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://m.blog.naver.com/jhc9639/220967352282</a></li>\n</ul>\n"}},{"node":{"title":"[Network] GSLB란?","path":"/00-network-gslb/","date":"11. January 2021","timeToRead":4,"description":"GSLB에 대해 작성합니다.","content":"<h1 id=\"gslb란\"><a href=\"#gslb%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GSLB란?</h1>\n<p>로드밸런서 관련 이야기를 하면서 어쩌면 한번 쯤 GSLB에 대해 들어봤을 수 있다. 회사에서는 F5나, Citrix와 같이 여러 GSLB를 사용하고 있는데 오늘은 이에 대해 한번 정리해봅니다.</p>\n<h2 id=\"gslb의-정의\"><a href=\"#gslb%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GSLB의 정의</h2>\n<p>GLSB는 Global Service Load Balancing의 약자로, <strong>비지니스 연속성 및 재해 복구에 사용되는 기술들의 집합</strong>입니다,</p>\n<p>이러한 GLSB는 다음과 같은 기능을 제공하여, 지능적 DNS 서비스라고도 불리기도 합니다.</p>\n<ul>\n<li>\n<p>재난 복구 (disaster recovery)</p>\n<ul>\n<li>실패에 대해 대체할 수 있는 서버를 제공합니다.</li>\n</ul>\n</li>\n<li>\n<p>부하 분산 (load sharing)</p>\n<ul>\n<li>많은 트래픽을 여러 서버로 분산합니다.</li>\n</ul>\n</li>\n<li>\n<p>성능 (performance)</p>\n<ul>\n<li>client의 위치나 네트워크를 기반으로 최적의 성능을 낼 서버를 선택합니다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"glsb의-동작\"><a href=\"#glsb%EC%9D%98-%EB%8F%99%EC%9E%91\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GLSB의 동작</h2>\n<p>다음과 같은 순서로 진행됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104177144-adcb6300-544b-11eb-8ce7-4cbeef9c7480.png\" alt=\"GLSB-logic\"></p>\n<p>각 서버마다 Health Check를 하고 운영가능한 서버의 IP를 반환합니다.</p>\n<br/>\n<h2 id=\"glsb-vs-dns\"><a href=\"#glsb-vs-dns\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GLSB vs DNS</h2>\n<p>GLSB와 DNS를 비교하면 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/104177295-e53a0f80-544b-11eb-8cb4-71d51475305d.png\" alt=\"GLSB-vs-DNS\"></p>\n<p>이를 표로 표현하면 다음과 같습니다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>GLSB</th>\n<th>DNS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>재해복구</td>\n<td>- 모니터링(Health Check) 실패한 IP는 응답에서 제외합니다.</td>\n<td>- 서버의 상황을 알 수 없습니다.</td>\n</tr>\n<tr>\n<td>로드밸런싱</td>\n<td>- 서버를 모니터링 해서 로드가 적은 서버의 IP를 반환합니다.</td>\n<td>- Round Robin 방식을 사용합니다. 정교한 로드밸런싱이 되지않습니다.</td>\n</tr>\n<tr>\n<td>레이턴시 기반</td>\n<td>- 유저에게 더 적은 latency를 가지는 서버로 연결합니다.</td>\n<td>- 네트워크상 멀리 떨어진 위치의 서버에 연결가능합니다.</td>\n</tr>\n<tr>\n<td>위치기반 서비스</td>\n<td>- 유저의 지역 정보에 기반하여, 해당 지역을 서버스하는 서버로 연결합니다.</td>\n<td>- Round Robin</td>\n</tr>\n</tbody>\n</table>\n<br/>\n<h2 id=\"gslb-주요-기술\"><a href=\"#gslb-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EC%88%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>GSLB 주요 기술</h2>\n<h3 id=\"health-check\"><a href=\"#health-check\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Health Check</h3>\n<ul>\n<li>등록된 호스트들에 대해 주기적으로 health check를 수행합니다.</li>\n<li>호스트가 실패하는 경우, DNS 응답에서 해당 호스트를 제거합니다.</li>\n<li>실패한 호스트로의 접근을 막아서 서버의 가용성을 높입니다.</li>\n</ul>\n<h3 id=\"ttltime-to-live\"><a href=\"#ttltime-to-live\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>TTL(Time to Live)</h3>\n<ul>\n<li>DNS에서 권한을 가진 네임 서버는 특정 레코드에 대해 TTL를 설정할 수 있습니다.</li>\n<li>캐시 네임서버는 TTL 동안 캐시에 저장하고, Client로부터 요청이 오면 캐시에 저장된 값을 반환합니다.</li>\n<li>TTL값이 너무 크면, GLSB의 상태 정보가 제때 동기화되지 못합니다.</li>\n<li>TTL값이 너무 짧으면, 네임서버에 오는 부담감이 커집니다.</li>\n</ul>\n<h3 id=\"네트워크-거리와-지역\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B1%B0%EB%A6%AC%EC%99%80-%EC%A7%80%EC%97%AD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>네트워크 거리와 지역</h3>\n<ul>\n<li>주기적으로 성능을 측정하고 결과를 저장합니다.</li>\n<li>DNS 질의에 대해 지리적으로 가까운 서버를 반환하거나 네트워크 거리가 가까운 서버를 반환합니다.</li>\n<li>지리적으로 가까운 서버는 RTT(Round Trip Time)도 짧기 때문에 동일한 결과를 반환하는 경우가 많습니다.</li>\n</ul>\n<br/>\n<h2 id=\"대표적인-서비스\"><a href=\"#%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>대표적인 서비스</h2>\n<ul>\n<li>AWS : Route53</li>\n<li>Google Cloud : Cloud Load Balancing</li>\n<li>Azure : Traffic Manager</li>\n<li>Naver : Global Route Manager</li>\n<li>F5</li>\n<li>Citrix</li>\n</ul>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>간단하게 GSLB에 대해 정리했습니다. 잘못된 부분 있으면 편하게 알려주세요.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://ckddn9496.tistory.com/33\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ckddn9496.tistory.com/33</a></li>\n<li><a href=\"https://nesoy.github.io/articles/2020-01/GSLB\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://nesoy.github.io/articles/2020-01/GSLB</a></li>\n<li><a href=\"https://blog.naver.com/n_cloudplatform/221206343859\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://blog.naver.com/n_cloudplatform/221206343859</a></li>\n<li><a href=\"https://www.joinc.co.kr/w/man/12/GSLB\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.joinc.co.kr/w/man/12/GSLB</a></li>\n<li><a href=\"https://cloud.kt.com/portal/ktcloudportal.epc.productintro.gslb.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cloud.kt.com/portal/ktcloudportal.epc.productintro.gslb.html</a></li>\n<li><a href=\"https://cwiki.apache.org/confluence/display/CLOUDSTACK/GSLB+%28Global+Server+Load+Balancing%29+Functional+specification+and+Design+Document\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cwiki.apache.org/confluence/display/CLOUDSTACK/GSLB+%28Global+Server+Load+Balancing%29+Functional+specification+and+Design+Document</a></li>\n<li><a href=\"https://www.netmanias.com/ko/post/blog/5620/dns-data-center-gslb-network-protocol/global-server-load-balancing-for-enterprise-part-1-concept-workflow\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.netmanias.com/ko/post/blog/5620/dns-data-center-gslb-network-protocol/global-server-load-balancing-for-enterprise-part-1-concept-workflow</a></li>\n<li><a href=\"https://cloud.kt.com/portal/ktcloudportal.epc.productintro.gslb.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cloud.kt.com/portal/ktcloudportal.epc.productintro.gslb.html</a></li>\n</ul>\n"}},{"node":{"title":"[Network] CDN이란?","path":"/00-network-cdn/","date":"28. December 2020","timeToRead":5,"description":" CDN에 대해 작성합니다.","content":"<h1 id=\"cdn이란\"><a href=\"#cdn%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CDN이란?</h1>\n<p>롤을 좋아하시는 분 들 중, 저번 큰 이슈 중 하나로 CDN 서버가 나가서 대회가 중단되었던 사례가 있습니다.</p>\n<p>일반적으로 사용자가 많은 사이트나, 서버에서는 거의 대부분 CDN을 사용합니다. 저희 회사에서 배포하는 서비스 또한 CDN을 당연히 쓰고 있고 이에 대한 개념을 아는 것은 거의 필수라고 볼 수 있습니다. 그에 따라 한번 내용을 정리해볼려고합니다.</p>\n<br/>\n<h2 id=\"cdn의-정의\"><a href=\"#cdn%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CDN의 정의</h2>\n<p>CDN(Contents Delivery Network)은 <strong>물리적으로 멀리 떨어져있는 사용자에게 컨텐츠 제공자의 컨텐츠를 더 빠르게 제공할 수 있는 기술</strong>을 의미합니다.</p>\n<p>일반적으로 우리가 많이 보는 넷플릭스와 같이 큰 영상 데이터를 스트리밍해서 사용자에게 보내줘야하는 경우에는 이러한 CDN은 반드시 필요한 기술입니다.</p>\n<p>좀 더 자세하게 설명하자면, 기본적으로 사용자는 원격에 있는 서버(Origin Server)로 부터 Content(Ex. Web Object, Video, Music, Image 등등)을 다운 받을때는 가까이에서 받는것보다 시간이 오래걸립니다. 따라서 사용자와 가까운 곳에 위치한 Cache Server에 Content를 저장(캐싱)하고 Content 요청시에 Cache Server에 응답을 주는 기술입니다.</p>\n<p>즉, CDN은 <strong>콘텐츠를 전송하도록 최적화된 전세계적으로 촘촘히 분산된 서버로 이루어진 플랫폼</strong>입니다. 이 <strong>CDN은 Origin이라고 불리는 콘텐츠 서버와 엔드유저(Client) 사이에서 컨텐츠를 저장</strong>하는 역할을 합니다.</p>\n<br/>\n<h2 id=\"cdn의-이용시-장점\"><a href=\"#cdn%EC%9D%98-%EC%9D%B4%EC%9A%A9%EC%8B%9C-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CDN의 이용시 장점</h2>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103219584-7942ac00-4961-11eb-9011-4e76f394c548.png\" alt=\"CDN 장점\"></p>\n<p>일반적으로 CDN을 사용하지 않으면 Origin 서버의 경우에는 모든 클라이언트의 요청에 일일이 응답해야합니다. 이는 막대한 트래픽을 유발하고, 장애 발생확률을 높입니다.</p>\n<p>CDN을 이용하면 다음과 같은 장점을 가집니다.</p>\n<ul>\n<li>\n<p>성능</p>\n<ul>\n<li>온라인 콘텐츠가 빠르게 전송시킬 수 있습니다.</li>\n<li>해당 Origin 서버가 여러 위치에 CDN을 설치해놓으면 해당 위치에서 신규 콘텐츠를 요청하는 경우, 가까운 곳에서 직접 액세스가 가능하고 이를 통해서 수백, 수천 킬로미터의 왕복시간을 절약할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>가용성</p>\n<ul>\n<li>여러 트래픽 급증, 서버 중단 등의 이슈에서도 클라이언트에게 콘텐츠를 제공할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>보안</p>\n<ul>\n<li>보안적인 지원이 많이 들어가는 CDN을 사용하는 경우, CDN은 악성 유저들의 공격을 막음으로서 사용자들을 보호할 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"cdn의-작동원리\"><a href=\"#cdn%EC%9D%98-%EC%9E%91%EB%8F%99%EC%9B%90%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CDN의 작동원리.</h2>\n<p>CDN은 다음과 같이 작동합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103219998-7b593a80-4962-11eb-9b95-290c39678b9c.png\" alt=\"CDN 작동원리\"></p>\n<ol>\n<li>일반적으로 웹 브라우저가 실행되는 디바이스인 PC나 모바일에서 사용자가 접근해서 필요한 콘텐츠를 요청합니다.</li>\n<li>대부분의 CDN의 경우, 각 요청이 발생시 가장 가까운 위치에 최적으로 배치된 CDN 서버에 클라이언트가 매핑되고 해당 서버는 이 데이터를전송합니다.</li>\n<li>오래된 CDN의 경우, 요청 프록시를 통해서 Origin 서버에 콘텐츠를 요청하고 새로운 콘텐츠로 저장합니다.</li>\n</ol>\n<br/>\n<h2 id=\"cdn-캐싱-방식의-종류\"><a href=\"#cdn-%EC%BA%90%EC%8B%B1-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CDN 캐싱 방식의 종류</h2>\n<p>Content 캐싱은 Static과 Dynamic으로 나눌 수 있습니다.</p>\n<h3 id=\"static-caching\"><a href=\"#static-caching\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Static Caching</h3>\n<ul>\n<li>사용자 요청이 없어도 Origin Server에 있는 Content를 운영자가 미리 Cache Server에 복사합니다,</li>\n<li>따라서 사용자가 Cache Server에서 Content를 요청시 반드시 해당 컨텐츠는 Cache Server에 있습니다.</li>\n<li>대부분의 국내 CDN은 이 방식을 선호합니다.</li>\n</ul>\n<h3 id=\"dynamic-caching\"><a href=\"#dynamic-caching\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Dynamic Caching</h3>\n<ul>\n<li>최초 Cache Server에는 Content가 없습니다.</li>\n<li>사용자가 Content를 요청하면, 해당 Content가 있는지 확인하고 없으면 Origin Server로부터 다운로드 받습니다</li>\n<li>이후 동일 Content 요청을 받은 경우, 저정(캐싱)된 Content를 사용자에게 전달합니다. (Cache Hit)</li>\n<li>각 Content는 일정시간(TTL)이 지나면 Content Server에서 삭제될 수 있고 혹은 Origin Server를 통해서 Content 최신화 된 이후 계속 가지고 있을 수 있습니다.</li>\n<li>Global CDN 업체의 경우에는 일반적으로 이 방식을 선호합니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>오늘은 간단하게, CDN에 대해 정리해보았습니다. 많은 회사에서 CDN을 쓰고 있고 이에 따라 이정도의 개념은 알고 있는 것이 좋은 것 같습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://cdn.hosting.kr/cdn%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cdn.hosting.kr/cdn%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/</a></li>\n<li><a href=\"https://goddaehee.tistory.com/173\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://goddaehee.tistory.com/173</a></li>\n<li><a href=\"https://brownbears.tistory.com/408\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://brownbears.tistory.com/408</a></li>\n</ul>\n"}}]}}},"context":{}}