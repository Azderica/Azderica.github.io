{"hash":"c2dcd6346273a26a908e8ae3dd5d59774a4a3863","data":{"tag":{"title":"Api","belongsTo":{"edges":[{"node":{"title":"[WEB] RESTful API","path":"/00-restful-api/","date":"1. March 2022","timeToRead":10,"description":"Restful API에 대해 정리합니다.","content":"<h1 id=\"restful-api\"><a href=\"#restful-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>RESTful API</h1>\n<p>갑자기 기억이 안나서 다시 작성.</p>\n<br/>\n<h2 id=\"rest란\"><a href=\"#rest%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>REST란?</h2>\n<ul>\n<li><code class=\"language-text\">Representational State Transfe</code>라는 용어의 약자입니다.</li>\n<li>자원을 <code class=\"language-text\">URI</code>로 표시하고 해당 자원의 상태를 주고 받는 것을 의미합니다.</li>\n</ul>\n<p>REST의 구성 요소는 아래로 이루어졌습니다.</p>\n<ul>\n<li><code class=\"language-text\">자원(Resource)</code>: URI</li>\n<li><code class=\"language-text\">행위(Verb)</code>: HTTP METHOD</li>\n<li><code class=\"language-text\">표현(Representations)</code></li>\n</ul>\n<p>즉 <code class=\"language-text\">Rest</code>는 <code class=\"language-text\">URI</code>를 통해 자원을 표시하고, <code class=\"language-text\">HTTP METHOD</code>를 이용하여 해당 자원의 행위를 정해주며 그 결과를 받는 것을 의미합니다.</p>\n<Br/>\n<h2 id=\"rest의-특징\"><a href=\"#rest%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>REST의 특징</h2>\n<h3 id=\"1-uniform-유니폼-인터페이스\"><a href=\"#1-uniform-%EC%9C%A0%EB%8B%88%ED%8F%BC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1) Uniform (유니폼 인터페이스)</h3>\n<ul>\n<li>Uniform Interface는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다.</li>\n</ul>\n<h3 id=\"2-stateless-무상태성\"><a href=\"#2-stateless-%EB%AC%B4%EC%83%81%ED%83%9C%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2) Stateless (무상태성)</h3>\n<ul>\n<li>REST는 무상태성 성격을 갖습니다. 즉 작업을 위한 상태정보를 따로 저장하고 관리하지 않습니다.</li>\n<li>세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만 단순히 처리하면 됩니다. </li>\n<li>서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다.</li>\n</ul>\n<h3 id=\"3-cacheable-캐시-가능\"><a href=\"#3-cacheable-%EC%BA%90%EC%8B%9C-%EA%B0%80%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3) Cacheable (캐시 가능)</h3>\n<ul>\n<li>REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다. </li>\n<li>즉, HTTP가 가진 캐싱 기능이 적용 가능합니다. HTTP 프로토콜 표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하면 캐싱 구현이 가능합니다.</li>\n</ul>\n<h3 id=\"4-self-descriptiveness-자체-표현-구조\"><a href=\"#4-self-descriptiveness-%EC%9E%90%EC%B2%B4-%ED%91%9C%ED%98%84-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>4) Self-descriptiveness (자체 표현 구조)</h3>\n<ul>\n<li>REST의 또 다른 큰 특징 중 하나는 REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어 있다는 것입니다.</li>\n</ul>\n<h3 id=\"5-client---server-구조\"><a href=\"#5-client---server-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>5) Client - Server 구조</h3>\n<ul>\n<li>REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다.</li>\n</ul>\n<h3 id=\"6-계층형-구조\"><a href=\"#6-%EA%B3%84%EC%B8%B5%ED%98%95-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>6) 계층형 구조</h3>\n<ul>\n<li>REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다.</li>\n</ul>\n<br/>\n<h2 id=\"rest-api란\"><a href=\"#rest-api%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>REST API란?</h2>\n<p>Rest 기반의 규칙들을 지켜서 설계된 API를 Rest API 혹은 Restful API이라고 합니다.</p>\n<br/>\n<h2 id=\"rest-api-설계-규칙\"><a href=\"#rest-api-%EC%84%A4%EA%B3%84-%EA%B7%9C%EC%B9%99\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>REST API 설계 규칙</h2>\n<h3 id=\"1-uri는-정보의-자원을-표현해야합니다\"><a href=\"#1-uri%EB%8A%94-%EC%A0%95%EB%B3%B4%EC%9D%98-%EC%9E%90%EC%9B%90%EC%9D%84-%ED%91%9C%ED%98%84%ED%95%B4%EC%95%BC%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. URI는 정보의 자원을 표현해야합니다.</h3>\n<ul>\n<li>자원의 이름은 동사보다는 명사를 사용합니다.</li>\n<li>URI는 자원을 표현하는데 중점을 두어야 하기 때문에 행위에 대한 표현이 들어가면 안됩니다.</li>\n<li>행위에대한 동사 표현이 들어가면 안됩니다.</li>\n</ul>\n<pre class=\"language-null\"><code class=\"language-null\">    GET /users/321</code></pre>\n<h3 id=\"2-자원에-대한-행위는-http-method로-표현합니다-get-post-put-delete\"><a href=\"#2-%EC%9E%90%EC%9B%90%EC%97%90-%EB%8C%80%ED%95%9C-%ED%96%89%EC%9C%84%EB%8A%94-http-method%EB%A1%9C-%ED%91%9C%ED%98%84%ED%95%A9%EB%8B%88%EB%8B%A4-get-post-put-delete\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 자원에 대한 행위는 HTTP METHOD로 표현합니다. (GET, POST, PUT DELETE)</h3>\n<ul>\n<li>URI에 자원의 행위에 대한 표현이 들어가지 않는 대신 HTTP METHOD를 통해 대신한다.</li>\n</ul>\n<pre class=\"language-null\"><code class=\"language-null\">   GET /users/321 321 ID를 가진 유저 정보를 가져오기\n   DELETE /users/321 321 ID를 가진 유저 정보를 삭제하기\n   POST /users 유저를 생성하기</code></pre>\n<table>\n<thead>\n<tr>\n<th align=\"center\">METHOD</th>\n<th align=\"center\">역할</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">POST</td>\n<td align=\"center\">POST를 통해 해당 URI를 요청하면 리소스를 생성합니다.</td>\n</tr>\n<tr>\n<td align=\"center\">GET</td>\n<td align=\"center\">GET를 통해 해당 리소스를 조회합니다. 리소스를 조회하고 해당 도큐먼트에 대한 자세한 정보를 가져온다.</td>\n</tr>\n<tr>\n<td align=\"center\">PUT</td>\n<td align=\"center\">PUT를 통해 해당 리소스를 수정합니다.</td>\n</tr>\n<tr>\n<td align=\"center\">PATCH</td>\n<td align=\"center\">PATCH를 통해 자원의 일부를 수정합니다.</td>\n</tr>\n<tr>\n<td align=\"center\">DELETE</td>\n<td align=\"center\">DELETE를 통해 리소스를 삭제합니다.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-슬래시-는-계층-관계를-나타내는데-사용합니다\"><a href=\"#3-%EC%8A%AC%EB%9E%98%EC%8B%9C-%EB%8A%94-%EA%B3%84%EC%B8%B5-%EA%B4%80%EA%B3%84%EB%A5%BC-%EB%82%98%ED%83%80%EB%82%B4%EB%8A%94%EB%8D%B0-%EC%82%AC%EC%9A%A9%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 슬래시 (/)는 계층 관계를 나타내는데 사용합니다.</h3>\n<pre class=\"language-null\"><code class=\"language-null\">   http://restapi.test.com/users/rooms\n   http://restapi.test.com/users/board</code></pre>\n<h3 id=\"4-uri-마지막은-슬래시를-사용하면-안됩니다\"><a href=\"#4-uri-%EB%A7%88%EC%A7%80%EB%A7%89%EC%9D%80-%EC%8A%AC%EB%9E%98%EC%8B%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>4. URI 마지막은 슬래시(/)를 사용하면 안됩니다.</h3>\n<pre class=\"language-null\"><code class=\"language-null\">   http://restapi.test.com/users/rooms/ [X]\n   http://restapi.test.com/users/rooms  [O]</code></pre>\n<h3 id=\"5-하이픈--은-uri의-가독성을-높이는데-사용합니다\"><a href=\"#5-%ED%95%98%EC%9D%B4%ED%94%88--%EC%9D%80-uri%EC%9D%98-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%84-%EB%86%92%EC%9D%B4%EB%8A%94%EB%8D%B0-%EC%82%AC%EC%9A%A9%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>5. 하이픈 (-)은 URI의 가독성을 높이는데 사용합니다.</h3>\n<ul>\n<li>불가피하게 긴 URI를 사용하게 될 경우 하이픈을 이용하여 가독성을 높입니다.</li>\n</ul>\n<h3 id=\"6-언더바_-혹은-밑줄은-uri에-사용하지-않습니다\"><a href=\"#6-%EC%96%B8%EB%8D%94%EB%B0%94_-%ED%98%B9%EC%9D%80-%EB%B0%91%EC%A4%84%EC%9D%80-uri%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>6. 언더바(_) 혹은 밑줄은 URI에 사용하지 않습니다.</h3>\n<ul>\n<li>밑줄은 보기 어렵거나 밑줄 때문에 문자가 가려지기도 합니다.</li>\n<li>그래서 대신 언더바를 사용하지 않고 하이픈을 이용합니다.</li>\n</ul>\n<h3 id=\"7-uri는-경로에는-소문자가-적합하다\"><a href=\"#7-uri%EB%8A%94-%EA%B2%BD%EB%A1%9C%EC%97%90%EB%8A%94-%EC%86%8C%EB%AC%B8%EC%9E%90%EA%B0%80-%EC%A0%81%ED%95%A9%ED%95%98%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>7. URI는 경로에는 소문자가 적합하다.</h3>\n<ul>\n<li>URI 경로에는 대문자 사용을 피해야합니다.</li>\n<li>대소문자에 따라 각자 다른 리소스로 인식하기 때문입니다.</li>\n<li>RFC3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정하기 때문이다.</li>\n</ul>\n<h3 id=\"8-파일-확장자는-uri에-포함하지-않는다\"><a href=\"#8-%ED%8C%8C%EC%9D%BC-%ED%99%95%EC%9E%A5%EC%9E%90%EB%8A%94-uri%EC%97%90-%ED%8F%AC%ED%95%A8%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>8. 파일 확장자는 URI에 포함하지 않는다.</h3>\n<ul>\n<li>REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않는다.</li>\n<li>Accept header를 사용한다.</li>\n</ul>\n<h3 id=\"9-리소스-간의-관계를-표현하는-방법\"><a href=\"#9-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EA%B0%84%EC%9D%98-%EA%B4%80%EA%B3%84%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>9. 리소스 간의 관계를 표현하는 방법</h3>\n<pre class=\"language-null\"><code class=\"language-null\">   GET : /users/{userid}/devices</code></pre>\n<p>이 규칙 중 가장 중요한 규칙은 아래 입니다.</p>\n<ul>\n<li><strong>첫 번째,</strong> URI는 정보의 자원을 표현해야 한다.</li>\n<li><strong>두 번째,</strong> 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.</li>\n</ul>\n<blockquote>\n<p> 좀 더 자세하게 확인하기 위해서는 다음 링크를 참고하면 좋습니다. <a href=\"https://meetup.toast.com/posts/92\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">LINK</a></p>\n</blockquote>\n<br/>\n## RESTful API란?\n<ul>\n<li>위에서 설명했던 REST를 REST답게 쓰기 위한 방법이지만 누군가가 공식적으로 발표한 것이 아니고\n그저 개발자들이 비공식적으로 의견을 제시한 것이라 명확한 정의는 없습니다.</li>\n<li>하지만 RESTful의 목적은 이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것입니다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>CRUD</th>\n<th>HTTP METHOD</th>\n<th>URI</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>user들을 표시</td>\n<td>GET</td>\n<td>/users</td>\n</tr>\n<tr>\n<td>user 하나만 표시</td>\n<td>GET</td>\n<td>/users/:id</td>\n</tr>\n<tr>\n<td>user를 생성</td>\n<td>POST</td>\n<td>/users</td>\n</tr>\n<tr>\n<td>user를 수정</td>\n<td>PUT</td>\n<td>/users:id</td>\n</tr>\n<tr>\n<td>user를 삭제</td>\n<td>DELETE</td>\n<td>/users:id</td>\n</tr>\n</tbody>\n</table>\n<p>잘못된 경우는 다음과 같습니다.</p>\n<ul>\n<li>Restful 하지 못한 경우</li>\n<li>CRUD 기능을 전부 POST METHOD로만 처리하는 API</li>\n<li>URI에 자원과 id외 정보가 들어가는 경우</li>\n</ul>\n<pre class=\"language-null\"><code class=\"language-null\">   PUT /users/update-nickname [X]\n   PUT /users/:id/nickname [O]</code></pre>\n<br/>\n<h2 id=\"http-응답-상태-코드\"><a href=\"#http-%EC%9D%91%EB%8B%B5-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>HTTP 응답 상태 코드</h2>\n<ul>\n<li>잘 설계된 REST API는 URI만 잘 설계된 것이 아닌 그 리소스에 대한 응답을 잘 내어주는 것까지 포함되어야 합니다. </li>\n<li>정확한 응답의 상태코드만으로도 많은 정보를 전달할 수가 있기 때문에 응답의 상태코드 값을 명확히 돌려주는 것은 생각보다 중요한 일이 될 수도 있습니다. </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">상태코드</th>\n<th align=\"center\">성공</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">200</td>\n<td align=\"center\">클라이언트의 요청을 정상적으로 수행함.</td>\n</tr>\n<tr>\n<td align=\"center\">201</td>\n<td align=\"center\">클라이언트에게 생성 작업을 요청 받았고, 생성 작업을 성공함.</td>\n</tr>\n<tr>\n<td align=\"center\">204</td>\n<td align=\"center\">요청은 성공 했지만 응답할 콘텐츠가 없음.</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">상태코드</th>\n<th align=\"center\">리다이렉션</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">301</td>\n<td align=\"center\">클라이언트가 요청한 리소스에 대한 URI가 영구적으로 변경되었을 때 사용함.</td>\n</tr>\n<tr>\n<td align=\"center\">302</td>\n<td align=\"center\">301과 같으나 임시적으로 주소가 바뀌었을 경우 사용함.</td>\n</tr>\n<tr>\n<td align=\"center\">304</td>\n<td align=\"center\">이전에 방문했을 때의 요청 결과와 다르지 않을 경우 사용함. 캐시된 페이지를 그대로 사용.</td>\n</tr>\n<tr>\n<td align=\"center\">307</td>\n<td align=\"center\">임시 페이지로 리다이렉트.</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">상태코드</th>\n<th align=\"center\">클라이언트 오류</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">400</td>\n<td align=\"center\">클라이언트가 올바르지 못한 요청을 보냄.</td>\n</tr>\n<tr>\n<td align=\"center\">401</td>\n<td align=\"center\">로그인을 하지 않아 페이지를 열 권한이 없음.</td>\n</tr>\n<tr>\n<td align=\"center\">403</td>\n<td align=\"center\">금지된 페이지, 로그인을 하든 안하든 접근할 수 없음. (관리자 페이지)</td>\n</tr>\n<tr>\n<td align=\"center\">404</td>\n<td align=\"center\">찾을 수 없는 페이지, 주소를 잘 못 입력했을 때 사용함.</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">403 대신에 사용할 수도 있음.(해커들의 공격을 방지하고자 페이지가 없는 것처럼 위장함)</td>\n</tr>\n<tr>\n<td align=\"center\">408</td>\n<td align=\"center\">요청 시간이 초과됨.</td>\n</tr>\n<tr>\n<td align=\"center\">409</td>\n<td align=\"center\">서버가 요청을 처리하는 과정에서 충돌이 발생한 경우. (회원가입 중 중복된 아이디인 경우)</td>\n</tr>\n<tr>\n<td align=\"center\">410</td>\n<td align=\"center\">영구적으로 사용할 수 없는 페이지.</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">상태코드</th>\n<th align=\"center\">서버 오류</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">501</td>\n<td align=\"center\">해당 요청을 처리하는 기능이 만들어지지 않음.</td>\n</tr>\n<tr>\n<td align=\"center\">502</td>\n<td align=\"center\">서버로 가능 요청이 중간에서 유실된 경우.</td>\n</tr>\n<tr>\n<td align=\"center\">503</td>\n<td align=\"center\">서버가 터졌거나 유지 보수 중<br/>(유지 보수 중일때는 유지 보수중이라는 것을 알려주는 페이지로 전송해주는 것이 좋음)</td>\n</tr>\n<tr>\n<td align=\"center\">504</td>\n<td align=\"center\">서버 게이트웨이에 문제가 생겨 시간 초과가 된 경우.</td>\n</tr>\n<tr>\n<td align=\"center\">505</td>\n<td align=\"center\">HTTP 버전이 달라 요청이 처리할 수 없음.</td>\n</tr>\n</tbody>\n</table>\n<br/>\n<h2 id=\"references\"><a href=\"#references\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>References</h2>\n<ul>\n<li><a href=\"https://velog.io/@stampid/REST-API%EC%99%80-RESTful-API\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">REST-API와-RESTful-API</a></li>\n<li><a href=\"https://meetup.toast.com/posts/92\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">REST API 제대로 알고 사용하기</a></li>\n<li><a href=\"https://sanghaklee.tistory.com/57\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RESTful API 설계 가이드</a></li>\n</ul>\n"}},{"node":{"title":"[Server] 토큰 기반 인증과 JWT","path":"/00-server-jwt/","date":"25. December 2020","timeToRead":10,"description":" 토큰 기반 인증과 JWT에 대해 알아보겠습니다. ","content":"<h1 id=\"jwt\"><a href=\"#jwt\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JWT</h1>\n<p>최근 업무에서 긴급 이슈가 있었는데, 그 자세한 내용을 설명할 수는 없으나 가장 큰 원인 중 하나는 토큰 이슈였습니다. 그에 따라 오늘 토큰 기반의 인증과 가장 유명한 JWT(Json Web Token)에 대해 정리해볼려고 합니다.</p>\n<br/>\n<h2 id=\"토큰token-기반-인증\"><a href=\"#%ED%86%A0%ED%81%B0token-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>토큰(Token) 기반 인증</h2>\n<p>토큰 기반의 인증은 모던 웹서비스에서 많이 사용됩니다. 특히 API를 사용하는 웹서비스를 개발해야한다면 토큰을 사용하는 방법이 가장 좋습니다.</p>\n<h3 id=\"기존-서버-기반-인증\"><a href=\"#%EA%B8%B0%EC%A1%B4-%EC%84%9C%EB%B2%84-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>기존 서버 기반 인증</h3>\n<p>기존의 서버 기반의 인증은 다음과 같은 구조를 가지고 있었습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103119059-06ada400-46b5-11eb-8e01-e1e841b40823.png\" alt=\"서버기반인증\"></p>\n<p>하지만 이러한 서버 기반의 인증은 다음과 같은 문제를 가집니다. (그러나 아직 사용하는 곳도 많습니다.)</p>\n<ul>\n<li>\n<p>세션</p>\n<ul>\n<li>유저가 인증을 할 때, 서버는 이 기록을 서버에 저장합니다. (= 세션)</li>\n<li>로그인 중인 유저가 늘어날 수록 서버의 램이 과부화됩니다. (DB에 저장하면 DB 성능의 무리가 오게됩니다.)</li>\n</ul>\n</li>\n<li>\n<p>확장성</p>\n<ul>\n<li>세션을 사용하는 경우에는 더 많은 트래픽을 감당하기 위해 여러개의 프로세스를 돌리거나, 여러 서버 컴퓨터를 추가하는 것이 어려워집니다.</li>\n</ul>\n</li>\n<li>\n<p>CORS(Cross-Origin Resource Sharing)</p>\n<ul>\n<li>일반적으로 쿠키는 단일 도메인 및 서브 도메인엣만 작동하도록 설계되어 있는데 이러한 쿠키를 여러 도메인에서 관리하는 것은 번거롭습니다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"토큰-기반-시스템의-작동-원리\"><a href=\"#%ED%86%A0%ED%81%B0-%EA%B8%B0%EB%B0%98-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>토큰 기반 시스템의 작동 원리.</h4>\n<p>토큰 기반 시스템은 <strong>stateless</strong>(상태를 유지하지 않음) 합니다. 이 덕분에 위에서 발생한 문제들이 해결됩니다.</p>\n<p>토큰 기반 시스템은 다음과 같이 작동합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103119347-4c1ea100-46b6-11eb-9a90-a7fab5edbc1b.png\" alt=\"토큰기반인증\"></p>\n<p>이를 순서로 나타내면 다음과 같습니다.</p>\n<ol>\n<li>유저가 <strong>로그인</strong>을 합니다.</li>\n<li>서버가 <strong>계정정보를 검증</strong>합니다.</li>\n<li>계정 정보가 정확한 경우, 서버측에서 <strong>signed 토큰을 발급</strong>해줍니다.</li>\n<li>클라이언트 측에서는 전달받은 <strong>토큰을 저장</strong>하고, 서버 <strong>요청마다 토큰을 함께 서버에 전달</strong>합니다.</li>\n<li>서버는 <strong>토큰을 검증</strong>하고 <strong>요청에 응답</strong>합니다.</li>\n</ol>\n<h3 id=\"토큰-기반-서비스를-선택하는-이유\"><a href=\"#%ED%86%A0%ED%81%B0-%EA%B8%B0%EB%B0%98-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>토큰 기반 서비스를 선택하는 이유.</h3>\n<p>일반적으로 토큰 기반의 인증 시스템은 다음의 장점을 가집니다.</p>\n<ul>\n<li>\n<p>Stateless 서버</p>\n<ul>\n<li>Stateful 서버 : 클라이언트에게 요청받을때마다, 클라이언트의 상태를 계속 유지합니다. 세션에 로그인 정보 등을 저장하고 계속 활용합니다.</li>\n<li><strong>Stateless 서버</strong> : 상태를 유지 하지 않는 서버. 상태정보를 저장하지 않고, 서버는 클라이언트측에서 들어오는 요청만으로 작업을 진행, 이 경우에는 클라이언트와 서버의 연결고리가 없으므로 <strong>서버의 확장성에서 장점</strong>을 가집니다.</li>\n</ul>\n</li>\n<li>\n<p>모바일 어플리케이션에 적합</p>\n<ul>\n<li>만약에 Android와 IOS에서 작동하는 어플리케이션을 개발할 때, 안전한 API를 만들기 위해서는 쿠키 등은 좋은 해결책이 될 수 없습니다. (쿠키 컨테이너를 사용해야하기 때문에...)</li>\n</ul>\n</li>\n<li>\n<p>인증정보를 다른 어플리케이션으로 전달</p>\n<ul>\n<li>대표적인 서비스로 OAuth 등이 있습니다. 구글이나 페이스북, 카카오톡, 네이버와 같은 소셜 계정을 통해 다른 웹서비스에서도 로그인 가능합니다.</li>\n</ul>\n</li>\n<li>\n<p>보안</p>\n<ul>\n<li>토큰 기반의 인증을 통해서 어플리케이션의 보안을 높일 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"토큰-기반-서비스의-장점\"><a href=\"#%ED%86%A0%ED%81%B0-%EA%B8%B0%EB%B0%98-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>토큰 기반 서비스의 장점.</h3>\n<p>따라서 토큰 기반의 서비스는 다음과 같은 장점을 가집니다.</p>\n<ul>\n<li>\n<p>무상태이며 확장성을 가짐</p>\n<ul>\n<li>기존에 설명한 것처럼 많은 리소스 소모를 줄일 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>보안성</p>\n<ul>\n<li>쿠키를 사용하지 않으므로 쿠키 취약점을 방지할 수 있습니다.</li>\n<li>다만 토큰도 취약점이 존재합니다.</li>\n</ul>\n</li>\n<li>\n<p>확장성(Extensibility)</p>\n<ul>\n<li>토큰을 통해 다른 서비스에 권한을 공유함으로서 사업이나 분야를 확장할 수 있습니다.</li>\n<li>토큰에 선택적인 권한만 부여하여 발급할 수도 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>여러 플랫폼 및 도메인</p>\n<ul>\n<li>토큰만 유효하다면 여러 플랫폼과 도메인에서 사용할 수 있습니다.</li>\n<li>서버측 어플리케이션 응답부분에 다음 헤더만 포함하면 <code class=\"language-text\">Access-Control-Allow-Origin: *</code> 서버에서는 쉽게 정리할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>웹 표준 기반</p>\n<ul>\n<li>JWT는 웹 표준에 등록되어 있기 때문에 여러 환경에서 지원이 됩니다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"jwtjson-web-token\"><a href=\"#jwtjson-web-token\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JWT(Json Web Token)</h2>\n<p>그렇다면 메인 디쉬인 JWT(Json Web Token)에 대해 이야기를 해보겠습니다.</p>\n<p><strong>JWT(JSON Web Token)</strong> 은 웹표준(RFC 7519)으로 두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적인 (self-contained) 방식으로 정보를 안정성 있게 전달합니다.</p>\n<p>JSON은 다음과 같은 특징을 유지합니다.</p>\n<ul>\n<li>수많은 프로그래밍 언어에서 지원됩니다. (대부분의 주류 프로그래밍 언어에서 지원)</li>\n<li>\n<p>자가 수용적 (self-contained)</p>\n<ul>\n<li>JWT는 필요한 모든 정보를 가지고 있습니다.</li>\n<li>토큰, 토큰에 대한 기본정보, 전달할 정보, signature 등을 가지고 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>쉽게 전달 될 수 있습니다.</p>\n<ul>\n<li>JWT는 자가수용적으로 두 개체 사이에서 손쉽게 전달된다.</li>\n<li>웹 서버의 경우 HTTP의 헤더에 넣어서 전달할 수 있고, ULR의 파라미터로도 전달 가능합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jwt의-정의\"><a href=\"#jwt%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JWT의 정의</h3>\n<p>JWT는 <code class=\"language-text\">.</code> 을 구분자로 3가지의 문자열로 되어있습니다. 구조는 다음과 같이 이루어졌습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/103124452-24860380-46cb-11eb-827e-b1d02001516f.png\" alt=\"jwt\"></p>\n<p>JWT 토큰을 만들때는 JWT를 담당하는 라이브러리가 자동으로 인코딩 및 해싱 작업을 해줍니다.</p>\n<h4 id=\"헤더\"><a href=\"#%ED%97%A4%EB%8D%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>헤더</h4>\n<p><strong>Header</strong>는 <strong>typ</strong>과 <strong>alg</strong> 의 두가지 정보를 지니고 있습니다.</p>\n<ul>\n<li><strong>typ</strong> : 토큰의 타입을 지정 - JWT</li>\n<li><strong>alg</strong> : 해싱 알고리즘을 지정 - HMAC SHA256이나 RSA가 주로 사용, signature에서 사용</li>\n</ul>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"typ\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"JWT\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"alg\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"HS256\"</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>인코딩에 대한 코드 예시입니다.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> header <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">typ</span><span class=\"token operator\">:</span> <span class=\"token string\">'JWT'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">alg</span><span class=\"token operator\">:</span> <span class=\"token string\">'HS256'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// encode to base64</span>\n<span class=\"token keyword\">const</span> encodedPayload <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Buffer</span><span class=\"token punctuation\">(</span><span class=\"token known-class-name class-name\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">stringify</span><span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token method function property-access\">toString</span><span class=\"token punctuation\">(</span><span class=\"token string\">'base64'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token method function property-access\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'='</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span></code></pre>\n<h4 id=\"정보payload\"><a href=\"#%EC%A0%95%EB%B3%B4payload\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>정보(payload)</h4>\n<p><strong>payload</strong> 부분에는 토큰에 담을 정보가 있습니다. 여기에 담는 정보의 한 조각을 클레임(<strong>claim</strong>) 이라고 부르며, 이는 <code class=\"language-text\">name/value</code>의 한쌍으로 이뤄져 있습니다.</p>\n<p>클레임은 크게 3가지(등록-registered, 공개-public, 비공개-private)로 분류됩니다.</p>\n<h5 id=\"1-등록된-registered클레임\"><a href=\"#1-%EB%93%B1%EB%A1%9D%EB%90%9C-registered%ED%81%B4%EB%A0%88%EC%9E%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 등록된 (registered)클레임</h5>\n<p>등록된 클레임들은 이름이 이미 정해진 클레임이며, 모두 선택적입니다.</p>\n<ul>\n<li><code class=\"language-text\">iss</code> : 토큰 발급자 (issuer)</li>\n<li><code class=\"language-text\">sub</code> : 토큰 제목 (subject)</li>\n<li><code class=\"language-text\">aud</code> : 토큰 대상자 (audience)</li>\n<li><code class=\"language-text\">exp</code> : 토큰의 만료시간 (expiration), NumericDate</li>\n<li><code class=\"language-text\">nbf</code> : 토큰 활성 날짜</li>\n<li><code class=\"language-text\">iat</code> : 토큰이 발급된 시간, 나이를 확인할 수 있습니다.</li>\n<li><code class=\"language-text\">jti</code> : JWT의 고유 식별자, 중복처리를 방지하기 위해서 사용합니다.</li>\n</ul>\n<h5 id=\"2-공개-public-클레임\"><a href=\"#2-%EA%B3%B5%EA%B0%9C-public-%ED%81%B4%EB%A0%88%EC%9E%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 공개 (public) 클레임</h5>\n<p>공개 클레임들은 충돌이 방지된 이름을 가지고 있습니다. 일반적으로 충돌을 막기 위해 클레임을 URI 형식으로 짓습니다.</p>\n<h5 id=\"3-비공개-private-클레임\"><a href=\"#3-%EB%B9%84%EA%B3%B5%EA%B0%9C-private-%ED%81%B4%EB%A0%88%EC%9E%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 비공개 (private) 클레임</h5>\n<p>등록된 클레임도 아니고 공개된 클레임이 아닙니다. 일반적으로 서버 협의에 사용되는 클레임입니다.</p>\n<p>예제 payload는 다음과 같습니다.</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"iss\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"github.com\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"https://Azderica.github.io/is_admin\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token property\">\"username\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Azderica\"</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>마찬가지로 위의 코드처럼 encode 할 수 있습니다.</p>\n<h4 id=\"서명signature\"><a href=\"#%EC%84%9C%EB%AA%85signature\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서명(signature)</h4>\n<p>JSON Web Token의 마지막 부분은 서명(signature)입니다. 서명은 헤더의 인코딩 값과 정보의 인코딩 값을 합쳐서 주어진 비밀키로 해쉬를 하여 생성</p>\n<p>서명 부분을 만드는 슈도코드(pseudocode)의 구조는 다음과 같습니다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code></pre>\n<p>이렇게 만든 해쉬를 <code class=\"language-text\">base64</code> 형태로 나타냅니다.</p>\n<h3 id=\"jwt는-언제-사용하지\"><a href=\"#jwt%EB%8A%94-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JWT는 언제 사용하지?</h3>\n<ul>\n<li>\n<p>회원 인증</p>\n<ul>\n<li>JWT를 사용하는 가장 흔한 시나리오입니다.</li>\n<li>유저가 로그인 시, 서버는 유저의 정보에 기반한 토큰을 발급하여 유저에게 전달하고 이후 요청시 JWT를 포함하여 전달합니다.</li>\n<li>서버측에서 유저의 세션을 유지할 필요가 없어서 리소스를 아낄 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>정보 교류</p>\n<ul>\n<li>JWT는 두 개체 사이에서 안정성있게 정보를 교환하기에 좋은 방법</li>\n<li>정보가 sign이 되어있기 때문에 정보가 조작되지 않았는지를 검증할 수 있음.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>토큰 기반의 인증 시스템과 JWT에 대해 알아보았습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://velopert.com/2350\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velopert.com/2350</a></li>\n<li><a href=\"https://velopert.com/2389\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velopert.com/2389</a></li>\n<li><a href=\"http://www.opennaru.com/opennaru-blog/jwt-json-web-token/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://www.opennaru.com/opennaru-blog/jwt-json-web-token/</a></li>\n</ul>\n"}}]}}},"context":{}}