{"hash":"409256f0cf4ba53e53b5c32326d49aab3f1f64f3","data":{"tag":{"title":"CleanCode","belongsTo":{"edges":[{"node":{"title":"[Review] Clean Code 내용정리 - 1","path":"/01-clean-code/","date":"6. November 2020","timeToRead":7,"description":" Clean code 책 정리 1편입니다. ","content":"<h1 id=\"clean-code-내용-정리---1\"><a href=\"#clean-code-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC---1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Clean Code 내용 정리 - 1</h1>\n<p>대학시절 프런트 개발을 하다가, ebay에서 웹 개발을 하면서 백엔드 개발을 주로 하다 보니, Java나 C#으로 개발을 주로 하게 되었는데, 모르는 부분도 많고 함께 프로젝트를 만들기 때문에 좀 더 좋은 개발을 하고 싶어서, 1년 전에 샀던 책을 다시 펴서 정리한다.</p>\n<h2 id=\"1장-clean-code\"><a href=\"#1%EC%9E%A5-clean-code\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1장. Clean Code</h2>\n<p><strong>나쁜 코드가 만드는 결과</strong></p>\n<ul>\n<li>개발 속도의 감소</li>\n<li>팀 생산성의 하락, 이후 재개발 필요</li>\n<li>유지 보수의 어려움</li>\n</ul>\n<h3 id=\"깨끗한-코드란\"><a href=\"#%EA%B9%A8%EB%81%97%ED%95%9C-%EC%BD%94%EB%93%9C%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>깨끗한 코드란?</h3>\n<ul>\n<li>모든 테스트를 통과</li>\n<li>중복이 없음</li>\n<li>시스템 내 모든 설계 아이디어를 표현함</li>\n<li>클래스, 메서드, 함수 등을 최대한 줄임</li>\n</ul>\n<h2 id=\"2장-의미-있는-이름\"><a href=\"#2%EC%9E%A5-%EC%9D%98%EB%AF%B8-%EC%9E%88%EB%8A%94-%EC%9D%B4%EB%A6%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2장. 의미 있는 이름</h2>\n<p>핵심은 다음과 같다.</p>\n<ol>\n<li>\n<p>의도를 분명히 밝히기.</p>\n<ul>\n<li>ex) <code class=\"language-text\">int elapsedTimeInDays</code>, <code class=\"language-text\">daysSinceCreation</code> 등등</li>\n</ul>\n</li>\n<li>\n<p>그릇된 정보를 피하기.</p>\n<ul>\n<li>일관성을 지켜야한다.</li>\n</ul>\n</li>\n<li>의미 있게 구분하기.</li>\n<li>발음하기 쉬운 이름을 사용하기.</li>\n<li>검색하기 쉬운 이름을 사용하기.</li>\n<li>\n<p>인코딩을 피하기.</p>\n<ul>\n<li>헝가리식 표기법</li>\n<li>멤버 변수 접두어</li>\n<li>인터페이스 클래스와 구현 클래스</li>\n</ul>\n</li>\n<li>자신의 기억력을 자랑하지 말기.</li>\n<li>클래스 이름은 명사나 명사구.</li>\n<li>메서드 이름은 동사나 동사구.</li>\n<li>기발한 이름을 피하기</li>\n<li>한 개념에 한 단어 사용</li>\n<li>말장난하지 말기</li>\n<li>\n<p>해법 영역에서 가져온 이름 사용하기</p>\n<ul>\n<li>전산, 알고리즘, 패턴, 수학 용어들은 사용해도 괜찮다.</li>\n</ul>\n</li>\n<li>\n<p>문제 영역에서 가져온 이름 사용하기</p>\n<ul>\n<li>적절한 프로그래머 용어가 없다면, 문제 영역에서 가져온다.</li>\n</ul>\n</li>\n<li>\n<p>의미 있는 맥락을 추가</p>\n<ul>\n<li>스스로 의미가 분명하게 해 주기. -> 클래스, 함수, 이름 공간에 넣어 맥락 주기</li>\n<li>모든 방법이 어렵다면 접두어 사용하기</li>\n</ul>\n</li>\n<li>불필요한 맥락 없애기.</li>\n</ol>\n<p>핵심 중 하나는, 좋은 이름을 선택하려면 설명 능력이 뛰어나야 하고, 문화적인 배경이 같아야 한다.</p>\n<h2 id=\"3장-함수\"><a href=\"#3%EC%9E%A5-%ED%95%A8%EC%88%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3장. 함수</h2>\n<p>함수의 규칙은 다음과 같다.</p>\n<ol>\n<li>\n<p>작게 만들기</p>\n<ul>\n<li>일반적으로 2줄, 3줄, 4줄이 이상적으로 좋다.</li>\n<li>\n<p>블록과 들여 쓰기.</p>\n<ul>\n<li>if/else/while 문 등에 들어가는 블록은 한 줄이여야 함.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>한 가지만 하기</p>\n<ul>\n<li><strong>함수는 한 가지를 해야 하고 한 가지를 잘해야 한다.</strong></li>\n</ul>\n</li>\n<li>\n<p>함수 당 추상화 수준은 하나로</p>\n<ul>\n<li>한 함수에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈림</li>\n<li>\n<p><strong>내려가기 규칙</strong> : 위에서 아래로 코드 읽기</p>\n<ul>\n<li>마치 이야기처럼</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Switch 문</p>\n<ul>\n<li>\n<p>다형성 사용해서 최대한 숨기고 반복하지 않게 하기.</p>\n<ul>\n<li>객체 안에서 숨기기</li>\n<li>최대한 한 번만 사용하기</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>서술적인 이름 사용</p>\n<ul>\n<li>서술적인 이름이 설계에서 더 뚜렷한 의미를 가지고 개선하기 쉬워짐</li>\n<li>일관성 유지하기</li>\n</ul>\n</li>\n<li>\n<p>함수 인수</p>\n<ul>\n<li>함수에서 이상적인 인수는 0개이다.</li>\n<li>\n<p>1개(단항), 2개(이항)까지고 좋고, 3개(삼항)는 가능한 피하고, 4개(다항)는 이유가 필요하다.</p>\n<ul>\n<li>점점 더 읽기 어려워짐.</li>\n<li><code class=\"language-text\">includeSetupPageInfo(new PageContent)</code> 보다는 <code class=\"language-text\">includeSetupPage()</code>가 더 읽기 좋음</li>\n<li>\n<p>단항 형식의 좋은 예</p>\n<ul>\n<li><code class=\"language-text\">boolean fileExists(&quot;MyFile&quot;)</code></li>\n</ul>\n</li>\n<li>\n<p>이항 함수의 좋은 예</p>\n<ul>\n<li><code class=\"language-text\">Point p = new Point(0, 0)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>동사와 키워드</p>\n<ul>\n<li>함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수가 필수</li>\n<li>\n<p>단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.</p>\n<ul>\n<li>ex) <code class=\"language-text\">writeField(name)</code> 등</li>\n<li><code class=\"language-text\">assertEquals</code>보다는 <code class=\"language-text\">assertExpectedEqualsActual(expected, actual)</code> 이 더 좋다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>부수 효과를 일으키지 마라</p>\n<ul>\n<li>즉, 함수에서 한 가지를 하겠다고 하고, 다른 기능을 넣지 마라</li>\n<li>\n<p>출력 인수</p>\n<ul>\n<li>일반적으로는 출력 인수를 피해라.</li>\n<li><code class=\"language-text\">appendFooter(s)</code> 보다는 <code class=\"language-text\">report.appendFooter()처럼</code> 작성하기.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>명령과 조회를 분리하기</p>\n<ul>\n<li>함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>오류 코드보다 예외를 사용하라</strong></p>\n<ul>\n<li>명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.</li>\n<li>\n<p>Try/Catch 블록 뽑아내기.</p>\n<ul>\n<li>흉측함, 별도 함수로 뽑아내는 편이 좋다.</li>\n</ul>\n</li>\n<li>\n<p>오류 처리도 한 가지 작업</p>\n<ul>\n<li>오류 처리도 오류만 처리해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>오류 클래스를 따로 선언하면, 해당 클래스는 의존성 자석이 되기 때문에 다른 코드에서 import 해서 사용해야 한다.</p>\n<ul>\n<li>즉, 오류 클래스가 변한다면 클래스 전부를 다시 컴파일하고 다시 배치해야 한다.</li>\n<li>따라서 일반적으로는 예외를 사용하기</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>반복하지 말기</p>\n<ul>\n<li>AOP(Aspect Oriented Programming), COP(Component Oriented Programming) 등 모두가 어떤 면에서는 <strong>중복 제거 전략</strong>이 들어간다.</li>\n</ul>\n</li>\n<li>\n<p>구조적 프로그래밍</p>\n<ul>\n<li>모든 함수와 함수 내 모든 블록에 <strong>입구와 출구가 하나만 존재해야 한다</strong></li>\n<li>루프 안에서 break나 continue를 사용해서는 안된다. goto는 아시다시피 절대로 안됨</li>\n<li>해당 문제는 함수가 아주 클 때 상당한 이익을 제공.</li>\n</ul>\n</li>\n<li>\n<p>함수는 짜는 방법</p>\n<ul>\n<li>일종의 글짓기와 비슷</li>\n<li>초안은 길고 복잡할 수 있지만,<br>\n수정하면서 코드를 다듬고 함수를 만들고, 이름을 바꾸고 중복을 제거하고 메서드를 제거하기</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"결론\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>결론</h3>\n<p>모든 시스템은 특정 응용 분야 시스템을 기술할 목적으로 프로그래머가 설계한 DSL(Domain Specific Language, 도메인 특화 언어)로 만든다. 이러한 기술 들은 함수를 잘 만드는 방법이다. 그러나 정말로 중요한 것은 <strong>시스템이다.</strong></p>\n"}},{"node":{"title":"[Review] Clean Code 내용정리 - 3","path":"/03-clean-code/","date":"6. November 2020","timeToRead":11,"description":" Clean code 책 정리 3편입니다. ","content":"<h1 id=\"clean-code-내용-정리---3\"><a href=\"#clean-code-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC---3\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Clean Code 내용 정리 - 3</h1>\n<h2 id=\"7장-오류-처리\"><a href=\"#7%EC%9E%A5-%EC%98%A4%EB%A5%98-%EC%B2%98%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>7장. 오류 처리</h2>\n<p>깨끗한 코드와 오류 처리는 연관성이 존재한다.</p>\n<h3 id=\"오류-코드보다-예외를-사용하기\"><a href=\"#%EC%98%A4%EB%A5%98-%EC%BD%94%EB%93%9C%EB%B3%B4%EB%8B%A4-%EC%98%88%EC%99%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>오류 코드보다 예외를 사용하기</h3>\n<p>오류가 발생 시 예외를 던지는 방법이 논리와 오류 처리 코드가 뒤섞이지 않아 코드가 더 깔끔해진다.</p>\n<h3 id=\"try-catch-finally-문부터-작성하기\"><a href=\"#try-catch-finally-%EB%AC%B8%EB%B6%80%ED%84%B0-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Try-Catch-Finally 문부터 작성하기</h3>\n<p>예외가 발생할 코드를 짤 경우에는 try-catch-finally 문으로 시작하는 것이 좋다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">RecordedGrip</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">retrieveSection</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> sectionName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">FileInputStream</span> stream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span>sectionName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StorageException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"retrieval error\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">RecordedGrip</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"미확인unchecked-예외를-사용하기\"><a href=\"#%EB%AF%B8%ED%99%95%EC%9D%B8unchecked-%EC%98%88%EC%99%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>미확인(unchecked) 예외를 사용하기</h3>\n<p>확인된 예외는 몇 가지 장점을 제공하지만, 반드시 필요하지는 않다.</p>\n<ul>\n<li>확인된 오류가 치르는 비용에 대해서 잘 생각해보아야 한다.</li>\n<li>확인된 예외는 OCP(Open Closed Principle)를 위반한다.</li>\n<li>Ex) 확인된 예외를 던졌으나, catch가 세 단계 위에 있다면 모든 선언부에 예외가 필요하다. 대규모 시스템에서는 힘들다.</li>\n</ul>\n<h3 id=\"예외에-의미를-제공하기\"><a href=\"#%EC%98%88%EC%99%B8%EC%97%90-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EC%A0%9C%EA%B3%B5%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>예외에 의미를 제공하기</h3>\n<ul>\n<li>예외를 던질 때 전후 상황을 충분히 덧붙일 때, 오류가 발생한 원인과 위치를 찾을 수 있다.</li>\n<li>\n<p>오류 메시지에 정보(실패한 연산 이름, 실패 유형)등을 함께 던진다.</p>\n<ul>\n<li>로깅 기능을 통해 충분한 정보를 제공하자.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"호출자를-고려해-예외-클래스를-정의하기\"><a href=\"#%ED%98%B8%EC%B6%9C%EC%9E%90%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%B4-%EC%98%88%EC%99%B8-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>호출자를 고려해 예외 클래스를 정의하기</h3>\n<p>오류를 잡아내는 다양한 방법이 존재한다.</p>\n<ul>\n<li>외부 API를 사용할 때는 감싸기 기법을 사용하는 것은 좋은 방법이다.</li>\n<li>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">LocalPort</span> port <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LocalPort</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  port<span class=\"token punctuation\">.</span><span class=\"token keyword\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">PortDeviceFailure</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">reportError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  logger<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li>예외 클래스가 하나만 있어도 되는 경우가 많다.</li>\n<li>더 나아가, 한 예외는 잡아내고 다른 예외는 무시해도 되는 경우에는 여러 예외 케이스를 사용하는 것도 방법이다.</li>\n</ul>\n<h3 id=\"정상-흐름을-정의하기\"><a href=\"#%EC%A0%95%EC%83%81-%ED%9D%90%EB%A6%84%EC%9D%84-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>정상 흐름을 정의하기</h3>\n<p>특수 사례 패턴을 사용하기</p>\n<ul>\n<li>클래스나 객체로 예외적인 상황을 캡슐화하여 처리할 수 있음</li>\n</ul>\n<h3 id=\"null을-반환하지-말기\"><a href=\"#null%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%98%EC%A7%80-%EB%A7%90%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>null을 반환하지 말기</h3>\n<p>null에 대한 과한 확인은 문제가 될 수 있다. 즉, 예외나 <strong>특수 사례 패턴</strong>이 더 좋은 경우가 많다.</p>\n<h3 id=\"null을-전달하지-말기\"><a href=\"#null%EC%9D%84-%EC%A0%84%EB%8B%AC%ED%95%98%EC%A7%80-%EB%A7%90%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>null을 전달하지 말기</h3>\n<p>인수에 null이 넘어가지 않는 정책이 있다면, 많은 실수를 줄일 수 있다.</p>\n<h3 id=\"결론\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>결론.</h3>\n<ul>\n<li>깨끗한 코드는 읽기도 좋아야 하지만, <strong>안정성</strong>도 높아야 한다.</li>\n<li>오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드 작성이 가능</li>\n</ul>\n<h2 id=\"8장-경계\"><a href=\"#8%EC%9E%A5-%EA%B2%BD%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>8장. 경계</h2>\n<p>시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물다.</p>\n<h3 id=\"외부-코드-사용하기\"><a href=\"#%EC%99%B8%EB%B6%80-%EC%BD%94%EB%93%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>외부 코드 사용하기</h3>\n<p>인터페이스 제공자와 사용자 사이에는 이해관계가 들어간다. 제공자는 최대한 적용성을 늘리기를 원하지만, 사용자는 자신의 요구에 집중하는 인터페이스를 희망한다.</p>\n<p>즉, <code class=\"language-text\">Map</code>과 같은 <code class=\"language-text\">경계 인터페이스를</code> 사용할 때는 이용하는 클래스나 계열 밖으로 노출되지 않도록 주의해야 한다.(캡슐화도 한 방법)</p>\n<h3 id=\"경계를-살피고-익히기\"><a href=\"#%EA%B2%BD%EA%B3%84%EB%A5%BC-%EC%82%B4%ED%94%BC%EA%B3%A0-%EC%9D%B5%ED%9E%88%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>경계를 살피고 익히기</h3>\n<ul>\n<li>외부 코드를 사용하면 적은 시간에 많은 기능을 넣을 수 있는 장점이 존재.</li>\n<li>\n<p>그러나, 테스트를 해서 진행하는 방법이 바람직하다.</p>\n<ul>\n<li>이러한 간단한 테스트 케이스를 사용해 익히는 방법을 <strong>학습 테스트라고</strong> 부른다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"log4j-익히기\"><a href=\"#log4j-%EC%9D%B5%ED%9E%88%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>log4j 익히기</h3>\n<p>로깅을 직접 구현하기보다는 아파치의 log4j 패키지를 사용하자.</p>\n<p>간단한 예시 코드는 다음과 같다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LogTest</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">Logger</span> logger<span class=\"token punctuation\">;</span>\n\n  <span class=\"token annotation punctuation\">@Before</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initialize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    logger <span class=\"token operator\">=</span> <span class=\"token class-name\">Logger</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLogger</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"logger\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    logger<span class=\"token punctuation\">.</span><span class=\"token function\">removeAllApenders</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Logger</span><span class=\"token punctuation\">.</span><span class=\"token function\">getRootLogger</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">removeAllAppenders</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@Test</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">basicLogger</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">BasicConfigurator</span><span class=\"token punctuation\">.</span><span class=\"token function\">configure</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"basicLogger\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@Test</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addAppenderWithStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    logger<span class=\"token punctuation\">.</span><span class=\"token function\">addAppender</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ConsoleAppender</span><span class=\"token punctuation\">(</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">PatternLayout</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%p %t %m%n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token class-name\">ConsoleAppender</span><span class=\"token punctuation\">.</span>SYSTEM_OUT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"addAppenderWithStream\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@Test</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addAppenderWithoutSteam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    logger<span class=\"token punctuation\">.</span><span class=\"token function\">addAppender</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ConsoleAppender</span><span class=\"token punctuation\">(</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">PatternLayout</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%p %t %m%n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"addAppenderWithoutStream\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"학습-테스트는-공짜-이상\"><a href=\"#%ED%95%99%EC%8A%B5-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%EA%B3%B5%EC%A7%9C-%EC%9D%B4%EC%83%81\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>학습 테스트는 공짜 이상</h3>\n<ul>\n<li>학습 테스트에 드는 비용은 없으며, 필요한 지식만 확보하는 손쉬운 방법</li>\n<li>투자하는 노력보다 얻는 성과가 더 크다</li>\n<li>패키지가 새 버전이 나오면 학습 테스트를 돌려 예상대로 나오는지 체크한다.</li>\n</ul>\n<h3 id=\"아직-존재하지-않는-코드를-사용하기\"><a href=\"#%EC%95%84%EC%A7%81-%EC%A1%B4%EC%9E%AC%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>아직 존재하지 않는 코드를 사용하기</h3>\n<ul>\n<li>아는 코드와 모르는 코드(미완성 코드)를 분리하기</li>\n<li>바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제할 수 있다는 장점을 얻을 수 있음.</li>\n<li>이러한 설계는 테스트에서도 편하다.</li>\n</ul>\n<h3 id=\"깨끗한-경계\"><a href=\"#%EA%B9%A8%EB%81%97%ED%95%9C-%EA%B2%BD%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>깨끗한 경계</h3>\n<p>경계에서는 다양한 문제가 발생할 수 있다.</p>\n<p>따라서.</p>\n<ul>\n<li>통제 못하는 코드를 사용하는 경우에는 비용이 적게 구성해야 한다.</li>\n<li>경계에 위치한 코드는 깔끔하게 분리한다.</li>\n<li>외부 패키지에 의존하는 대신, 통제 가능한 우리 코드에 의존한다</li>\n<li>외부 패키지 호출 코드를 가능한 줄여서 경계를 관리한다</li>\n</ul>\n<h2 id=\"9장-단위-테스트\"><a href=\"#9%EC%9E%A5-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>9장. 단위 테스트</h2>\n<p>제대로 된 테스트가 필요하다.</p>\n<h3 id=\"tdd-법칙-세가지\"><a href=\"#tdd-%EB%B2%95%EC%B9%99-%EC%84%B8%EA%B0%80%EC%A7%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>TDD 법칙 세가지</h3>\n<ol>\n<li>실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않다.</li>\n<li>컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.</li>\n<li>현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.</li>\n</ol>\n<p>위 규칙을 잘 지키면, 테스트 코드와 실제 코드가 같이 나온다.</p>\n<h3 id=\"깨끗한-테스트-코드-유지하기\"><a href=\"#%EA%B9%A8%EB%81%97%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>깨끗한 테스트 코드 유지하기</h3>\n<p>코드가 망가지기 시작하면 망가진다. 따라서, 테스트 코드는 실제 코드 못지않게 중요하게 짜야한다.</p>\n<h4 id=\"테스트는-유연성-유지보수성-재사용성을-제공한다\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%EC%9C%A0%EC%97%B0%EC%84%B1-%EC%9C%A0%EC%A7%80%EB%B3%B4%EC%88%98%EC%84%B1-%EC%9E%AC%EC%82%AC%EC%9A%A9%EC%84%B1%EC%9D%84-%EC%A0%9C%EA%B3%B5%ED%95%9C%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>테스트는 유연성, 유지보수성, 재사용성을 제공한다.</h4>\n<ul>\n<li>단위 테스트는 코드에 유연성, 유지보수성, 재사용성을 제공하는 기둥이 된다.</li>\n<li>테스트 케이스가 있다면 많은 공포를 해결할 수 있다.</li>\n<li>테스트 코드가 지저분해질수록 실제 코드도 지저분해진다.</li>\n</ul>\n<h3 id=\"깨끗한-테스트-코드\"><a href=\"#%EA%B9%A8%EB%81%97%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>깨끗한 테스트 코드</h3>\n<ul>\n<li>가독성 : 명료성, 단순성, 풍부한 표현력</li>\n</ul>\n<h4 id=\"도메인에-특화된-테스트-언어\"><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8%EC%97%90-%ED%8A%B9%ED%99%94%EB%90%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%96%B8%EC%96%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>도메인에 특화된 테스트 언어</h4>\n<ul>\n<li>도메인에 특화된 언어(DSL)도 좋은 방법이다.</li>\n</ul>\n<h4 id=\"이중-표준\"><a href=\"#%EC%9D%B4%EC%A4%91-%ED%91%9C%EC%A4%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>이중 표준</h4>\n<ul>\n<li>단순, 간결, 표현력이 풍부, 그러나 꼭 효율적인 필요는 없다.</li>\n</ul>\n<h3 id=\"테스트-당-assert-하나\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8B%B9-assert-%ED%95%98%EB%82%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>테스트 당 assert 하나</h3>\n<ul>\n<li>Assert 문은 하나가 좋지만, 때로는 여러 개를 써도 된다. (단, 최대한 줄여야 한다.)</li>\n</ul>\n<blockquote>\n<p>Tip) Assert문.</p>\n<p>정해진 조건에 맞지 않을 때 프로그램을 중단. ex) assert(표현식)</p>\n</blockquote>\n<ul>\n<li><strong>테스트 함수마다 한 개념만 테스트</strong></li>\n</ul>\n<h3 id=\"first\"><a href=\"#first\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>F.I.R.S.T</h3>\n<ul>\n<li>Fast(빠르게) : 테스트는 빠르게 돌아야 한다.</li>\n<li>Independent(독립적으로) : 각 테스트는 서로 의존하면 안 된다.</li>\n<li>Repeatable(반복 가능하게) : 테스트는 어떤 환경에서도 반복 가능해야 한다.</li>\n<li>Self-Validating(자가 검증하는) : 테스트는 부울(bool) 값으로 결과를 내야 한다.</li>\n<li>Timely(적시에) : 테스트는 적시에 작성해야 한다.</li>\n</ul>\n<h3 id=\"결론-1\"><a href=\"#%EA%B2%B0%EB%A1%A0-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>결론</h3>\n<ul>\n<li>테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화해야 한다.</li>\n<li>도메인 특화 언어(DSL, Domain Specific Language)를 구성하면 테스트 코드가 짜기 쉬워진다.</li>\n</ul>\n<h2 id=\"10장-클래스\"><a href=\"#10%EC%9E%A5-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>10장. 클래스</h2>\n<h3 id=\"클래스-체계\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B2%B4%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>클래스 체계</h3>\n<p>추상화 단계는 순차적으로 내려간다.</p>\n<ul>\n<li>public, private, 비공개 인스턴스 변수 순으로 진행된다.</li>\n</ul>\n<h4 id=\"캡슐화\"><a href=\"#%EC%BA%A1%EC%8A%90%ED%99%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>캡슐화</h4>\n<p>꼭 유지해야 하는 것은 아니나, 캡슐화를 푸는 방법은 최후의 수단입니다.</p>\n<h3 id=\"클래스는-작아야-한다\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%9E%91%EC%95%84%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>클래스는 작아야 한다.</h3>\n<p>하나의 클래스는 적은 책임을 얻어야 한다.</p>\n<p>즉, 클래스 설명은 if, and, or, but 등의 단어를 제외하고 25 단어 내외로 가능해야 한다.</p>\n<h4 id=\"단일-책임-원칙srp-single-responsibility-principle\"><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99srp-single-responsibility-principle\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단일 책임 원칙(SRP, Single Responsibility Principle)</h4>\n<ul>\n<li>클래스나 모듈을 변경할 이유가 하나뿐이어야 한다는 원칙.</li>\n<li>객체 지향 설계에서 더우 중요한 개념이다.</li>\n</ul>\n<h4 id=\"응집도\"><a href=\"#%EC%9D%91%EC%A7%91%EB%8F%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>응집도</h4>\n<ul>\n<li>클래스는 인스턴스 변수 수가 적어야 한다.</li>\n<li>각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.</li>\n<li>'함수를 작게, 매개변수 목록을 짧게'라는 전략으로 진행하고, 응집도가 높아지도록 새로운 클래스로 분리한다.</li>\n</ul>\n<h4 id=\"응집도를-유지하면-작은-클래스-여럿으로-구성된다\"><a href=\"#%EC%9D%91%EC%A7%91%EB%8F%84%EB%A5%BC-%EC%9C%A0%EC%A7%80%ED%95%98%EB%A9%B4-%EC%9E%91%EC%9D%80-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%97%AC%EB%9F%BF%EC%9C%BC%EB%A1%9C-%EA%B5%AC%EC%84%B1%EB%90%9C%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>응집도를 유지하면 작은 클래스 여럿으로 구성된다.</h4>\n<ul>\n<li>클래스가 응집력을 잃으면 쪼개야 한다.</li>\n<li>\n<p>3가지 룰을 사용한다.</p>\n<ol>\n<li>리팩터링한 프로그램은 좀 더 길고 서술적인 변수 이름을 사용</li>\n<li>리팩터링한 프로그램은 코드에 주석을 추가하는 수단으로 함수 선언과 클래스 선언을 활용</li>\n<li>가독성을 높이기 위해 공백을 추가하고 형식을 맞춤</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"변경하기-쉬운-클래스\"><a href=\"#%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0-%EC%89%AC%EC%9A%B4-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>변경하기 쉬운 클래스</h3>\n<p>대표적으로 수정하기 어려운 코드가 SQL 클래스이다. 잠재적으로 수정되는 여지를 남기는 것이 좋다.</p>\n<h4 id=\"변경으로부터-격리\"><a href=\"#%EB%B3%80%EA%B2%BD%EC%9C%BC%EB%A1%9C%EB%B6%80%ED%84%B0-%EA%B2%A9%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>변경으로부터 격리</h4>\n<ul>\n<li>구체적인 클래스와 추상 클래스의 사용이 중요하다. 즉, 인터페이스와 추상 클래스가 중요하다.</li>\n<li>시스템의 결합도를 낮추면 유연성과 재사용성이 높아지고 각 요소를 이해하기 쉬워진다.</li>\n<li>\n<p>이는 클래스 설계 원칙(DIP, Dependency Inversion Principle)을 따르는 클래스를 지킬 수 있다.</p>\n<ul>\n<li>DIP : 상세한 구현이 아니라 추상화에 의존한다는 원칙</li>\n</ul>\n</li>\n</ul>\n"}},{"node":{"title":"[Review] Clean Code 내용정리 - 2","path":"/02-clean-code/","date":"6. November 2020","timeToRead":9,"description":" Clean code 책 정리 2편입니다. ","content":"<h1 id=\"clean-code-내용-정리---2\"><a href=\"#clean-code-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC---2\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Clean Code 내용 정리 - 2</h1>\n<h2 id=\"4장-주석\"><a href=\"#4%EC%9E%A5-%EC%A3%BC%EC%84%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>4장. 주석</h2>\n<p>부정확한 주석은 아예 없는 주석보다 나쁘다.</p>\n<ol>\n<li>\n<p>주석은 나쁜 코드를 보완하지 못한다.</p>\n<ul>\n<li>코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문에, 주석보다는 코드를 정리를 해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>코드로 의도를 표현하기.</p>\n<ul>\n<li>많은 경우에서 주석에서 할 수 있는 설명을 함수로 표현해도 충분하다</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"좋은-주석\"><a href=\"#%EC%A2%8B%EC%9D%80-%EC%A3%BC%EC%84%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>좋은 주석</h3>\n<ol>\n<li>\n<p>법적인 주석</p>\n<ul>\n<li>회사가 정립한 구현 표준을 지켜야 하는 경우</li>\n</ul>\n</li>\n<li>\n<p>정보를 제공하는 주석</p>\n<ul>\n<li>기본적인 정보를 주석으로 제공</li>\n<li>\n<p>Ex)</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// kk:mm:ss EEE, MMM dd, yyyy 형식이다.</span>\n<span class=\"token class-name\">Pattern</span> timeMatcher <span class=\"token operator\">=</span> <span class=\"token class-name\">Pattern</span><span class=\"token punctuation\">.</span><span class=\"token function\">compile</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"\\\\d*:\\\\d*:\\\\d* \\\\w*, \\\\w*, \\\\d*, \\\\d*\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>의도를 설명하는 주석</p>\n<ul>\n<li>의도를 표현</li>\n<li>\n<p>Ex)</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testConcurrentAddWidgets</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token comment\">// 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다.</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span><span class=\"token number\">25000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">WidgetBuilderThread</span> widgetBuilderThread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WidgetBuilderThread</span><span class=\"token punctuation\">(</span>widgetBuilder<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">,</span> failFlag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Thread</span> thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>widgetBuilderThread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">assertEquals</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> failFlag<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p>의미를 명료하게 밝히는 주석</p>\n<ul>\n<li>모호한 인수나 반환 값의 의미를 읽기 좋게 표현</li>\n<li>\n<p>Ex)</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n<span class=\"token function\">assertThat</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// a == a</span>\n<span class=\"token function\">assertThat</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// a != b</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"5\">\n<li>\n<p>결과를 경고하는 주석</p>\n<ul>\n<li>결과를 경고할 목적</li>\n<li>\n<p>Ex)</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">SimpleDateFormat</span> <span class=\"token function\">makeStandardHttpDataFormat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// SimpleDateFormat은 스레드에 안전하지 못하다.</span>\n  <span class=\"token comment\">// 따라서 각 인스턴스를 독립적으로 생성해야 한다.</span>\n  <span class=\"token class-name\">SimpleDateFormat</span> df <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"EEE, dd MMM. yyyy HH:mm:ss z\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  df<span class=\"token punctuation\">.</span><span class=\"token function\">setTimeZone</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TimeZone</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTimeZone</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GMT\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> df<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>TODO 주석</p>\n<ul>\n<li>앞으로 할 일을 설명할 때 괜찮다.</li>\n<li>\n<p>Ex)</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// TODO-MdM 현재 필요하지 않다</span>\n<span class=\"token comment\">// 체크아웃 모델을 도입하면 함수가 필요 없다.</span>\n<span class=\"token keyword\">protected</span> <span class=\"token class-name\">VersionInfo</span> <span class=\"token function\">makeVersion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>중요성을 강조하는 주석</p>\n<ul>\n<li>중요성을 강조하기 위해 주석을 사용한다.</li>\n<li>\n<p>Ex)</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> listItemContent <span class=\"token operator\">=</span> match<span class=\"token punctuation\">.</span><span class=\"token function\">group</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다.</span>\n<span class=\"token comment\">// 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다.</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">ListItemWidget</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> listItemContent<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>level <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">return</span> <span class=\"token function\">buildList</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>공개 API에서 Javadocs</p>\n<ul>\n<li>설명이 잘 된 공개 API를 사용하는 것도 방법.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"나쁜-주석\"><a href=\"#%EB%82%98%EC%81%9C-%EC%A3%BC%EC%84%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>나쁜 주석</h3>\n<ol>\n<li>주절거리는 주석</li>\n<li>같은 이야기를 중복하는 주석</li>\n<li>오해할 여지가 있는 주식</li>\n<li>의무적으로 다는 주석</li>\n<li>이력을 기록하는 주석</li>\n<li>있으나 마나 한 주석</li>\n<li>무서운 잡음 : 의미 없는 주석</li>\n<li>함수나 변수로 표현할 수 있다면 주석을 달지 말기.</li>\n<li>\n<p>위치를 표시하는 주석</p>\n<ul>\n<li>Ex) <code class=\"language-text\">// Action//////////////</code></li>\n<li>반드시 필요할 때만, 아주 드물게 사용하기</li>\n</ul>\n</li>\n<li>닫는 괄호에 다는 주석</li>\n<li>공로를 돌리거나 저자를 표시하는 주석</li>\n<li>주석으로 처리한 코드</li>\n<li>\n<p>HTML 주석</p>\n<ul>\n<li>너무 지저분하다.</li>\n</ul>\n</li>\n<li>전역 정보</li>\n<li>너무 많은 정보</li>\n<li>\n<p>모호한 관계</p>\n<ul>\n<li>주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>함수 헤더</p>\n<ul>\n<li>짧은 함수는 긴 설명이 필요 없다.</li>\n</ul>\n</li>\n<li>\n<p>비공개 코드에서 Javadocs</p>\n<ul>\n<li>공개하지 않을 코드라면 Javadocs는 쓸모가 없음.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5장-형식-맞추기\"><a href=\"#5%EC%9E%A5-%ED%98%95%EC%8B%9D-%EB%A7%9E%EC%B6%94%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>5장. 형식 맞추기</h2>\n<p>프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야하고, 코드 형식을 맞추기 위한 간단한 규칙을 정하고 이를 수행해야 한다.</p>\n<h3 id=\"형식을-맞추는-목적\"><a href=\"#%ED%98%95%EC%8B%9D%EC%9D%84-%EB%A7%9E%EC%B6%94%EB%8A%94-%EB%AA%A9%EC%A0%81\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>형식을 맞추는 목적</h3>\n<ul>\n<li>코드 형식은 중요하다.</li>\n<li>오늘 구현한 코드는 다음 버전에서 바뀔 확률이 높으며, 구현한 코드의 가독성은 이후 바뀔 코드의 품질에 지대한 영향을 미친다.</li>\n</ul>\n<h3 id=\"적절한-행-길이를-유지하기-세로-형식\"><a href=\"#%EC%A0%81%EC%A0%88%ED%95%9C-%ED%96%89-%EA%B8%B8%EC%9D%B4%EB%A5%BC-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0-%EC%84%B8%EB%A1%9C-%ED%98%95%EC%8B%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>적절한 행 길이를 유지하기 (세로 형식)</h3>\n<p>사실 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다.</p>\n<ol>\n<li>\n<p>신문 기사처럼 작성하기</p>\n<ul>\n<li>좋은 신문 기사는 최상단에서 기사를 몇 마디로 요약하는 표제가 있다.</li>\n<li>소스파일도 이름은 간단하면서 설명이 가능하게 짓는다.</li>\n<li>신문이 다양한 기사로 이뤄지는 것처럼, 소스 코드도 그렇게 구성한다.</li>\n</ul>\n</li>\n<li>\n<p>개념은 빈 행으로 분리하기</p>\n<ul>\n<li>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 좋은 케이스</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> <span class=\"token function\">function1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> <span class=\"token function\">function2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 나쁜 케이스</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> <span class=\"token function\">function1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> <span class=\"token function\">function2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>세로 밀집도</p>\n<ul>\n<li>줄 바꿈이 개념을 분리한다면, 세로 밀집도는 연관성을 의미</li>\n</ul>\n</li>\n<li>\n<p>수직거리</p>\n<ul>\n<li>서로 밀집한 개념은 세로로 가까이 둔다. 단, 다른 파일에 속한다면 규칙은 통하지 않는다.</li>\n<li>타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 한다.</li>\n<li>\n<p><strong>변수 선언</strong></p>\n<ul>\n<li>변수는 사용하는 위치에 최대한 가까이 선언</li>\n</ul>\n</li>\n<li>\n<p><strong>인스턴스 변수</strong></p>\n<ul>\n<li>인스턴스 변수는 클래스 맨 처음에 선언</li>\n</ul>\n</li>\n<li>\n<p><strong>종속 함수</strong></p>\n<ul>\n<li>한 함수가 다른 함수를 호출한다면, 두 함수는 세로로 가까이 배치한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>개념적 유사성</strong></p>\n<ul>\n<li>개념적인 친화도가 높을수록 코드를 가까이 배치한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>세로 순서</p>\n<ul>\n<li>일반적으로 함수 호출 종속성은 아래 방향으로 유지</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"가로-형식-맞추기\"><a href=\"#%EA%B0%80%EB%A1%9C-%ED%98%95%EC%8B%9D-%EB%A7%9E%EC%B6%94%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>가로 형식 맞추기</h3>\n<p>일반적으로는 가로길이는 45자 근처이다. (가급적으로는 120자 정도를 제한)</p>\n<ol>\n<li>\n<p>가로 공백과 밀집도</p>\n<ul>\n<li>가로 공백을 사용해 밀집한 개념과 느슨한 개념을 표현</li>\n<li>\n<p>Ex)</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">measureLine</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  lineCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> lineSize <span class=\"token operator\">=</span> line<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 느슨한 개념</span>\n  totalhars <span class=\"token operator\">+=</span> lineSize<span class=\"token punctuation\">;</span>\n  lineWidthHistogram<span class=\"token punctuation\">.</span><span class=\"token function\">addLine</span><span class=\"token punctuation\">(</span>lineSize<span class=\"token punctuation\">,</span> lineCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">recordWidestLine</span><span class=\"token punctuation\">(</span>lineSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 밀집한 개념</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>가로 정렬</p>\n<ul>\n<li>코드처럼 선언부가 길다면 클래스를 쪼개야 한다는 의미</li>\n</ul>\n</li>\n<li>\n<p>들여 쓰기</p>\n<ul>\n<li>scope로 이뤄진 계층을 보여준다.</li>\n<li><strong>\"들여 쓰기 무시하기\"를</strong> 피하기</li>\n</ul>\n</li>\n<li>\n<p>가짜 범위</p>\n<ul>\n<li>세미콜론은 새 행에다 제대로 들여 써서 넣어준다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"팀-규칙\"><a href=\"#%ED%8C%80-%EA%B7%9C%EC%B9%99\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>팀 규칙</h3>\n<p>좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이뤄 저 야한다.</p>\n<h2 id=\"6장-객체와-자료-구조\"><a href=\"#6%EC%9E%A5-%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>6장. 객체와 자료 구조</h2>\n<h3 id=\"자료-추상화\"><a href=\"#%EC%9E%90%EB%A3%8C-%EC%B6%94%EC%83%81%ED%99%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>자료 추상화</h3>\n<ul>\n<li>자료를 세세하게 공개하기보다는 추성적인 개념으로 표현하는 편이 좋다.</li>\n<li>아무 생각 없이 GET/SET을 추가하는 방법은 좋지 않다.</li>\n</ul>\n<h3 id=\"자료객체-비대칭\"><a href=\"#%EC%9E%90%EB%A3%8C%EA%B0%9D%EC%B2%B4-%EB%B9%84%EB%8C%80%EC%B9%AD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>자료/객체 비대칭</h3>\n<ul>\n<li>모든 것이 객체가 좋은 것은 아니고, 단순한 자료 구조와 절차적인 코드가 좋을 때도 있음</li>\n<li>객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉽고, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉬움.</li>\n</ul>\n<h3 id=\"디미터-법칙\"><a href=\"#%EB%94%94%EB%AF%B8%ED%84%B0-%EB%B2%95%EC%B9%99\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>디미터 법칙</h3>\n<blockquote>\n<p>모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙<br>\n즉, 객체의 내부를 몰라야 한다는 법칙</p>\n</blockquote>\n<ol>\n<li>\n<p>기차 충돌</p>\n<ul>\n<li>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 기차 충돌 코드</span>\n<span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> outputDir <span class=\"token operator\">=</span> ctxt<span class=\"token punctuation\">.</span><span class=\"token function\">getOptions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getScratchDir</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getAbsolutePath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 이를 방지하는 코드</span>\n<span class=\"token class-name\">Options</span> opts <span class=\"token operator\">=</span> ctxt<span class=\"token punctuation\">.</span><span class=\"token function\">getOptions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">File</span> scratchDir <span class=\"token operator\">=</span> opts<span class=\"token punctuation\">.</span><span class=\"token function\">getScratchDir</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> outputDir <span class=\"token operator\">=</span> scratchDir<span class=\"token punctuation\">.</span><span class=\"token function\">getAbsolutePath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 단, 아래의 코드는 디미터 법칙과 상관 없음.</span>\n<span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> outputDir <span class=\"token operator\">=</span> ctxt<span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">.</span>scratchDir<span class=\"token punctuation\">.</span>absolutePath<span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li>자료 구조는 무조건 함수 없이 공개 변수만 포함한다면, 문제는 간단하겠지만<br>\n그럴 수 없기 때문에 요구하는 프레임워크와 표준(ex. 빈)이 존재한다.</li>\n</ul>\n</li>\n<li>\n<p>잡종 구조</p>\n<ul>\n<li>잡종 구조는 절차적과 객체적의 단점만 모아놓은 구조이기 때문에, 피하는 편이 좋다.</li>\n</ul>\n</li>\n<li>구조체 감추기</li>\n</ol>\n<h3 id=\"자료-전달-객체\"><a href=\"#%EC%9E%90%EB%A3%8C-%EC%A0%84%EB%8B%AC-%EA%B0%9D%EC%B2%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>자료 전달 객체</h3>\n<p>DTO나 빈 구조 등을 사용한다</p>\n<ul>\n<li>\n<p>활성 레코드</p>\n<ul>\n<li>DTO의 특수한 형태, 자료 구조로 취급하기</li>\n<li>비즈니스 규칙은 넣는 것이 아니고, 비즈니스 규칙을 넣고 싶으면 내부 자료를 숨기는 객체를 따로 생성한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"결론\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>결론</h3>\n<ul>\n<li>객체는 동작을 공개하고 자료를 숨긴다. 그러나, 자료 구조는 별다른 도작 없이 자료를 노출한다.</li>\n<li>\n<p>어떤 시스템을 구현할 때</p>\n<ul>\n<li>새로운 자료 타입을 추가하는 유연성이 필요하면 객체를 선택.</li>\n<li>새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다.</li>\n</ul>\n</li>\n</ul>\n"}},{"node":{"title":"[Review] Clean Code 내용정리 - 5","path":"/05-clean-code/","date":"6. November 2020","timeToRead":18,"description":" Clean code 책 정리 5편입니다. ","content":"<h1 id=\"clean-code-내용-정리---5\"><a href=\"#clean-code-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC---5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Clean Code 내용 정리 - 5</h1>\n<h2 id=\"14장-점진적인-개선\"><a href=\"#14%EC%9E%A5-%EC%A0%90%EC%A7%84%EC%A0%81%EC%9D%B8-%EA%B0%9C%EC%84%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>14장. 점진적인 개선</h2>\n<blockquote>\n<p>좋은 코드가 많지만, 이를 다 적을 수 없어 내용적으로 간략하게만 구성하였다.</p>\n<p>이후에 한 번 책을 사서 코드를 보는 것을 추천드립니다.</p>\n</blockquote>\n<h3 id=\"구현\"><a href=\"#%EA%B5%AC%ED%98%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>구현</h3>\n<p>깔끔한 코드를 짜는 방법에 대해 이야기할 수 있다.</p>\n<p>깨끗한 코드를 짜기 위해서는 먼저 지저분한 코드를 짠 뒤에 정리해야 한다.</p>\n<h3 id=\"초안\"><a href=\"#%EC%B4%88%EC%95%88\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>초안</h3>\n<p>최초의 코드에 인수 유형 1개만 추가해도 엄청나게 지저분해진다.</p>\n<p>이 경우에, 기능을 더 추가하지 않고 리팩토링을 한다. 왜냐하면? 더 인수 유형을 추가할 수도 있기 때문에.</p>\n<p>점진적으로 개선</p>\n<p>프로그램을 망치는 방법 중 하나는 \"개선\"이라는 이름에서 구조를 크게 뒤집는 것. 이는 그 전과 똑같이 어려워질 수 있다.</p>\n<p>따라서, <strong>테스트 주도 개발(TDD, Test-Driven Development)</strong> 기법을 통해 시스템을 망가트리지 않고, 리팩토링을 진행한다.</p>\n<h3 id=\"결론\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>결론</h3>\n<p>단순히 돌아가는 코드만으로는 되지 않는다. 이는 이후에 큰 문제를 만든다.</p>\n<p>나쁜 코드는 깨끗한 코드로 개선하기에는 엄청난 비용이 발생하지만, 최근에 만든 코드는 당장 정리하기 매우 쉽다.</p>\n<p><strong>따라서, 코드는 언제나 최대한 깔끔하고 단순하게 정리해야한다.</strong></p>\n<h2 id=\"15장-junit-들여다보기\"><a href=\"#15%EC%9E%A5-junit-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>15장. JUnit 들여다보기</h2>\n<h3 id=\"junit-프레임워크\"><a href=\"#junit-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JUnit 프레임워크</h3>\n<p>문자열 비교 오류를 파할 때 유용한 코드로 parisonCompactor 등이 있다.</p>\n<blockquote>\n<p>코드 등은 미첨부.</p>\n</blockquote>\n<h3 id=\"결론-1\"><a href=\"#%EA%B2%B0%EB%A1%A0-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>결론</h3>\n<p>보이스카우트 규칙을 지키기.</p>\n<p><strong>즉, 좋은 모듈을 통해서 조금 더 깨끗하게 만들 수 있어야 한다.</strong></p>\n<h2 id=\"16장-serialdate-리팩터링\"><a href=\"#16%EC%9E%A5-serialdate-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>16장. SerialDate 리팩터링</h2>\n<p>대표적인 코드를 분석을 해보면서 좋은 코드로 리팩터링 할 수 있다.</p>\n<p>순서는 다음과 같이 진행할 수 있다.</p>\n<h3 id=\"1-돌려보기\"><a href=\"#1-%EB%8F%8C%EB%A0%A4%EB%B3%B4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 돌려보기</h3>\n<ul>\n<li>단위 테스트가 다 구현이 되어있는가?</li>\n</ul>\n<h3 id=\"2-고쳐보기\"><a href=\"#2-%EA%B3%A0%EC%B3%90%EB%B3%B4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 고쳐보기</h3>\n<ul>\n<li>변경이력은 소스 코드 제어 도구가 있으므로 하지 않아도 된다.</li>\n<li>오래된 주석은 고쳐서 개선하기</li>\n<li>enum을 독자적인 소스파일로 옮기기</li>\n<li>추상 메서드를 클래스로 수정</li>\n<li><strong>코드 커버리지를 감소시켰다.</strong></li>\n</ul>\n<h3 id=\"결론-2\"><a href=\"#%EA%B2%B0%EB%A1%A0-2\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>결론</h3>\n<p><strong>따라서 리팩터링을 통해 테스트 커버리지가 증가시키고, 버그 고치고, 코드 크기를 줄이고 코드를 명확하게 할 수 있다.</strong></p>\n<ul>\n<li>시간을 투자해서, 보이스카우트 규칙을 따랐다.</li>\n</ul>\n<h2 id=\"17장-냄새와-휴리스틱\"><a href=\"#17%EC%9E%A5-%EB%83%84%EC%83%88%EC%99%80-%ED%9C%B4%EB%A6%AC%EC%8A%A4%ED%8B%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>17장. 냄새와 휴리스틱</h2>\n<h3 id=\"주석\"><a href=\"#%EC%A3%BC%EC%84%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>주석</h3>\n<h4 id=\"c1-부적절한-정보-피하기\"><a href=\"#c1-%EB%B6%80%EC%A0%81%EC%A0%88%ED%95%9C-%EC%A0%95%EB%B3%B4-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>C1. 부적절한 정보 피하기</h4>\n<p>다른 시스템에 저장할 정보는 주석으로 적절하지 못한다. 일반적으로 작성자, 최종 수정일, SPR 번호 등과 같은 메타 정보만 주석으로 넣고, 추가적으로 코드와 설계에 기술적인 설명을 하는 수단으로 써야 한다.</p>\n<h4 id=\"c2-쓸모없는-주석-피하기\"><a href=\"#c2-%EC%93%B8%EB%AA%A8%EC%97%86%EB%8A%94-%EC%A3%BC%EC%84%9D-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>C2. 쓸모없는 주석 피하기</h4>\n<p>오래된 주석, 엉뚱한 주석, 잘못된 주석은 더 이상 쓸모가 없다. 쓸모없는 주석은 없애야 한다.</p>\n<h4 id=\"c3-중복된-주석-피하기\"><a href=\"#c3-%EC%A4%91%EB%B3%B5%EB%90%9C-%EC%A3%BC%EC%84%9D-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>C3. 중복된 주석 피하기</h4>\n<p>코드만으로 충분한데 구구절절 설명하는 주석이 중복된 주석은 좋지 않다.</p>\n<h4 id=\"c4-성의-없는-주석-피하기\"><a href=\"#c4-%EC%84%B1%EC%9D%98-%EC%97%86%EB%8A%94-%EC%A3%BC%EC%84%9D-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>C4. 성의 없는 주석 피하기</h4>\n<p>단어를 신중하게 선택하고, 간결하고 명료하게 작성해야 한다.</p>\n<h4 id=\"c5-주석-처리된-코드-피하기\"><a href=\"#c5-%EC%A3%BC%EC%84%9D-%EC%B2%98%EB%A6%AC%EB%90%9C-%EC%BD%94%EB%93%9C-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>C5. 주석 처리된 코드 피하기</h4>\n<p>주석으로 처리된 코드는 남들이 읽을 때 매우 눈에 거슬리고 매일매일 낡아간다. 이는 해당 모듈을 오염시키고, 읽는 사람을 헷갈리게 만든다.</p>\n<h3 id=\"환경\"><a href=\"#%ED%99%98%EA%B2%BD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>환경</h3>\n<h4 id=\"e1-한-단계로-빌드하기\"><a href=\"#e1-%ED%95%9C-%EB%8B%A8%EA%B3%84%EB%A1%9C-%EB%B9%8C%EB%93%9C%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>E1. 한 단계로 빌드하기</h4>\n<p>빌드는 간단히 한 단계로 끝나야 한다.</p>\n<h4 id=\"e2-한-단계로-테스트하기\"><a href=\"#e2-%ED%95%9C-%EB%8B%A8%EA%B3%84%EB%A1%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>E2. 한 단계로 테스트하기</h4>\n<p>모든 단위 테스트는 한 명령으로 돌려야 하고, 이 방법이 빠르고 쉽고 명백하며, 가장 중요하다.</p>\n<h3 id=\"함수\"><a href=\"#%ED%95%A8%EC%88%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>함수</h3>\n<h4 id=\"f1-너무-많은-인수-피하기\"><a href=\"#f1-%EB%84%88%EB%AC%B4-%EB%A7%8E%EC%9D%80-%EC%9D%B8%EC%88%98-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>F1. 너무 많은 인수 피하기</h4>\n<p>인수는 작으면 작을수록 좋다</p>\n<h4 id=\"f2-출력-인수-피하기\"><a href=\"#f2-%EC%B6%9C%EB%A0%A5-%EC%9D%B8%EC%88%98-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>F2. 출력 인수 피하기</h4>\n<p>출력이 인수는 직관을 정면으로 위배하므로 안 쓰는 것이 좋다.</p>\n<h4 id=\"f3-플래그-인수-피하기\"><a href=\"#f3-%ED%94%8C%EB%9E%98%EA%B7%B8-%EC%9D%B8%EC%88%98-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>F3. 플래그 인수 피하기</h4>\n<p>Boolean 인수는 함수가 여러 기능을 수행한다는 증거이므로, 플래그 인수는 혼란을 피하기 위해서 피해야 한다.</p>\n<h4 id=\"f4-죽은-함수-피하기\"><a href=\"#f4-%EC%A3%BD%EC%9D%80-%ED%95%A8%EC%88%98-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>F4. 죽은 함수 피하기</h4>\n<p>아무도 호출하지 않는 함수는 삭제한다.</p>\n<h3 id=\"일반\"><a href=\"#%EC%9D%BC%EB%B0%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>일반</h3>\n<h4 id=\"g1-한-소스-파일에-여러-언어를-사용을-줄이기\"><a href=\"#g1-%ED%95%9C-%EC%86%8C%EC%8A%A4-%ED%8C%8C%EC%9D%BC%EC%97%90-%EC%97%AC%EB%9F%AC-%EC%96%B8%EC%96%B4%EB%A5%BC-%EC%82%AC%EC%9A%A9%EC%9D%84-%EC%A4%84%EC%9D%B4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G1. 한 소스 파일에 여러 언어를 사용을 줄이기</h4>\n<p>이상적으로는 소스 파일 하나에 언어 하나만 사용하는 방식이 좋으며, 현실적으로는 이가 어렵기 때문에 소스 파일에서 언어 수와 범위를 줄이는 방법이 중요하다.</p>\n<h4 id=\"g2-당연한-동작을-구현하기\"><a href=\"#g2-%EB%8B%B9%EC%97%B0%ED%95%9C-%EB%8F%99%EC%9E%91%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G2. 당연한 동작을 구현하기</h4>\n<p>최소 놀람의 원칙을 지켜서 함수나 클래스는 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.</p>\n<h4 id=\"g3-경계를-올바르게-처리하기\"><a href=\"#g3-%EA%B2%BD%EA%B3%84%EB%A5%BC-%EC%98%AC%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G3. 경계를 올바르게 처리하기</h4>\n<p>코드는 올바르게 동작해야 한다. 모든 경계 조건, 구석진 곳, 예외 등을 신경을 써야 하며 모든 경계 조건을 테스트하는 케이스가 있어야 한다.</p>\n<h4 id=\"g4-안전-절차를-지키기\"><a href=\"#g4-%EC%95%88%EC%A0%84-%EC%A0%88%EC%B0%A8%EB%A5%BC-%EC%A7%80%ED%82%A4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G4. 안전 절차를 지키기</h4>\n<p>안전 절차를 무시하면 위험하다. 예를 들면 변수를 직접 제어하거나 컴파일러 경고를 꺼버리면 끊임없는 문제가 발생한다.</p>\n<h4 id=\"g5-중복을-피하기\"><a href=\"#g5-%EC%A4%91%EB%B3%B5%EC%9D%84-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G5. 중복을 피하기</h4>\n<p>단 한 번만 사용하는 규칙을 지켜야 한다. 코드에서 중복을 발견할 때마다 이를 추상화시키고, 중복을 다른 클래스로 분리해야 한다.</p>\n<h4 id=\"g6-추상화-수준이-올바르게-지키기\"><a href=\"#g6-%EC%B6%94%EC%83%81%ED%99%94-%EC%88%98%EC%A4%80%EC%9D%B4-%EC%98%AC%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%A7%80%ED%82%A4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G6. 추상화 수준이 올바르게 지키기</h4>\n<p>추상화는 저 차원 상세 개념을 고차원 일반 개념으로 분리한다. 고차원 개념을 표현하는 추상(기초) 클래스와 저차원 개념을 표현하는 파생 클래스를 통해서 추상화를 진행해야 한다.</p>\n<h4 id=\"g7-기초-클래스는-파생-클래스에-독립적으로\"><a href=\"#g7-%EA%B8%B0%EC%B4%88-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%ED%8C%8C%EC%83%9D-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9C%BC%EB%A1%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G7. 기초 클래스는 파생 클래스에 독립적으로</h4>\n<p>기초 클래스와 파생 클래스로 나누는 큰 이유는 하나는 개념을 분리해 독립성을 보장하기 위해서이다. 따라서 서로 ㅈ독립적으로 진행해야 하고, 이는 이후에 유지보수에 큰 장점을 가진다.</p>\n<h4 id=\"g8-과도한-정보를-피하기\"><a href=\"#g8-%EA%B3%BC%EB%8F%84%ED%95%9C-%EC%A0%95%EB%B3%B4%EB%A5%BC-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G8. 과도한 정보를 피하기</h4>\n<p>잘 정의된 모듈은 인터페이스가 아주 작다. 많은 함수를 제공하지 않기 때문에 결합도가 낮다. 이런 식으로 인터페이스에 노출할 함수를 제한해야 하고, 클래스가 제공하는 메서드 수는 작을수록 좋다. 마찬가지로 변수가 작을 수록 좋다. 더 나아가서 자료를 줌 기는 것 또한 중요하다.</p>\n<h4 id=\"g9-죽은-코드를-피하기\"><a href=\"#g9-%EC%A3%BD%EC%9D%80-%EC%BD%94%EB%93%9C%EB%A5%BC-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G9. 죽은 코드를 피하기</h4>\n<p>실행되지 않는 코드는 시스템에서 제거해주어야 한다.</p>\n<h4 id=\"g10-수직-분리-줄이기\"><a href=\"#g10-%EC%88%98%EC%A7%81-%EB%B6%84%EB%A6%AC-%EC%A4%84%EC%9D%B4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G10. 수직 분리 줄이기</h4>\n<p>변수와 함수는 사용되는 위치에 가깝게 정의해야 한다. 비공개 함수는 처음으로 호출한 직후에 정의해야 한다.</p>\n<h4 id=\"g11-일관성-유지\"><a href=\"#g11-%EC%9D%BC%EA%B4%80%EC%84%B1-%EC%9C%A0%EC%A7%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G11. 일관성 유지</h4>\n<p>어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현해야 한다. 이러한 일관성을 유지한다면 코드를 읽고 수정하기가 쉬워진다.</p>\n<h4 id=\"g12-잡동사니-없애기\"><a href=\"#g12-%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88-%EC%97%86%EC%95%A0%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G12. 잡동사니 없애기</h4>\n<p>비어있는 기본 생성자와 같은 잡동사니는 삭제한다.</p>\n<h4 id=\"g13-인위적인-결합-피하기\"><a href=\"#g13-%EC%9D%B8%EC%9C%84%EC%A0%81%EC%9D%B8-%EA%B2%B0%ED%95%A9-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G13. 인위적인 결합 피하기</h4>\n<p>서로 무관한 개념은 인위적으로 결합하지 않는다.</p>\n<h4 id=\"g14-기능-욕심내지-말기\"><a href=\"#g14-%EA%B8%B0%EB%8A%A5-%EC%9A%95%EC%8B%AC%EB%82%B4%EC%A7%80-%EB%A7%90%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G14. 기능 욕심내지 말기</h4>\n<p>기능을 위해서 다른 클래스의 변수와 함수에 관심을 가져서는 안 된다. 어쩔 수 없는 경우를 제외하고는 최대한 피해야 한다.</p>\n<h4 id=\"g15-선택자-인수-피하기\"><a href=\"#g15-%EC%84%A0%ED%83%9D%EC%9E%90-%EC%9D%B8%EC%88%98-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G15. 선택자 인수 피하기</h4>\n<p>선택자 인수는 큰 함수를 작은 함수로 쪼개지 않으려는 게으름의 결과이다.</p>\n<h4 id=\"g16-분명한-의도-사용\"><a href=\"#g16-%EB%B6%84%EB%AA%85%ED%95%9C-%EC%9D%98%EB%8F%84-%EC%82%AC%EC%9A%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G16. 분명한 의도 사용</h4>\n<p>코드를 짤 때는 의도를 최대한으로 밝혀야 한다.</p>\n<h4 id=\"g17-명백한-위치-선정\"><a href=\"#g17-%EB%AA%85%EB%B0%B1%ED%95%9C-%EC%9C%84%EC%B9%98-%EC%84%A0%EC%A0%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G17. 명백한 위치 선정</h4>\n<p>코드는 독자가 자연스럽게 기대할 위치에 배치해야 한다</p>\n<h4 id=\"g18-부적절한-static-함수-피하기\"><a href=\"#g18-%EB%B6%80%EC%A0%81%EC%A0%88%ED%95%9C-static-%ED%95%A8%EC%88%98-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G18. 부적절한 static 함수 피하기</h4>\n<p>일반적으로 static 함수보다는 인스턴스 함수가 더 좋고, 조금이라도 의심스럽다면 인스턴스 함수를 사용하는 방법이 더 좋다. 반드시 static 함수로 정의해야 한다면 재정의 가능성이 없는지 꼼꼼히 고려해야 한다.</p>\n<h4 id=\"g19-서술적인-변수-사용하기\"><a href=\"#g19-%EC%84%9C%EC%88%A0%EC%A0%81%EC%9D%B8-%EB%B3%80%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G19. 서술적인 변수 사용하기</h4>\n<p>서술적인 변수 이름 등인 일반적으로 더 많을수록 좋다. 좋은 변수 이름만 붙여도 모듈이 읽기 쉬운 모듈로 탈바꿈한다.</p>\n<h4 id=\"g20-이름과-기능이-일치하는-함수\"><a href=\"#g20-%EC%9D%B4%EB%A6%84%EA%B3%BC-%EA%B8%B0%EB%8A%A5%EC%9D%B4-%EC%9D%BC%EC%B9%98%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G20. 이름과 기능이 일치하는 함수</h4>\n<p>이름만으로 분명하지 않아, 구현을 봐야 한다면 더 좋은 이름을 선정해야 한다.</p>\n<h4 id=\"g21-알고리즘-이해하기\"><a href=\"#g21-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G21. 알고리즘 이해하기</h4>\n<p>기능이 뻔히 보일 정도로 함수를 깔끔하게 구해야 하며, 이를 통해 알고리즘이 올바르다는 것을 보여주어야 한다.</p>\n<h4 id=\"g22-논리적-의존성은-물리적으로도-나타내기\"><a href=\"#g22-%EB%85%BC%EB%A6%AC%EC%A0%81-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%80-%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%9C%BC%EB%A1%9C%EB%8F%84-%EB%82%98%ED%83%80%EB%82%B4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G22. 논리적 의존성은 물리적으로도 나타내기</h4>\n<p>한 모듈이 다른 모듈에 의존한다면 물리적인 의존성도 주어야 한다.</p>\n<h4 id=\"g23-ifelse-혹은-switchcase-문보다-다형성을-사용하기\"><a href=\"#g23-ifelse-%ED%98%B9%EC%9D%80-switchcase-%EB%AC%B8%EB%B3%B4%EB%8B%A4-%EB%8B%A4%ED%98%95%EC%84%B1%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G23. If/Else 혹은 Switch/Case 문보다 다형성을 사용하기</h4>\n<p>대부분의 개발자가 switch 문을 사용하는 이유는 그 상황에서 가장 올바른 선택보다는 손쉬운 선택이므로 선택한다.</p>\n<p>유형보다 함수가 더 쉽게 변하는 경우는 드물기 때문에, 같은 선택을 수행하는 다른 코드에서는 다형성 객체를 생성하고, 선택 유형 하나에는 switch 문을 한 번만 사용해야 한다.</p>\n<h4 id=\"g24-표준-표기법을-사용하기\"><a href=\"#g24-%ED%91%9C%EC%A4%80-%ED%91%9C%EA%B8%B0%EB%B2%95%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G24. 표준 표기법을 사용하기</h4>\n<p>팀은 업계 표준에 기반한 구현 표준을 지켜야 한다.</p>\n<h4 id=\"g25-매직-숫자는-명명된-상수로-교체하기\"><a href=\"#g25-%EB%A7%A4%EC%A7%81-%EC%88%AB%EC%9E%90%EB%8A%94-%EB%AA%85%EB%AA%85%EB%90%9C-%EC%83%81%EC%88%98%EB%A1%9C-%EA%B5%90%EC%B2%B4%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G25. 매직 숫자는 명명된 상수로 교체하기</h4>\n<p>예를 들면 <code class=\"language-text\">86400</code>이라는 숫자는 <code class=\"language-text\">SECONDS_PER_DAY와</code> 같이 표현해야 한다.</p>\n<h4 id=\"g26-정확하게-작성하기\"><a href=\"#g26-%EC%A0%95%ED%99%95%ED%95%98%EA%B2%8C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G26. 정확하게 작성하기</h4>\n<p>코드에서 뭔가를 결정할 때는 정확히 결정해야 한다. 결정을 내리는 이유와 예외를 처리할 방법을 정확하게 알아야 한다.</p>\n<h4 id=\"g27-관례보다는-구조를-사용하기\"><a href=\"#g27-%EA%B4%80%EB%A1%80%EB%B3%B4%EB%8B%A4%EB%8A%94-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G27. 관례보다는 구조를 사용하기</h4>\n<p>명명 관례도 좋지만 구조 자체로 강제로 하는 경우가 더 좋을 수 있다.</p>\n<h4 id=\"g28-조건을-캡슐화하기\"><a href=\"#g28-%EC%A1%B0%EA%B1%B4%EC%9D%84-%EC%BA%A1%EC%8A%90%ED%99%94%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G28. 조건을 캡슐화하기</h4>\n<p>부울 논리를 넣는 것보다 의도를 분명히 밝히는 함수로 표현을 하는 것이 더 좋다.</p>\n<p>즉, <code class=\"language-text\">if(shouldBeDeleted(timer))</code> 가 <code class=\"language-text\">if(timer.hasExpired() &amp;&amp;! timer.isRecurrent())</code> 보다 좋다.</p>\n<h4 id=\"g29-부정-조건은-피하기\"><a href=\"#g29-%EB%B6%80%EC%A0%95-%EC%A1%B0%EA%B1%B4%EC%9D%80-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G29. 부정 조건은 피하기</h4>\n<p>부정 조건은 긍정 조건보다 이해하기 어렵다. 가능하다면 긍정 조건을 사용하는 것이 좋다</p>\n<h4 id=\"g30-함수는-한-가지만-하기\"><a href=\"#g30-%ED%95%A8%EC%88%98%EB%8A%94-%ED%95%9C-%EA%B0%80%EC%A7%80%EB%A7%8C-%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G30. 함수는 한 가지만 하기</h4>\n<h4 id=\"g31-숨겨진-시간적인-결합-피하기\"><a href=\"#g31-%EC%88%A8%EA%B2%A8%EC%A7%84-%EC%8B%9C%EA%B0%84%EC%A0%81%EC%9D%B8-%EA%B2%B0%ED%95%A9-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G31. 숨겨진 시간적인 결합 피하기</h4>\n<p>때로는 시간적인 결합을 필요하다. 단 이때는 시간적인 결합을 숨겨서는 안 된다. 실행되는 순서가 중요하기 때문에 일종의 연결 소자를 통해 시간적인 결합을 노출하는 것도 좋은 방법이 된다.</p>\n<h4 id=\"g32-일관성-유지하기\"><a href=\"#g32-%EC%9D%BC%EA%B4%80%EC%84%B1-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G32. 일관성 유지하기</h4>\n<p>코드 구조를 잡을 때는 이유를 고민하고, 그 이유를 코드 구조로 명백하게 표현해야 한다.</p>\n<h4 id=\"g33-경계-조건을-캡슐화-하기\"><a href=\"#g33-%EA%B2%BD%EA%B3%84-%EC%A1%B0%EA%B1%B4%EC%9D%84-%EC%BA%A1%EC%8A%90%ED%99%94-%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G33. 경계 조건을 캡슐화 하기</h4>\n<p>경계 조건은 빼먹기나 놓치기 십상이다.</p>\n<h4 id=\"g34-함수는-추상화-수준을-한-단계만-내려가야-한다\"><a href=\"#g34-%ED%95%A8%EC%88%98%EB%8A%94-%EC%B6%94%EC%83%81%ED%99%94-%EC%88%98%EC%A4%80%EC%9D%84-%ED%95%9C-%EB%8B%A8%EA%B3%84%EB%A7%8C-%EB%82%B4%EB%A0%A4%EA%B0%80%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G34. 함수는 추상화 수준을 한 단계만 내려가야 한다.</h4>\n<p>함수 내 모든 문장은 추상화 수준이 동일해야 한다. 그리고 그 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계 낮아야 한다.</p>\n<h4 id=\"g35-설정-정보는-최상위-단계에-두기\"><a href=\"#g35-%EC%84%A4%EC%A0%95-%EC%A0%95%EB%B3%B4%EB%8A%94-%EC%B5%9C%EC%83%81%EC%9C%84-%EB%8B%A8%EA%B3%84%EC%97%90-%EB%91%90%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G35. 설정 정보는 최상위 단계에 두기</h4>\n<p>추상화 최상위 단계에 둬야 할 기본값 상수나 설정 관련 상수를 저 차원 함수에 숨겨서는 안 된다. 설정 관련 상수는 최상위 단계에 두어야 한다. 그래야 변경하기 쉽고, 인수로 넘길 수 있다.</p>\n<h4 id=\"g36-추이적-탐색-피하기\"><a href=\"#g36-%EC%B6%94%EC%9D%B4%EC%A0%81-%ED%83%90%EC%83%89-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>G36. 추이적 탐색 피하기</h4>\n<p>일반적으로 한 모듈은 주변 모듈을 모르면 모를수록 좋다. 이를 디미터의 법칙(Law of Demeter)라고 부른다.</p>\n<h3 id=\"자바\"><a href=\"#%EC%9E%90%EB%B0%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>자바</h3>\n<h4 id=\"j1-긴-import-목록을-피하기-와일드카드를-사용하는-것이-좋다\"><a href=\"#j1-%EA%B8%B4-import-%EB%AA%A9%EB%A1%9D%EC%9D%84-%ED%94%BC%ED%95%98%EA%B8%B0-%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>J1. 긴 import 목록을 피하기 와일드카드를 사용하는 것이 좋다.</h4>\n<p>패키지에서 클래스를 둘 이상 사용한다면 와일드카드를 사용해 패키지 전체를 가져오는 것이 좋다</p>\n<p>Ex) <code class=\"language-text\">import package.*;</code></p>\n<h4 id=\"j2-상수는-상속하지-않는다\"><a href=\"#j2-%EC%83%81%EC%88%98%EB%8A%94-%EC%83%81%EC%86%8D%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>J2. 상수는 상속하지 않는다.</h4>\n<h4 id=\"j3-상수-vs-enum\"><a href=\"#j3-%EC%83%81%EC%88%98-vs-enum\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>J3. 상수 VS Enum</h4>\n<p>자바 5부터는 enum을 제공하기 때문에 enum을 사용하는 방법은 좋다. enum은 이름이 부여된 열거체에 속하며, 메서드와 필도도 사용할 수 있기 때문에 int보다 훨씬 더 유연하고 서술적인 강력한 도구이다.</p>\n<h3 id=\"이름\"><a href=\"#%EC%9D%B4%EB%A6%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>이름</h3>\n<h4 id=\"n1-서술적인-이름-사용하기\"><a href=\"#n1-%EC%84%9C%EC%88%A0%EC%A0%81%EC%9D%B8-%EC%9D%B4%EB%A6%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>N1. 서술적인 이름 사용하기</h4>\n<p>서술적인 이름을 신중하게 고른다. 소프트웨어 가독성의 90%는 이름이 결정한다.</p>\n<h4 id=\"n2-적절한-추상화-수준에서-이름-선택하기\"><a href=\"#n2-%EC%A0%81%EC%A0%88%ED%95%9C-%EC%B6%94%EC%83%81%ED%99%94-%EC%88%98%EC%A4%80%EC%97%90%EC%84%9C-%EC%9D%B4%EB%A6%84-%EC%84%A0%ED%83%9D%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>N2. 적절한 추상화 수준에서 이름 선택하기</h4>\n<p>구현을 드러내는 이름은 피하기. 적절한 추상화 수준에서 이름을 선택하는 다른 연결방식에도 사용 가능하다</p>\n<h4 id=\"n3-가능하다면-표준-명명법-사용하기\"><a href=\"#n3-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4%EB%A9%B4-%ED%91%9C%EC%A4%80-%EB%AA%85%EB%AA%85%EB%B2%95-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>N3. 가능하다면 표준 명명법 사용하기</h4>\n<h4 id=\"n4-명확한-이름\"><a href=\"#n4-%EB%AA%85%ED%99%95%ED%95%9C-%EC%9D%B4%EB%A6%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>N4. 명확한 이름</h4>\n<p>함수나 변수의 목적을 명확히 밝히는 이름을 선택하기</p>\n<h4 id=\"n5-긴-범위는-긴-이름을-사용하기\"><a href=\"#n5-%EA%B8%B4-%EB%B2%94%EC%9C%84%EB%8A%94-%EA%B8%B4-%EC%9D%B4%EB%A6%84%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>N5. 긴 범위는 긴 이름을 사용하기</h4>\n<p>이름 길이는 범위 길이에 비례해야 한다.</p>\n<h4 id=\"n6-인코딩을-피하기\"><a href=\"#n6-%EC%9D%B8%EC%BD%94%EB%94%A9%EC%9D%84-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>N6. 인코딩을 피하기</h4>\n<p>이름에 유형 정보나 범위 정보를 넣어서는 안 된다.</p>\n<h4 id=\"n7-이름으로-부수-효과를-설명하기\"><a href=\"#n7-%EC%9D%B4%EB%A6%84%EC%9C%BC%EB%A1%9C-%EB%B6%80%EC%88%98-%ED%9A%A8%EA%B3%BC%EB%A5%BC-%EC%84%A4%EB%AA%85%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>N7. 이름으로 부수 효과를 설명하기</h4>\n<p>함수, 변수, 클래스가 하는 일을 모두 기술하는 이름을 사용하기. 이름에 부수 효과를 숨기지 않기  </p>\n<h3 id=\"테스트\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>테스트</h3>\n<h4 id=\"t1-불충분한-테스트\"><a href=\"#t1-%EB%B6%88%EC%B6%A9%EB%B6%84%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>T1. 불충분한 테스트</h4>\n<p>테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다. 테스트 케이스가 확인하지 않는 조건이나 검증하지 않는 계산이 있다면 그 테스트는 불안정한 테스트이다</p>\n<h4 id=\"t2-커버리지-도구를-사용하기\"><a href=\"#t2-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-%EB%8F%84%EA%B5%AC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>T2. 커버리지 도구를 사용하기</h4>\n<p>커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다. 이를 사용하면 테스트가 불충분한 모듈, 클래스, 함수를 찾기가 쉬워진다.</p>\n<h4 id=\"t3-사소한-테스트-건너뛰지-말기\"><a href=\"#t3-%EC%82%AC%EC%86%8C%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B1%B4%EB%84%88%EB%9B%B0%EC%A7%80-%EB%A7%90%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>T3. 사소한 테스트 건너뛰지 말기</h4>\n<p>사소한 테스트는 짜기 쉽다. 사소한 테스트가 제공하는 문서적 가치는 구현에 드는 비용을 넘어선다</p>\n<h4 id=\"t4-무시한-테스트는-모호함을-뜻한다\"><a href=\"#t4-%EB%AC%B4%EC%8B%9C%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%EB%AA%A8%ED%98%B8%ED%95%A8%EC%9D%84-%EB%9C%BB%ED%95%9C%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>T4. 무시한 테스트는 모호함을 뜻한다</h4>\n<p>불분명한 요구사항은 테스트 케이스를 주석으로 처리하고나, 테스트 케이스에 @Ignore를 붙여서 표현해버린다.</p>\n<h4 id=\"t5-경계-조건을-테스트하기\"><a href=\"#t5-%EA%B2%BD%EA%B3%84-%EC%A1%B0%EA%B1%B4%EC%9D%84-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>T5. 경계 조건을 테스트하기</h4>\n<p>경계조건은 각별히 신경 써서 테스트하기</p>\n<h4 id=\"t6-버그-주변은-철저히-테스트하기\"><a href=\"#t6-%EB%B2%84%EA%B7%B8-%EC%A3%BC%EB%B3%80%EC%9D%80-%EC%B2%A0%EC%A0%80%ED%9E%88-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>T6. 버그 주변은 철저히 테스트하기</h4>\n<p>버그는 서로 모이는 경향이 있다</p>\n<h4 id=\"t7-실패-패턴을-살펴보기\"><a href=\"#t7-%EC%8B%A4%ED%8C%A8-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>T7. 실패 패턴을 살펴보기</h4>\n<p>테스트 케이스가 실패하는 패턴으로 문제를 진단할 수 있다. 테스트 케이스를 꼼꼼하게 짜게 되면 실패와 성공 패턴만 봐도 답을 찾을 수도 있다.</p>\n<h4 id=\"t8-테스트-커버리지-패턴을-살피기\"><a href=\"#t8-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%82%B4%ED%94%BC%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>T8. 테스트 커버리지 패턴을 살피기</h4>\n<p>통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다.</p>\n<h4 id=\"t9-테스트는-빨라야-한다\"><a href=\"#t9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%EB%B9%A8%EB%9D%BC%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>T9 테스트는 빨라야 한다</h4>\n<p>느린 테스트 케이스는 실행하지 않게 된다.</p>\n"}},{"node":{"title":"[Review] Clean Code 내용정리 - 4","path":"/04-clean-code/","date":"6. November 2020","timeToRead":26,"description":" Clean code 책 정리 4편입니다. ","content":"<h1 id=\"clean-code-내용-정리---4\"><a href=\"#clean-code-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC---4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Clean Code 내용 정리 - 4</h1>\n<h2 id=\"11장-시스템\"><a href=\"#11%EC%9E%A5-%EC%8B%9C%EC%8A%A4%ED%85%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>11장. 시스템</h2>\n<h3 id=\"도시가-잘-돌아가는-이유\"><a href=\"#%EB%8F%84%EC%8B%9C%EA%B0%80-%EC%9E%98-%EB%8F%8C%EC%95%84%EA%B0%80%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>도시가 잘 돌아가는 이유</h3>\n<ul>\n<li>다양한 분야를 관리하는 팀원</li>\n<li>적절한 추상화와 모듈화</li>\n</ul>\n<h3 id=\"시스템-제작과-시스템-사용을-분리\"><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%A0%9C%EC%9E%91%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%82%AC%EC%9A%A9%EC%9D%84-%EB%B6%84%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>시스템 제작과 시스템 사용을 분리</h3>\n<p>제작과 사용은 다르다.</p>\n<p>소프트웨어 시스템은 <strong>준비 과정</strong>(애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는)과 <strong>런타임 로직</strong>(준비 과정 이후의 단계)을 분리해야 한다.</p>\n<h4 id=\"관심사-분리\"><a href=\"#%EA%B4%80%EC%8B%AC%EC%82%AC-%EB%B6%84%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>관심사 분리.</h4>\n<ul>\n<li>Ex) 초기화 지연(Lazy Initialization), 계산 지연(Lazy Evaluation)</li>\n<li>\n<p>장점</p>\n<ol>\n<li>애플리케이션을 시작하는 시간이 그만큼 빨라진다.</li>\n<li>어떤 경우에도 null을 반환하지 않는다.</li>\n</ol>\n</li>\n<li>\n<p>단점</p>\n<ol>\n<li>의존성을 해결해야 한다.</li>\n<li>테스트에서 문제가 생긴다. 즉, 일시적으로라도 단일 책임 원칙(SRP, Single Responsibility Principle)을 깨야한다.</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"main-분리\"><a href=\"#main-%EB%B6%84%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Main 분리.</h4>\n<blockquote>\n<p>시스템 생성과 사용을 분리하는 방법.</p>\n</blockquote>\n<p>main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘기며, 애플리케이션은 그저 객체를 사용한다.</p>\n<h4 id=\"팩토리\"><a href=\"#%ED%8C%A9%ED%86%A0%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>팩토리</h4>\n<blockquote>\n<p>Factory 패턴은 부모 클래스에 알려지지 않은 구체 클래스를 생성하는 패턴이며.<br>\n자식 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴이다.</p>\n</blockquote>\n<p>객체가 생성하는 시점을 애플리케이션이 결정할 필요가 있는 경우에는 Abstact factory 패턴을 사용한다.</p>\n<h4 id=\"의존성-주입\"><a href=\"#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>의존성 주입</h4>\n<blockquote>\n<p>의존성 주입(DI, Dependency Injection)은 하나의 객체가 다른 객체의 의존성을 제공하는 테크닉이다. \"의존성\"은 예를 들어 서비스로 사용할 수 있는 객체이다. 클라이언트가 어떤 서비스를 사용할 것인지 지정하는 대신, 클라이언트에게 무슨 서비스를 사용할 것인지를 말해주는 것</p>\n</blockquote>\n<p>사용과 제작을 분리하는 강력한 메커니즘. 객체는 의존성 자체를 인스턴스로 만드는 책임을 지지 않는 대신에 다른 메커니즘에 넘겨야 한다.</p>\n<ul>\n<li>해당 방법으로 'main'루틴이나 특수 컨테이너를 사용한다.</li>\n<li>스프링 프레임워크는 잘 알려진 자바 DI 컨테이너를 제공한다.</li>\n</ul>\n<h3 id=\"확장\"><a href=\"#%ED%99%95%EC%9E%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>확장</h3>\n<p>깨끗한 코드는 코드 수준에서는 시스템을 조정하고 확장하기 쉽게 만들어진다.</p>\n<p>그러나 <strong>시스템 수준</strong>에서는 그렇지 않다. 단순한 아키텍처를 복잡한 아키텍처로 조금씩 키울 수는 없다.</p>\n<ul>\n<li>따라서 소프트웨어 시스템은 관심사를 적절한 게 분리해 관리해야 한다.</li>\n</ul>\n<h4 id=\"횡단cross-cutting-관심사\"><a href=\"#%ED%9A%A1%EB%8B%A8cross-cutting-%EA%B4%80%EC%8B%AC%EC%82%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>횡단(Cross-cutting) 관심사</h4>\n<blockquote>\n<p>횡단 관심사는 다른 관심사에 영향을 미치는 프로그램의 측면이다. 이 관심사들은 디자인과 구현 면에서 시스템의 나머지 부분으로부터 깨끗이 분해되지 못하는 경우가 있을 수 있으며 분산되거나 얽히는 일이 일어날 수 있다.</p>\n</blockquote>\n<p>이를 해결하기 대처하기 위해 나온 방법론으로 <strong>관점 지향 프로그래밍</strong>(AOP, Aspet-Oriented Programming)이 있다.</p>\n<ul>\n<li>AOP에서의 관점 : 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다.</li>\n</ul>\n<h3 id=\"자바-프록시\"><a href=\"#%EC%9E%90%EB%B0%94-%ED%94%84%EB%A1%9D%EC%8B%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>자바 프록시</h3>\n<ul>\n<li>단순한 상황에 적합하다. Ex) 개별 객체나 클래스에서 메서드 호출을 감싸는 경우.</li>\n<li>JDK가 지원하는 동적 프록시는 인터페이스만 지원하며, 클래스 프록시를 사용하려면 CGLIB, ASM. Javassist 같은 바이트 코드 처리 라이브러리가 필요하다.</li>\n</ul>\n<h3 id=\"순수-자바-aop-프레임워크\"><a href=\"#%EC%88%9C%EC%88%98-%EC%9E%90%EB%B0%94-aop-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>순수 자바 AOP 프레임워크</h3>\n<p>POJO는 순수하게 도메인에 초점을 맞추며, 다른 도메인에 의존하지 않는다. 따라서 테스트가 개념적으로 더 쉽고 간단하며, 단순하여 구현에 쉬우며 이후 코드를 보수하고 개선하기 편하다.</p>\n<blockquote>\n<p>POJO(Plain Old Java Object) : 오래된 방식의 간단한 자바 오브젝트라는 말로서 Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 \"무거운\" 객체를 만들게 된 것에 반발해서 사용되게 된 용어</p>\n</blockquote>\n<h3 id=\"aspectj-관점\"><a href=\"#aspectj-%EA%B4%80%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>AspectJ 관점</h3>\n<p>AspectJ는 관심사를 관점으로 분리하는 가장 강력한 도구이다.</p>\n<ul>\n<li>AspectJ '애너테이션 폼'은 새로운 도구와 새로운 언어의 부담을 제거한다.</li>\n<li>애너테이션이란 주석처럼 프로그래밍에 영향을 미치지 않으며, 유용한 정보를 제공</li>\n</ul>\n<h3 id=\"테스트-주도-시스템-아키텍처-구축\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%B6%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>테스트 주도 시스템 아키텍처 구축</h3>\n<ul>\n<li>애플리케이션 도메인 논리를 POJO로 작성할 수 있다면 (코드 수준에서 아키텍처 관심사를 분리할 수 있다면), <strong>테스트 주도 아키텍처</strong> 구축이 가능하다.</li>\n<li>좋은 웹 사이트 들은 고도의 자료 캐싱, 보안, 가상화 등을 이용해 아주 높은 가용성과 성능을 효율적이고 유연하게 달성한다.</li>\n<li>이를 정리하면, 최선의 시스템 구조는 각기 POJO 객체로 구현되는 모듈화 된 관심사 영역(도메인)으로 구성된다. 이러한 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합하며, 이러한 구조는 테스트 주도 기법을 사용할 수 있다.</li>\n</ul>\n<h3 id=\"의사-결정을-최적화\"><a href=\"#%EC%9D%98%EC%82%AC-%EA%B2%B0%EC%A0%95%EC%9D%84-%EC%B5%9C%EC%A0%81%ED%99%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>의사 결정을 최적화</h3>\n<ul>\n<li>모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능하다.</li>\n<li>\n<p>가능한 마지막 순간까지 결정을 미루는 방법이 좋은 경우가 있는데, 이러한 경우에서 옳게 쓰일 수 있다.</p>\n<ul>\n<li>즉, 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공하고, 이러한 기민함은 최신 정보에 기반에 최선의 시점에 최적의 결정을 내리는데 도움을 준다. 더불어 결정의 복잡성도 감소한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"명백한-가치가-있을-때-표준을-현명하게-사용\"><a href=\"#%EB%AA%85%EB%B0%B1%ED%95%9C-%EA%B0%80%EC%B9%98%EA%B0%80-%EC%9E%88%EC%9D%84-%EB%95%8C-%ED%91%9C%EC%A4%80%EC%9D%84-%ED%98%84%EB%AA%85%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>명백한 가치가 있을 때 표준을 현명하게 사용</h3>\n<p>표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉬우며 컴포넌트를 엮기 쉽다.</p>\n<p>단점으로는 표준을 만드는 시간이 너무 오래 걸리게 된다면, 다른 업계가 기다리지 못한다. 더불어 표준이 목적을 잃어버리는 경우도 발생한다.</p>\n<h3 id=\"시스템은-도메인-특화-언어가-필요\"><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%ED%8A%B9%ED%99%94-%EC%96%B8%EC%96%B4%EA%B0%80-%ED%95%84%EC%9A%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>시스템은 도메인 특화 언어가 필요</h3>\n<blockquote>\n<p>도메인 특화 언어(DSL, Domain-Specific Language)이란. 간단한 스크립트 언어나 표준 언어로 구현한 API</p>\n</blockquote>\n<ul>\n<li>좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 '의사소통 간극'을 줄여주며, 도메인을 잘못 구현할 가능성이 줄어든다.</li>\n<li>추상화 수준을 코드 관용구나 디자인 패턴 이상의 효과를 만들어 낼 수 있다.</li>\n<li>DSL을 사용하면 고차원 정책에서 저 차원 세부사항에 이르기까지 모든 추상화 수준과 모든 도메인을 POJO로 표현 가능하다.</li>\n</ul>\n<h3 id=\"결론\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>결론</h3>\n<ul>\n<li>깨끗한 아키텍처는 도메인 논리를 높여주며, 기민성을 높이고, 제품 품질이 떨어지며, TDD가 제공하는 단점이 사라진다.</li>\n<li>POJO를 작성하고 관점 등을 통해 관심사를 분리해서 추상화 단계에서의 의도를 명확히 표현해야 한다.</li>\n<li>핵심 중 하나는 <strong>실제로 돌아가는 가장 단순한 수단을 사용해야 한다.</strong></li>\n</ul>\n<h2 id=\"12장-창발성\"><a href=\"#12%EC%9E%A5-%EC%B0%BD%EB%B0%9C%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>12장. 창발성</h2>\n<h3 id=\"창발적-설계로-깔끔한-코드를-구현\"><a href=\"#%EC%B0%BD%EB%B0%9C%EC%A0%81-%EC%84%A4%EA%B3%84%EB%A1%9C-%EA%B9%94%EB%81%94%ED%95%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EA%B5%AC%ED%98%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>창발적 설계로 깔끔한 코드를 구현</h3>\n<p>우수한 설계가 나오는 간단한 규칙 4가지</p>\n<ol>\n<li>모든 테스트를 실행한다</li>\n<li>중복을 없앤다.</li>\n<li>프로그래머 의도를 표현한다.</li>\n<li>클래스와 메서드 수를 최소로 줄인다.</li>\n</ol>\n<p>단 위가 밑보다 중요하다.</p>\n<h3 id=\"단순한-설계-규칙-1-모든-테스트를-실행\"><a href=\"#%EB%8B%A8%EC%88%9C%ED%95%9C-%EC%84%A4%EA%B3%84-%EA%B7%9C%EC%B9%99-1-%EB%AA%A8%EB%93%A0-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%8B%A4%ED%96%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단순한 설계 규칙 1: 모든 테스트를 실행</h3>\n<ul>\n<li>설계는 의도한 대로 돌아가야 한다.</li>\n<li>철저한 테스트가 가능한 시스템은 더 나은 설계를 만든다.</li>\n<li>결합도가 높을수록 테스트 케이스를 작성하기 어렵다.</li>\n<li>테스트 케이스를 만들고 돌리는 것 -> 낮은 결합도와 높은 응집력</li>\n</ul>\n<h3 id=\"단순한-설계-규칙-24-리팩터링\"><a href=\"#%EB%8B%A8%EC%88%9C%ED%95%9C-%EC%84%A4%EA%B3%84-%EA%B7%9C%EC%B9%99-24-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단순한 설계 규칙 2~4: 리팩터링</h3>\n<ul>\n<li>테스트 케이스를 모두 작성했다면, 코드와 클래스를 점진적으로 정리하면 된다.</li>\n<li>코드를 정리하면서 테스트 케이스를 통해 깨지지 않도록 한다.</li>\n<li>리팩터링 단계에서는 소프트웨어 설계 품질을 높이는 기법을 사용하는 것이 좋다.</li>\n<li>이 단계 동안 중복을 없애고, 프로그래머 의도를 표현하고 클래스와 메서드 수를 줄이는 단계이다.</li>\n</ul>\n<h3 id=\"중복을-없애라\"><a href=\"#%EC%A4%91%EB%B3%B5%EC%9D%84-%EC%97%86%EC%95%A0%EB%9D%BC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>중복을 없애라</h3>\n<ul>\n<li>중복은 추가 작업, 추가 위협, 불필요한 복잡도를 의미한다.</li>\n<li>TEMPLATE METHOD 패턴은 고차원 중복을 제거할 목적으로 자주사 사용하는 기법</li>\n</ul>\n<blockquote>\n<p>Templaet Method Pattern. 동작 상의 알고리즘의 프로그램 뼈대를 정의하는 행위 디자인 패턴, 알고리즘의 구조를 변경하지 않고 알고리즘의 특정 단계들을 다시 정의할 수 있게 해 준다</p>\n</blockquote>\n<h3 id=\"표현하기\"><a href=\"#%ED%91%9C%ED%98%84%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>표현하기</h3>\n<p>많은 소프트웨어 프로젝트 비용 중 대다수는 장기적인 유지보수에 들어간다.</p>\n<p>이를 해결하는 방법은 다음과 같다.</p>\n<ol>\n<li>좋은 이름 선택한다.</li>\n<li>함수와 클래스 크기를 가능한 줄인다.</li>\n<li>표준 명칭을 사용한다.</li>\n<li>단위 테스트 케이스를 꼼꼼히 작성한다.</li>\n</ol>\n<p>가장 큰 핵심은 나중에 볼 사람을 위해서 <strong>노력</strong>해야 한다.</p>\n<h3 id=\"클래스와-메서드-수를-최소로-줄이기\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%88%98%EB%A5%BC-%EC%B5%9C%EC%86%8C%EB%A1%9C-%EC%A4%84%EC%9D%B4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>클래스와 메서드 수를 최소로 줄이기</h3>\n<ul>\n<li>너무 중복을 제거하고, 의도를 표현하고, SRP를 준수하는 경우에는 단점이 발생할 수 있다.</li>\n<li>목표는 함수와 클래스 크기를 줄이면서 시스템 크기를 작게 유지하는 것이다.</li>\n<li>단, 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다.</li>\n</ul>\n<h2 id=\"13장-동시성\"><a href=\"#13%EC%9E%A5-%EB%8F%99%EC%8B%9C%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>13장. 동시성</h2>\n<p>동시성과 깔끔한 코드는 양립하기 아주 어렵다. 깨끗한 동시성은 사실 매우 중요하며, 어려운 문제이다.</p>\n<h3 id=\"동시성이-필요한-이유\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>동시성이 필요한 이유?</h3>\n<ul>\n<li>동시성은 결함(coupling)을 없애는 전략. 즉, <strong>무엇</strong>과 <strong>언제</strong>를 분리하는 전략이다.</li>\n<li>무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.</li>\n<li>시스템 응답 시간과 작업 처리량 개선으로 인해 동시성이 필요하다.</li>\n</ul>\n<h4 id=\"미신과-오해\"><a href=\"#%EB%AF%B8%EC%8B%A0%EA%B3%BC-%EC%98%A4%ED%95%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a> 미신과 오해</h4>\n<p>대표적인 오해.</p>\n<ul>\n<li>\n<p>동시성은 항상 성능을 높여준다.</p>\n<ul>\n<li>동시성은 <strong>때로</strong> 성능을 높여준다. 즉, 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.</li>\n</ul>\n</li>\n<li>\n<p>동시성을 구현해도 설계는 변하지 않는다.</p>\n<ul>\n<li>단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. 일반적으로 <strong>무엇</strong>과 <strong>언제</strong>를 분리하면 시스템 구조가 달라진다.</li>\n</ul>\n</li>\n<li>\n<p>웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.</p>\n<ul>\n<li>실제로는 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지 알아야 한다.</li>\n</ul>\n</li>\n</ul>\n<p>타당한 생각.</p>\n<ul>\n<li><strong>동시성은 사소 부하를 유발한다.</strong> 성능 측면에서 부하가 걸리며, 코드도 더 짜야한다.</li>\n<li><strong>동시성은 복잡하다.</strong> 간단한 문제라도 동시성은 복잡하다.</li>\n<li><strong>일반적으로 동시성 버그는 제한하기 어렵다.</strong> 그래서 진짜 결함으로 간주 하지 않고 일회성 문제로 여겨 무시하기 쉽다.</li>\n<li><strong>동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.</strong></li>\n</ul>\n<h3 id=\"난관\"><a href=\"#%EB%82%9C%EA%B4%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>난관</h3>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">X</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> lastIdUsed<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getNextId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">++</span>lastIdUsed<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>다음과 같은 경우. 인스턴스 X를 생성하고 lastIdUsed를 필드. 42로 설정하는 경우로 보면.</p>\n<ul>\n<li>어떤 스레드는 43을 받고 다른 스레드는 44를 받는데 저장은 제각각이다. 이러한 스레드가 수많이 있다.</li>\n</ul>\n<h3 id=\"동시성-방어-원칙\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%B0%A9%EC%96%B4-%EC%9B%90%EC%B9%99\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>동시성 방어 원칙</h3>\n<p>다양한 방어 원칙과 기술이 있다.</p>\n<h4 id=\"단일-책임-원칙srp-single-reponsibility-priniciple\"><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99srp-single-reponsibility-priniciple\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>단일 책임 원칙(SRP, Single Reponsibility Priniciple)</h4>\n<blockquote>\n<p>SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙</p>\n</blockquote>\n<p>동시성은 복잡성 하므로 다른 코드와 분리해야 한다. 아래는 고려해야 할 사항이다.</p>\n<ul>\n<li>동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.</li>\n<li>동시성 코드에는 독자적인 난관이 있으며 이는 더 어렵다.</li>\n<li>잘못 구현된 동시성 코드는 온갖 에러가 발생한다.</li>\n</ul>\n<p><strong>따라서. 동시성 코드는 다른 코드와 분리한다.</strong></p>\n<h4 id=\"따름-정리corollary--자료-범위를-제한해라\"><a href=\"#%EB%94%B0%EB%A6%84-%EC%A0%95%EB%A6%ACcorollary--%EC%9E%90%EB%A3%8C-%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%A0%9C%ED%95%9C%ED%95%B4%EB%9D%BC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>따름 정리(corollary) : 자료 범위를 제한해라</h4>\n<p>공유 객체를 사용하는 코드 <strong>임계 영역(critical</strong> section)을 synchronized 키워드로 보호하는 것뿐만 아니라, 이 수를 줄여야 한다.</p>\n<p>수가 많으면 다음과 같은 문제가 발생한다.</p>\n<ul>\n<li>보호할 임계 영역을 빼먹어서 해당 자료를 수정하는 모든 코드가 망가진다.</li>\n<li>모든 임계 영역을 올바로 보호했는지 확인하느라 똑같은 노력과 수고가 필요하다.</li>\n<li>찾기 어려운 버그를 더 찾기 힘들어진다.</li>\n</ul>\n<p><strong>따라서. 자료를 캡슐화해야 하며, 공유 자료를 최대한 줄여야 한다.</strong></p>\n<h4 id=\"따름-정리--자료-사본을-사용하기\"><a href=\"#%EB%94%B0%EB%A6%84-%EC%A0%95%EB%A6%AC--%EC%9E%90%EB%A3%8C-%EC%82%AC%EB%B3%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>따름 정리 : 자료 사본을 사용하기</h4>\n<p>공유 자료를 줄이는 최고의 방법은 공유하지 않은 방법이다. 즉, 객체를 복사해서 읽는 방법도 존재한다. 객체를 복사하는 비용이 그렇게 크지않다면 나쁘지 않는 방법이다.</p>\n<h4 id=\"따름-정리--스레드는-가능한-독립적으로-구현하라\"><a href=\"#%EB%94%B0%EB%A6%84-%EC%A0%95%EB%A6%AC--%EC%8A%A4%EB%A0%88%EB%93%9C%EB%8A%94-%EA%B0%80%EB%8A%A5%ED%95%9C-%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9C%BC%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%98%EB%9D%BC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>따름 정리 : 스레드는 가능한 독립적으로 구현하라</h4>\n<p>다른 스레드와 공유하지 않는 독립적인 스레드를 구성해라. (예를 들면 로컬 변수 등)</p>\n<p><strong>따라서, 독자적인 스레드로, 가능하다면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할한다.</strong></p>\n<h3 id=\"라이브러리를-이해하기\"><a href=\"#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>라이브러리를 이해하기.</h3>\n<p>자바 5에서 스레드를 구현한다면 다음을 고려해보기.</p>\n<ul>\n<li>스레드 환경에 안전한 컬렉션을 사용.</li>\n<li>서로 무관한 작업을 수행할 때는 executor 프레임워크 사용.</li>\n<li>가능하다면 스레드가 차단(blocking) 되지 않는 방법을 사용.</li>\n<li>일부 클래스 라이브러리는 스레드에 안전하지 못함.</li>\n</ul>\n<h4 id=\"스레드-환경에-안전한-컬렉션\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%99%98%EA%B2%BD%EC%97%90-%EC%95%88%EC%A0%84%ED%95%9C-%EC%BB%AC%EB%A0%89%EC%85%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>스레드 환경에 안전한 컬렉션</h4>\n<p>다중 스레드에서 안전한 메소드로 여러 가지 존재한다.</p>\n<table>\n<thead>\n<tr>\n<th>이름</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ConcurrentHashMap</td>\n<td>HashMap보다 거의 모든 상황에서 빠르다.</td>\n</tr>\n<tr>\n<td>ReentrantLock</td>\n<td>한 메서드에서 잠그고 다른 메서드에서 푸는 락(lock)이다.</td>\n</tr>\n<tr>\n<td>Semaphore</td>\n<td>전형적인 세마포어, 개수(count)가 있는 락이다.</td>\n</tr>\n<tr>\n<td>CountDownLatch</td>\n<td>지정한 수만큼 이벤트가 발생하고 대기 중인 스레드를 모드 해제하는 락.</td>\n</tr>\n<tr>\n<td>모든 스레드에게 동시에 공평하게 시작할 권리를 제공</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"실행-모델을-이해하기\"><a href=\"#%EC%8B%A4%ED%96%89-%EB%AA%A8%EB%8D%B8%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>실행 모델을 이해하기.</h3>\n<p>간단한 기본 용어는 다음과 같다.</p>\n<table>\n<thead>\n<tr>\n<th>이름</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>한정된 자원 (Bound Resource)</td>\n<td>다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다.</td>\n</tr>\n<tr>\n<td>데이터 베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예시이다.</td>\n<td></td>\n</tr>\n<tr>\n<td>상호 배제 (Mutual Exclusion)</td>\n<td>한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.</td>\n</tr>\n<tr>\n<td>기아 (Starvation)</td>\n<td>한 스레드나 여러 스레드가 굉장히 오랫동안 호은 영원한 자원을 기다린다.</td>\n</tr>\n<tr>\n<td>예를 들어, 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속적으로 이루어지는 경우, 긴 스레드가 기아 상태에 빠진다.</td>\n<td></td>\n</tr>\n<tr>\n<td>데드락 (Deadlock)</td>\n<td>여러 스레드가 서로가 끝나기를 기다린다.</td>\n</tr>\n<tr>\n<td>모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느쪽도 더이상 진행하지 못한다.</td>\n<td></td>\n</tr>\n<tr>\n<td>라이브락 (Livelock)</td>\n<td>락을 거는 단계에서 각 스레드가 서로를 방해한다.</td>\n</tr>\n<tr>\n<td>스레드는 계속해서 진행하려 하지만, 공명(response)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>다중 스레드 프로그래밍에서 실행하는 방법은 대부분 아래의 3가지 방법이다.</p>\n<h4 id=\"생산자-소비자producer-consumer\"><a href=\"#%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90producer-consumer\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>생산자-소비자(Producer-Consumer)</h4>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/92720407-84b49c00-f39f-11ea-971b-582f1952a73a.png\" alt=\"image\"></p>\n<p>다음 그림처럼 <strong>한정적 자원</strong>을 생산자는 정보를 생성하고, 소비자는 정보를 사용한다.</p>\n<p>생산자 스레드는 정보를 채우고 시그널을 보내고, 소비자는 대기열에 정보를 읽은 후 시그널을 보낸다. 단, 동시에 시그널을 기다릴 가능성 또한 존재한다.</p>\n<h4 id=\"읽기-쓰기readers-writers\"><a href=\"#%EC%9D%BD%EA%B8%B0-%EC%93%B0%EA%B8%B0readers-writers\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>읽기-쓰기(Readers-Writers)</h4>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/92720672-e412ac00-f39f-11ea-9905-8e06721b39ab.png\" alt=\"image\"></p>\n<p>읽기 스레드가 공유 자원을 사용하지만, 처리율이 부족한 경우 기아 현상이나 오래된 정보가 쌓인다.</p>\n<p>이러한 처리율을 높이는 방법은 여러 가지가 있는데.</p>\n<ul>\n<li>간단한 전략 : 읽기 스레드가 없을 때까지 쓰기 스레드가 버퍼를 기다리는 방법, 하지만 쓰기 스레드가 기아 발생 가능.</li>\n<li>이러한 방법을 갱신하는 밥법은 \"<strong>식사하는 철학자들</strong>\" 방법이 있다.</li>\n</ul>\n<h4 id=\"식사하는-철학자들dining-philosopheres\"><a href=\"#%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4dining-philosopheres\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>식사하는 철학자들(Dining Philosopheres)</h4>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/92725422-196ec800-f3a7-11ea-8f11-9ff2bbac63f6.png\" alt=\"image\"></p>\n<p>여기서 철학자는 스레드이고, 포크는 자원이다. 여기서, 자원을 얻으려면 몇몇의 스레드는 쉬어야 하는 것을 알 수 있다.</p>\n<p>단 이와 같은 설계를 할 때는 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 고려해서 사용해야 한다.</p>\n<h3 id=\"동기화하는-메서드-사이에-존재하는-의존성을-이해\"><a href=\"#%EB%8F%99%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%82%AC%EC%9D%B4%EC%97%90-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%84-%EC%9D%B4%ED%95%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>동기화하는 메서드 사이에 존재하는 의존성을 이해</h3>\n<ul>\n<li><strong>공유 객체 하나에는 메서드 하나만 사용하기.</strong></li>\n</ul>\n<p>공유 객체 하나에 여러 메서드가 필요한 경우는 다음과 같은 세 가지 방법을 고려한다.</p>\n<ul>\n<li>클라이언트에서 잠금 : 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠금. 마지막 메서드를 호출할 때까지 잠금을 유지한다</li>\n<li>서버에서 잠금 : 서버에다 \"서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는\" 메서드를 구현. 클라이언트는 이 메서드를 구현</li>\n<li>연결(Adapted) 서버 : 잠금을 수행하는 중간 단계를 생성. '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경하지 않음</li>\n</ul>\n<h3 id=\"동기화하는-부분을-작게-만들기\"><a href=\"#%EB%8F%99%EA%B8%B0%ED%99%94%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84%EC%9D%84-%EC%9E%91%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>동기화하는 부분을 작게 만들기</h3>\n<p>필요 이상으로 임계 영역 크기를 키우면 스레드 간 경쟁이 늘어나고 프로그램 성능이 떨어진다.</p>\n<p><strong>따라서. 동기화하는 부분을 최대한 작게 만든다.</strong></p>\n<h3 id=\"올바른-종료-코드는-구현하기-어렵다\"><a href=\"#%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%A2%85%EB%A3%8C-%EC%BD%94%EB%93%9C%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-%EC%96%B4%EB%A0%B5%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>올바른 종료 코드는 구현하기 어렵다</h3>\n<p>데드락에 걸려서 종료 코드가 안 갈 수도 있다. 따라서 <strong>종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현해야 한다. 생각보다 오래 걸리고 어려우므로 나온 알고리즘을 검토하는 것도 좋은 방법이다.</strong></p>\n<h3 id=\"스레드-코드-테스트하기\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>스레드 코드 테스트하기</h3>\n<p>하나의 스레드에서는 이전에 했던 모든 말 들이 통용되지만, 여러 스레드에서의 상황은 복잡하다.</p>\n<p><strong>따라서. 문제를 노출하는 테스트 케이스를 작성한다. 프로그램 설정과 시스템 설정과 부하를 바꿔가면서 자주 돌리고 테스트가 실패할 경우 원인을 추적해야 한다. 다시 돌렸더니 통과한다는 이유로 넘어가면 안 된다.</strong></p>\n<p>구체적인 지침은 다음과 같다.</p>\n<ul>\n<li>\n<p>말이 안 되는 실패를 잠정적인 스레드 문제로 취급하기</p>\n<ul>\n<li>시스템 실패를 '일회성'이라고 취급하지 말기.</li>\n</ul>\n</li>\n<li>\n<p>다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들기</p>\n<ul>\n<li>스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하면 안 된다. 먼저 스레드 환경 밖부터 해결해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현</p>\n<ul>\n<li>다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현</li>\n</ul>\n</li>\n<li>\n<p>다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정해주기</p>\n<ul>\n<li>프로그램 처리율과 효율에 따라 스레드 개수를 조율하는 코드도 고민해보기</li>\n</ul>\n</li>\n<li>\n<p>프로세서 수보다 많은 스레드 돌려보기</p>\n<ul>\n<li>스와핑이 잦을수록 임계 영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.</li>\n</ul>\n</li>\n<li>\n<p>다른 플랫폼에서 돌려보기</p>\n<ul>\n<li>처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려보는 것이 좋다.</li>\n</ul>\n</li>\n<li>\n<p>코드에 보조 코드(instruction)를 넣어 돌리기. 강제로 실패 만들기.</p>\n<ul>\n<li>\n<p>방법 1. 직접 구현하기</p>\n<ul>\n<li>코드에다 wait(), sleep(), yield(), probity() 함수를 추가하기.</li>\n<li>생각했는 결과물과 맞는지 체크하기.</li>\n</ul>\n</li>\n<li>\n<p>방법 2. 자동화</p>\n<ul>\n<li>AOP(Aspect-Oriented Framework), CGLIB, ASM 등의 도구를 사용</li>\n<li><strong>흔들기 기법</strong>(jiggle) 등을 사용해 오류를 찾는 것도 좋다. 이를 사용하면 스레드를 매번 다른 순서로 실행한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"결론-1\"><a href=\"#%EA%B2%B0%EB%A1%A0-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>결론.</h3>\n<p>핵심은 다음과 같다.</p>\n<ul>\n<li>SRP를 준수하기</li>\n<li>동시성 오류를 일으키는 잠정적 원인을 정학하게 이해</li>\n<li>사용하는 라이브러리와 기본 알고리즘을 정확히 이해</li>\n<li>보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해</li>\n</ul>\n"}},{"node":{"title":"[Review] Clean Code 내용정리 - 6","path":"/06-clean-code/","date":"6. November 2020","timeToRead":7,"description":" Clean code 책 정리 마지막 편입니다. ","content":"<h1 id=\"clean-code-내용-정리---6\"><a href=\"#clean-code-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC---6\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Clean Code 내용 정리 - 6</h1>\n<h2 id=\"부록-a-동시성\"><a href=\"#%EB%B6%80%EB%A1%9D-a-%EB%8F%99%EC%8B%9C%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>부록 A. 동시성</h2>\n<h3 id=\"\"></h3>\n<p>클라이언트/서버 예제</p>\n<h4 id=\"서버\"><a href=\"#%EC%84%9C%EB%B2%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서버</h4>\n<p>애플리케이션에서 많은 시간을 보내는 가능성은 크게 2개이다.</p>\n<ul>\n<li>I/O : 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 emd</li>\n<li>프로세서 : 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등</li>\n</ul>\n<p>일반적으로 프로그램이 <strong>프로세서 연산에 많은 시간을 보낸다면, 하드웨어를 추가하여 성능을 높여야 한다.</strong>  </p>\n<p>즉, 스레드를 늘린다고 해결할 수 있는 문제가 아니다.</p>\n<p>하지만 프로그램이 주로 <strong>I/O 연산에 시간을 보낸다면 동시성이 성능을 높여 줄 수 있다.</strong></p>\n<h4 id=\"결론\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>결론</h4>\n<p>단일스레드 시스템에서 다중 스레드 시스템으로 변환하고, 성능을 높이기 위해서는 다음과 같은 방법을 사용해야한다.</p>\n<ul>\n<li>I/O에 많은 시간을 보내야 한다.</li>\n<li>관련된 코드를 분리시켜 여러개의 클래스로 분리해 <strong>단일 책임 원칙</strong>을 지켜야 한다.</li>\n</ul>\n<h3 id=\"가능한-실행-경로\"><a href=\"#%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%8B%A4%ED%96%89-%EA%B2%BD%EB%A1%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>가능한 실행 경로</h3>\n<p>10000개의 스레드로 현재 값인 변수에 1을 더한다고 했을 때 가정했을때,  </p>\n<p>최악의 경우는 1부터 10000까지 나올 수 있다.</p>\n<p>이를 해결하기 위해서는 ...</p>\n<h4 id=\"심층-분석\"><a href=\"#%EC%8B%AC%EC%B8%B5-%EB%B6%84%EC%84%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>심층 분석</h4>\n<p>3가지 정의를 이야기할 수 있다.</p>\n<ul>\n<li><strong>프레임</strong> : 모든 메서드 호출에는 프레임이 필요하다</li>\n<li><strong>지역 변수</strong> : 메서드 범위 내에 정의되는 모든 변수를 가리킴</li>\n<li><strong>피연산자 스택</strong> : JVM이 지원하는 명령 대다수는 매개변수를 받으며, 이 매개변수를 저장하는 장소</li>\n</ul>\n<p>이 3개를 atomic으로 잘 처리한다면, 결과는 일정하다.</p>\n<h5 id=\"결론-1\"><a href=\"#%EA%B2%B0%EB%A1%A0-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>결론</h5>\n<p>스레드가 서로의 작업을 덮어쓰는 과정을 이해하기 위해서는 어떤 연산이 안전한지 못한지에 파악할 수 있도록 메모리 모델을 이해하고 있어야한다.</p>\n<p>즉, 아래의 3가지를 이해해야 한다.</p>\n<ul>\n<li>공유 객체/값이 있는 곳</li>\n<li>동시 읽기/수정 문제를 일으킬 소지가 있는 코드</li>\n<li>동시성 문제를 방지하는 법</li>\n</ul>\n<h3 id=\"라이브러리를-이해하기\"><a href=\"#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>라이브러리를 이해하기</h3>\n<h4 id=\"executor-프레임워크\"><a href=\"#executor-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Executor 프레임워크</h4>\n<ul>\n<li>스레드 풀링으로 정교한 실행을 지원한다.</li>\n<li>코드가 깔끔해지고 이해하기 쉬워지며, 크기가 작아진다.</li>\n<li>스레드 풀 크기를 자동으로 조정하며, 재사용할 수 있다.</li>\n</ul>\n<h4 id=\"스레드를-차단하지-않는-방법non-blocking\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EB%A5%BC-%EC%B0%A8%EB%8B%A8%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EB%B0%A9%EB%B2%95non-blocking\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>스레드를 차단하지 않는 방법(non blocking)</h4>\n<ul>\n<li>\n<p>최신 프로세서는 blocking 하지 않고 안정적으로 값을 갱신한다.</p>\n<ul>\n<li>Ex) AtomicInteger, incrementAndGet() 등등</li>\n</ul>\n</li>\n<li>현대 프로세서는 CAS(Compare and Swap)을 지원한다.</li>\n</ul>\n<h4 id=\"다중-스레드-환경에서-안전하지-않은-클래스\"><a href=\"#%EB%8B%A4%EC%A4%91-%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EC%95%88%EC%A0%84%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>다중 스레드 환경에서 안전하지 않은 클래스</h4>\n<p>다중 스레드 환경에서 안정하지 않는 환경은 다음과 같다.</p>\n<ul>\n<li>SimpleDateFormat</li>\n<li>데이터베이스 연결</li>\n<li>java.util 컨테이너 클래스</li>\n<li>서블릿</li>\n</ul>\n<h3 id=\"메서드-사이에-존재하는-의존성-조심\"><a href=\"#%EB%A9%94%EC%84%9C%EB%93%9C-%EC%82%AC%EC%9D%B4%EC%97%90-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A1%B0%EC%8B%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>메서드 사이에 존재하는 의존성 조심</h3>\n<p>추적하기 어렵지만 이를 해결하는 방안은 크게 3가지로 구성된다.</p>\n<h4 id=\"1-실패를-용인하기\"><a href=\"#1-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EC%9A%A9%EC%9D%B8%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 실패를 용인하기</h4>\n<h4 id=\"2-클라이언트-기반-잠금\"><a href=\"#2-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EA%B8%B0%EB%B0%98-%EC%9E%A0%EA%B8%88\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 클라이언트-기반 잠금</h4>\n<p>굉장히 위험한 전략이다.</p>\n<h4 id=\"3-서버-기반-잠금\"><a href=\"#3-%EC%84%9C%EB%B2%84-%EA%B8%B0%EB%B0%98-%EC%9E%A0%EA%B8%88\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 서버-기반 잠금</h4>\n<p>일반적으로 가장 바람직한 방법이다.</p>\n<ul>\n<li>코드 중복이 줄어든다.</li>\n<li>성능이 좋아진다.</li>\n<li>오류가 발생할 가능성이 줄어든다.</li>\n<li>스레드 정책이 하나이다.</li>\n<li>공유 변수 범위가 절어든다.</li>\n</ul>\n<h3 id=\"작업-처리량-높이기\"><a href=\"#%EC%9E%91%EC%97%85-%EC%B2%98%EB%A6%AC%EB%9F%89-%EB%86%92%EC%9D%B4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>작업 처리량 높이기</h3>\n<p>동기화 영역은 언제나 작아야한다.</p>\n<h3 id=\"데드락\"><a href=\"#%EB%8D%B0%EB%93%9C%EB%9D%BD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>데드락</h3>\n<p>데드락의 4가지 조건</p>\n<ul>\n<li>상호 배제 (Mutual Exclusion)</li>\n<li>잠금 &#x26; 대기 (Lock &#x26; Wait)</li>\n<li>선점 불가 (No Preemption)</li>\n<li>순환 대기 (Circular Wait)</li>\n</ul>\n<h4 id=\"상호-배제\"><a href=\"#%EC%83%81%ED%98%B8-%EB%B0%B0%EC%A0%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>상호 배제</h4>\n<ul>\n<li>정의 : 여러 스레드가 동시에 사용하지 못하고, 개수가 제한적인 경우</li>\n<li>\n<p>해결책</p>\n<ul>\n<li>동시에 사용해도 괜찮은 자원을 사용, Ex) Atomic</li>\n<li>스레드 수 이상으로 자원 수를 높임</li>\n<li>자원을 점유하기 전에 필요한 자원이 모두 있는지 확인</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"잠금--대기\"><a href=\"#%EC%9E%A0%EA%B8%88--%EB%8C%80%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>잠금 &#x26; 대기</h4>\n<ul>\n<li>정의 : 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않는다.</li>\n<li>\n<p>해결책</p>\n<ul>\n<li>대기하지 않기</li>\n</ul>\n</li>\n<li>\n<p>문제점</p>\n<ul>\n<li>기아(Starvation) : 한 스레드가 계속해서 필요한 자원을 점유하지 못하는 것</li>\n<li>라이브락(Livelock) : 여러 스레드가 한번에 잠금으로 들어가 계속 자원을 점유했다 내놨다를 반복하는 것</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"선점-불가\"><a href=\"#%EC%84%A0%EC%A0%90-%EB%B6%88%EA%B0%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>선점 불가</h4>\n<ul>\n<li>정의 : 한 스레드가 다른 스레드로부터 자원을 빼앗지 못함</li>\n<li>\n<p>해결책</p>\n<ul>\n<li>다른 자원을 뺏어오기</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"순환-대기\"><a href=\"#%EC%88%9C%ED%99%98-%EB%8C%80%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>순환 대기</h4>\n<ul>\n<li>정의 : 스레드 A는 B가 끝나기를 기다리고, 스레드 B는 A가 끝나기를 기다리는 상황</li>\n<li>해결책 : 간단한 규약을 설정해서 순환이 없도록 한다</li>\n<li>\n<p>문제점</p>\n<ul>\n<li>자원을 할당하는 순서와 자원을 사용하는 순서를 다르게 한다</li>\n<li>때로는 순서에 따라 자원을 할당하기 어려움</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"다중-스레드-코드-테스트\"><a href=\"#%EB%8B%A4%EC%A4%91-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>다중 스레드 코드 테스트</h3>\n<ul>\n<li>몬테 카를로 테스트 : 조율이 가능하게 유연하게 테스트를 만든다</li>\n<li>시스템을 배치할 플랫폼 전부에서 테스트를 돌린다</li>\n<li>부하가 변하는 장비에서 테스트를 돌린다.</li>\n</ul>\n<h3 id=\"스레드-코드-테스트를-도와주는-도구\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BD%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EB%8F%84%EC%99%80%EC%A3%BC%EB%8A%94-%EB%8F%84%EA%B5%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>스레드 코드 테스트를 도와주는 도구</h3>\n<p>대표적인 예시로 IBM의 ConTest가 있다.</p>\n<p>사용방법은 다음과 같다.</p>\n<ul>\n<li>실제 코드와 테스트 코드 작성</li>\n<li>ConTest로 실제 코드와 테스트 코드에 보조 코드 추가</li>\n<li>테스트를 실행</li>\n</ul>\n<hr>\n<p>드디어 정리 완료.</p>\n<p><strong>부록 B. org.jfree.date.SerialDate</strong> 와 <strong>부록 C. 휴리스틱의 교차 참조 목록</strong> 은 코드 위주라서, 해당 부분을 따로 추가하지 않았다.</p>\n<p>점차 이전의 게시글을 틈틈이 수정하면서 가독성을 높이는 작업을 할 예정.</p>\n<p>책의 내용을 대부분 정리하기는 했지만, 코드나 원글의 내용을 다 담지 못한 듯 하여 한번 책을 읽어보는 것이 좋을 듯합니다.</p>\n"}}]}}},"context":{}}