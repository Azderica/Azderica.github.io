{"hash":"49b01721c2ed4f1361ca6db09477053f31e960ba","data":{"tag":{"title":"Serialization","belongsTo":{"edges":[{"node":{"title":"[Java] Effective Java, Serialization","path":"/11-java-effective-java/","date":"24. May 2021","timeToRead":28,"description":"Effective Java 책 중, ch12. 직렬화에 대해 정리합니다.","content":"<h1 id=\"serialization\"><a href=\"#serialization\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Serialization</h1>\n<p>아래에서는 자바 직렬화의 위험성과 이를 최소화하는 방법을 중점으로 합니다.</p>\n<ul>\n<li><a href=\"https://azderica.github.io/java-serialize/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바 직렬화란</a></li>\n</ul>\n<h2 id=\"item-85-자바-직렬화의-대안을-찾습니다\"><a href=\"#item-85-%EC%9E%90%EB%B0%94-%EC%A7%81%EB%A0%AC%ED%99%94%EC%9D%98-%EB%8C%80%EC%95%88%EC%9D%84-%EC%B0%BE%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Item 85. 자바 직렬화의 대안을 찾습니다.</h2>\n<p>최초의 자바에 직렬화가 추가되었을 때는 다소 위험한 것으로 알려졌습니다. 이는 보이지 않는 생성자였고 API와 구현 사이의 경계가 흐려졌습니다. 또한 정확성, 성능, 보안 및 유지 관리 문제가 발생할 가능성이 있어서 입니다.</p>\n<p>그러나 근본적인 자바 직렬화의 위험은 아래와 같습니다.</p>\n<ul>\n<li>공격 범위가 너무 넓습니다.</li>\n<li>지속적으로도 더 넓어져서 방어하기도 어렵습니다.</li>\n</ul>\n<p>이러한 문제들의 원인은 <code class=\"language-text\">OutputInputStream</code>의 <code class=\"language-text\">readObject</code> 메서드가 호출되면서 객체 그래프가 역직렬화(deserialization)가 되기 때문입니다.</p>\n<p>바이트 스트림을 역직렬화하는 과정에서 <code class=\"language-text\">readObject</code> 메서드는 그 타입들 안의 모드 코드를 수행할 수 있습니다. (즉, 타입들의 코드 전체가 악의적인 공격 범위에 들어갑니다.)</p>\n<p><strong>역직렬화 과정에서 호출되어 잠재적인 위험한 동작을 수행하는 메서드</strong>를 <strong>가젯(gadget)</strong> 이라고 합니다. 하나의 가젯이 여러개의 가젯이 마음대로 코드를 수행할 수 있기 때문에 아주 신중하게 제작된 바이트 스트림만 역직렬화를 해야합니다.</p>\n<p>역직렬화에 시간이 오래걸리는 짧은 스트림을 <strong>역직렬화 폭탄(deserialization bomb)</strong> 이라고 합니다. 아래는 그 예시입니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">bomb</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> root <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> s1 <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> s2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    t1<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Make t1 unequal to t2</span>\n    s1<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>t1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  s1<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    s2<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>t1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  s2<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    s1 <span class=\"token operator\">=</span> t1<span class=\"token punctuation\">;</span>\n    s2 <span class=\"token operator\">=</span> t2<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">serialize</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Method omitted for brevity</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>이를 호출해버리면, 깊이가 100단계까지 호출됩니다. 이를 역직렬화 하려면 2^100 번 넘게 호출해야합니다.</p>\n<p>이 문제를 해결하기 위해서는 자바 직렬화 대신 <strong>크로스-플랫폼 구조화된 데이터 표현 방법</strong> 을 사용하는 것이 좋습니다. 예로는 JSON, protocol buffer 등이 있습니다. 프로토콜 버퍼는 이진 표현이라 효율이 훨씬 더 높으며, JSON은 텍스트 기반이라 사람이 읽을 수 있는 장점이 있습니다.</p>\n<p>직렬화를 대체할 수 없다면, 반드시 <strong>신뢰할 수 있는 데이터만 역직렬화</strong> 해야합니다. 직렬화를 피할 수 없고, 역직렬화한 데이터가 안전하지 확실할 수 없다면 객체 역직렬화 필터링을 사용하면 됩니다.</p>\n<p>다만, 직렬화는 위험 요소가 많습니다. 시간과 노력을 쓰더라도, JSON 등으로 마이그레이션하는 것을 추천합니다.</p>\n<br/>\n<h2 id=\"item-86-serializable을-구현할지에-대해-신중히-결정합니다\"><a href=\"#item-86-serializable%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0%EC%A7%80%EC%97%90-%EB%8C%80%ED%95%B4-%EC%8B%A0%EC%A4%91%ED%9E%88-%EA%B2%B0%EC%A0%95%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Item 86. <code class=\"language-text\">Serializable</code>을 구현할지에 대해 신중히 결정합니다.</h2>\n<p>직렬화 가능한 클래스는 <code class=\"language-text\">Serializable</code>을 구현하면 됩니다. 이를 구현하는 것은 싶지만, 구현을 했을 때의 대가는 매우 비쌉니다. 구현한 순간부터 많은 위험성을 가지게 되고, 확장성을 잃게 됩니다.</p>\n<h3 id=\"직렬화-클래스의-단점\"><a href=\"#%EC%A7%81%EB%A0%AC%ED%99%94-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>직렬화 클래스의 단점</h3>\n<h4 id=\"1-릴리즈가-된-이후-유연성을-감소합니다\"><a href=\"#1-%EB%A6%B4%EB%A6%AC%EC%A6%88%EA%B0%80-%EB%90%9C-%EC%9D%B4%ED%9B%84-%EC%9C%A0%EC%97%B0%EC%84%B1%EC%9D%84-%EA%B0%90%EC%86%8C%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 릴리즈가 된 이후, 유연성을 감소합니다.</h4>\n<p><code class=\"language-text\">Serializable</code>을 구현하면 직렬화 형태도 하나의 공개 API가 됩니다. 직렬화 형태는 적용 당시 클래스의 내부 구현 방식에 종속적입니다. 또한 클래스의 private과 package 인스턴스 필드마저 API로 공개되기 때문에 캡슐화도 깨집니다.</p>\n<p>클래스의 내부 구현을 수정할 시, 원래의 직렬화 형태와 달라집니다. 구버전의 인스턴스를 직렬화한 후 신버전 클래스로 역직렬화를 시도하면 오류가 발생합니다.</p>\n<p>한편 수정을 어렵게 만드는 요소로 <code class=\"language-text\">SerialVersionUID</code>를 뽑을 수 있습니다. 모든 직렬화된 클래스는 고유 식별 번호를 부여받으며, 클래스 내부에 직접 명시하지 않는 경우에 시스템이 런타임에 자동으로 생성됩니다. <code class=\"language-text\">SUID</code>를 생성할 때는 클래스의 이름, 구현하도록 선언한 인터페이스 등이 고려됩니다. 따라서 나중에 수정한다면 <code class=\"language-text\">SUID</code> 값도 변하게 됩니다. 이러한 자동으로 생성된 값은 호환성이 쉽게 깨집니다.</p>\n<h4 id=\"2-버그와-보안에-취약합니다\"><a href=\"#2-%EB%B2%84%EA%B7%B8%EC%99%80-%EB%B3%B4%EC%95%88%EC%97%90-%EC%B7%A8%EC%95%BD%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 버그와 보안에 취약합니다.</h4>\n<p>자바에서는 객체를 생성자를 통해서 만듭니다. 그러나 직렬화는 이러한 언어의 기본 방식을 우회하면서 객체를 생성합니다. 역직렬화는 일반 생성자의 문제가 발생하는 숨은 생성자입니다. 역직렬화를 사용하면 불변식이 깨질 수 있으며 허가되지 않은 접근에 쉽게 노출될 수 있습니다.</p>\n<h4 id=\"3-테스트-부담-요소가-증가합니다\"><a href=\"#3-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%B6%80%EB%8B%B4-%EC%9A%94%EC%86%8C%EA%B0%80-%EC%A6%9D%EA%B0%80%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. 테스트 부담 요소가 증가합니다.</h4>\n<p>직렬화 가능한 클래스가 수정되면, 새로운 버전의 인스턴스를 직렬화 한후에 구버전으로 역직렬화가 가능한지 테스트해야합니다. 물론 그 반대 경우도 테스트 해야합니다.</p>\n<h3 id=\"serializable-구현\"><a href=\"#serializable-%EA%B5%AC%ED%98%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><code class=\"language-text\">Serializable</code> 구현</h3>\n<p><code class=\"language-text\">Serializable</code> 구현 여부는 쉽게 결정할 것이 아닙니다. 클래스를 설계할 때마다 따르는 이득과 비용을 잘 고려해야합니다. 에를 들어 <code class=\"language-text\">BigInteger</code>과 <code class=\"language-text\">Instant</code> 같은 값 클래스와 컬렉션 클래스는 <code class=\"language-text\">Serializable</code>을 구현하였으며 스레드 풀처럼 동작하는 객체를 표현한 클래스는 대부분 구현하지 않았습니다.</p>\n<p>따라서 아<code class=\"language-text\">Serializable</code>을 구현하면 안되는 경우가 많습니다.</p>\n<h4 id=\"상속-목적으로-설계된-클래스와-대부분의-인터페이스는-serializable을-구현하면-안됩니다\"><a href=\"#%EC%83%81%EC%86%8D-%EB%AA%A9%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%84%A4%EA%B3%84%EB%90%9C-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%8C%80%EB%B6%80%EB%B6%84%EC%9D%98-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-serializable%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>상속 목적으로 설계된 클래스와 대부분의 인터페이스는 <code class=\"language-text\">Serializable</code>을 구현하면 안됩니다.</h4>\n<p>클래스를 확장하거나 인터페이스를 구현하는 대상에게 위험성을 제공합니다. 하지면 <code class=\"language-text\">Serializable</code>를 구현한 클래스만 지원하는 프레임워크를 사용해야한다면 어쩔 수 없습니다. 이러한 경우처럼 직렬화와 확장이 모두 가능한 클래스를 만들어야한다면 하위 클래스에서 <code class=\"language-text\">finalize</code> 메서드를 재정의를 방지해야합니다. 일반적으로는 재정의하고 <code class=\"language-text\">final</code> 키워드를 붙이면 되며, 인스턴스 필드 중 기본값으로 초기화되어서 위배되는 불변식이 있는 경우에는 아래와 같은 메서드를 추가합니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">readObjectNoData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InvalidObjectException</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InvalidObjectException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Stream data required\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"내부-클래스는-직렬화를-구현하면-안됩니다\"><a href=\"#%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%A7%81%EB%A0%AC%ED%99%94%EB%A5%BC-%EA%B5%AC%ED%98%84%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>내부 클래스는 직렬화를 구현하면 안됩니다.</h4>\n<p>내부 클래스는 바깥 인스턴스의 참조와 유효 범위에 속한 지역변수를 저장하기 위한 필드가 필요합니다. 그렇기에 기본 직렬화 형태가 명확하지 않습니다. 이 필드들은 컴파일러가 자동으로 추가를 하는데, 이 필드들이 어떻게 추가될 지 모릅니다. (정적 멤버 클래스는 다릅니다.)</p>\n<br/>\n<h2 id=\"item-87-커스텀-직렬화-형태를-고려합니다\"><a href=\"#item-87-%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%A7%81%EB%A0%AC%ED%99%94-%ED%98%95%ED%83%9C%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Item 87. 커스텀 직렬화 형태를 고려합니다.</h2>\n<p>클래스가 <code class=\"language-text\">Serializable</code> 을 구현하고 기본 직렬화 형태를 사용한다면 현재의 구현에 종속적이게 됩니다. 즉, 기본 직렬화 형태를 버릴 수 없게 됩니다. 따라서 유연성, 성능, 정확성과 같은 측면을 고민한 후에 합당하다고 생각되는 경우에 한해 기본 직렬화 형태를 사용해야합니다.</p>\n<h3 id=\"이상적인-직렬화-형태\"><a href=\"#%EC%9D%B4%EC%83%81%EC%A0%81%EC%9D%B8-%EC%A7%81%EB%A0%AC%ED%99%94-%ED%98%95%ED%83%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>이상적인 직렬화 형태</h3>\n<p>기본 직렬화 형태는 객체가 포함한 데이터 뿐만 아니라, 그 객체를 시작으로 접근할 수 있는 모든 객체와 객체들의 연결된 정보까지 나타냅니다. 이상적인 직렬화의 형태는 물리적인 모습과 독립된 논리적인 모습만을 표현해야합니다. 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태를 선택해도 무방합니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Name</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token annotation punctuation\">@serial</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> lastName<span class=\"token punctuation\">;</span>\n\n  <span class=\"token annotation punctuation\">@serial</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> firstName<span class=\"token punctuation\">;</span>\n\n  <span class=\"token annotation punctuation\">@serial</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> middleName<span class=\"token punctuation\">;</span>\n\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>이름은 논리적으로 성, 이름, 중간 이름으로 3개의 문자열로 구성되는데 위 클래스의 인스턴스 필드들은 논리적인 구성 요소를 정확하게 반영합니다.</p>\n<p>기본 직렬화 형태가 적합해도 불변식 보장과 보안을 위해서 <code class=\"language-text\">readObject</code> 메서드를 제공해야하는 경우가 많습니다. 앞에 있는 코드의 경우, lastName과 firstName 필드는 null이 아님을 <code class=\"language-text\">readObject</code> 메서드가 보장해야합니다.</p>\n<h3 id=\"부적절한-직렬화-형태\"><a href=\"#%EB%B6%80%EC%A0%81%EC%A0%88%ED%95%9C-%EC%A7%81%EB%A0%AC%ED%99%94-%ED%98%95%ED%83%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>부적절한 직렬화 형태</h3>\n<p>객체의 물리적 표현과 논리적 내용이 같은 경우, 기본 직렬화 형태를 선택해도 됩니다. 그러나 적절하지 않는 경우도 있습니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StringList</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">Entry</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Entry</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">String</span> data<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Entry</span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Entry</span> previous<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// ... 생략</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>위의 클래스 경우에는 여러 문제점이 있습니다. 논리적으로 문자열을 표현했고 물리적으로는 문자열들을 이중 연결 리스트로 표현했습니다. 이 클래스에 기본 직렬화 형태를 사용하면 각 노드에 연결된 노드들까지 모두 표현하기 때문에 다음과 같은 문제가 발생합니다.</p>\n<ul>\n<li>\n<p>공개 API가 현재의 내부 표현 방식에 종속적이게 됩니다.</p>\n<ul>\n<li>향후 버전에서 연결 리스트를 사용하지 않더라도, 관련 처리가 필요해집니다.</li>\n<li>코드를 제거할 수가 없습니다.</li>\n</ul>\n</li>\n<li>\n<p>사이즈가 큽니다</p>\n<ul>\n<li>기본 직렬화를 사용할 때 각 노드의 연결 정보까지 모두 포함될 것입니다.</li>\n<li>이는 내부 구현이며 직렬화 형태에 가치가 없으며 네트워크 전송 속도를 느리게 합니다.</li>\n</ul>\n</li>\n<li>\n<p>시간이 많이 걸립니다.</p>\n<ul>\n<li>직렬화 로직은 객체 그래프의 위상에 관한 정보를 알 수 없으니, 직접 순회할 수 밖에 없습니다.</li>\n</ul>\n</li>\n<li>\n<p>스택 오버플로를 발생시킵니다.</p>\n<ul>\n<li>기본 직렬화 형태는 객체 그래프를 재귀 순회하며, 호출 정도가 많아지면 스택이 감당을 하지 못합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"합리적인-직렬화-형태\"><a href=\"#%ED%95%A9%EB%A6%AC%EC%A0%81%EC%9D%B8-%EC%A7%81%EB%A0%AC%ED%99%94-%ED%98%95%ED%83%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>합리적인 직렬화 형태</h3>\n<p>이를 수정해서 합리적인 직렬화 형태는 다음과 같습니다. 단순히 리스트가 포함한 문자열의 개수와 문자열만 있는 것이 좋습니다. 위의 부적절한 코드를 개선한 형태입니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StringList</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">transient</span> <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">transient</span> <span class=\"token class-name\">Entry</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Entry</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">String</span> data<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Entry</span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Entry</span> previous<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">writeObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ObjectOutputStream</span> stream<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">{</span>\n    stream<span class=\"token punctuation\">.</span><span class=\"token function\">defaultWriteObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    stream<span class=\"token punctuation\">.</span><span class=\"token function\">writeInt</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Entry</span> e <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span> e <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> e <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      s<span class=\"token punctuation\">.</span><span class=\"token function\">writeObject</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ObjectInputStream</span> stream<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ClassNotFoundException</span> <span class=\"token punctuation\">{</span>\n    stream<span class=\"token punctuation\">.</span><span class=\"token function\">defaultReadObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> numElements <span class=\"token operator\">=</span> stream<span class=\"token punctuation\">.</span><span class=\"token function\">readInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> numElements<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> stream<span class=\"token punctuation\">.</span><span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// ... 생략</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>위 코드에서 특별한 키워드인 <code class=\"language-text\">transient</code>를 확인할 수 있습니다. <code class=\"language-text\">transient</code> 키워드가 붙은 필드는 기본 직렬화 형태에 포함되지 않습니다. 클래스의 모든 필드가 <code class=\"language-text\">transient</code>로 선언되어 있더라도 <code class=\"language-text\">writeObject</code> 와 <code class=\"language-text\">readObject</code> 메서드는 <code class=\"language-text\">defaultWriteObject</code>와 <code class=\"language-text\">defaultReadObject</code> 메서드를 호출합니다. 직렬화 명세에서는 이 과정을 무조건 진행할 것을 요구합니다. 이렇게 함으로써 향후 릴리즈에서 <code class=\"language-text\">transient</code>가 아닌 필드가 추가되더라도 상위와 하위 모두 호환이 가능하기 때문입니다.</p>\n<p>신버전의 인스턴스를 직렬화하고 구버전으로 역직렬화할시, 새로 추가된 필드는 무시됩니다. 그리고 구버전의 <code class=\"language-text\">readObject</code> 메서드에서 <code class=\"language-text\">defaultReadObject</code>를 호출하지 않는다면 역직렬화 과정에서 <code class=\"language-text\">StreamCorruptedException</code>이 발생합니다.</p>\n<p>기본 직렬화 여부에 관계없이 <code class=\"language-text\">defaultWriteObject</code> 메서들 호출하면 <code class=\"language-text\">transient</code>로 선언하지 않은 모든 필드는 직렬화됩니다. 따라서, <code class=\"language-text\">transient</code> 키워드를 선언해도 되는 필드라면 붙이는 것이 좋습니다. 즉, 논리적 상태와 무관한 필드라고 판단될 때 생략하는 것이 좋습니다.</p>\n<p>기본 직렬화를 사용한다면, 역직렬화를 할 때는 <code class=\"language-text\">transient</code> 필드는 기본 값으로 초기화됩니다. 기본 값을 변경해야 하는 경우에는 <code class=\"language-text\">readObject</code> 메서드에서 <code class=\"language-text\">defaultReadObject</code> 메서드를 호출한 다음 원하는 값으로 지정하면 됩니다. 아니면 값을 처음 사용할 때 초기화해도 됩니다.</p>\n<p>기본 직렬화 사용 여부와 상관없이 직렬화에도 동기화 규칙을 적용해야합니다. 예를 들어 모든 메서드를 <code class=\"language-text\">synchronized</code> 로 선언하여 스레드에 안전하게 만든 객체에 기본 직렬화를 사용한다면 <code class=\"language-text\">writeObject</code> 도 아래처럼 수정해야 합니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">writeObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ObjectOutputStream</span> stream<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOExceptions</span> <span class=\"token punctuation\">{</span>\n  stream<span class=\"token punctuation\">.</span><span class=\"token function\">defaultWriteObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>어떤 직렬화 형태를 선택하더라도, 직렬화가 가능한 클래스에는 <code class=\"language-text\">SerialVersionUID(SUID)</code> 를 명시적으로 선언해야 합니다. 물론 선언하지 않더라도 자동 생성되지만 런타임에 이 값을 생성하느라 복잡한 연산을 수행해야합니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 무작위로 고른 long 값</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> serialVersionUID <span class=\"token operator\">=</span> <span class=\"token number\">0204L</span><span class=\"token punctuation\">;</span></code></pre>\n<p>다만, SUID가 꼭 유니크할 필요가 없습니다. 다만 이 값이 변경되면 기존 버전 클래스와의 호환을 끊게 됩니다. 따라서 호환성을 끊는 경우가 아니라면 SUID 값을 변경해서는 안됩니다.</p>\n<br/>\n<h2 id=\"item-88-readobject-메서드는-방어적으로-작성합니다\"><a href=\"#item-88-readobject-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EB%B0%A9%EC%96%B4%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%84%B1%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Item 88. <code class=\"language-text\">readObject</code> 메서드는 방어적으로 작성합니다.</h2>\n<p>지난 Item 50에서는 적시에 방어적 복사본을 만들라는 규칙이 있습니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Period</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Date</span> start<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Date</span> end<span class=\"token punctuation\">;</span>\n\n  <span class=\"token doc-comment comment\">/**\n   * <span class=\"token keyword\">@param</span>  <span class=\"token parameter\">start</span> the beginning of the period\n   * <span class=\"token keyword\">@param</span>  <span class=\"token parameter\">end</span> the end of the period; must not precede start\n   * <span class=\"token keyword\">@throws</span> <span class=\"token reference\"><span class=\"token class-name\">IllegalArgumentException</span></span> if start is after end\n   * <span class=\"token keyword\">@throws</span> <span class=\"token reference\"><span class=\"token class-name\">NullPointerException</span></span> if start or end is null\n   */</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Period</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Date</span> start<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Date</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>start <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>end   <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>end<span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>end<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span>\n      start <span class=\"token operator\">+</span> <span class=\"token string\">\" after \"</span> <span class=\"token operator\">+</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Date</span> start <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Date</span> end <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>end<span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> start <span class=\"token operator\">+</span> <span class=\"token string\">\" - \"</span> <span class=\"token operator\">+</span> end<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token comment\">// Remainder omitted</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>물리적 표현과 논리적 표현이 같기 때문에 기본 직렬화 형태를 사용해도 된다고 판단됩니다. 따라서 <code class=\"language-text\">Serializable</code>만 구현하면 될 것 같습니다. 하지만 <code class=\"language-text\">readObject</code>가 새로운 public 생성자이기 때문에 불변식을 보장할 수 없습니다.</p>\n<p><code class=\"language-text\">readObject</code> 메서드도 생성자와 같은 수준으로 주의해야합니다. 인수가 유효한지 검사하고, 매개변수를 방어적으로 복사해야합니다. 그렇지 않으면 불변식을 깨뜨리는 공격에 취약합니다.</p>\n<p><code class=\"language-text\">readObject</code> 메서드는 매개변수로 바이트 스트림을 받는 생성자로 볼 수 있습니다. 일반적으로 보통 바이트 스트림은 정상적으로 생성된 인스턴스를 직렬화해서 만들어집니다. 하지만, 불변을 깨트릴 목표로 만들어진 바이트 스트림을 받으면 문제가 발생합니다. 이러한 경우는 정상적으로 만들어 낼 수 없는 객체를 생성합니다.</p>\n<p>아래는 그 잘못된 코드입니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BogusPeriod</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">// Byte stream couldn't have come from a real Period instance!</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> serializedForm <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">)</span><span class=\"token number\">0xac</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">)</span><span class=\"token number\">0xed</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x00</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x05</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x73</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x72</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x00</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x06</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">0x50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x65</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x72</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x69</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x6f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x64</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x7e</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">)</span><span class=\"token number\">0xf8</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">0x2b</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x4f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x46</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">)</span><span class=\"token number\">0xc0</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">)</span><span class=\"token number\">0xf4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x02</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x00</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x02</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Period</span> p <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Period</span><span class=\"token punctuation\">)</span> <span class=\"token function\">deserialize</span><span class=\"token punctuation\">(</span>serializedForm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 바이트 스트림으로부터 객체를 만들어 변환합니다.</span>\n  <span class=\"token keyword\">static</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">deserialize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> sf<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectInputStream</span><span class=\"token punctuation\">(</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">ByteArrayInputStream</span><span class=\"token punctuation\">(</span>sf<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> <span class=\"token operator\">|</span> <span class=\"token class-name\">ClassNotFoundException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>해당 코드를 실행하면, 불변식이 깨지는 객체가 만들어집니다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">Fri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984</code></pre>\n<p>이를 방어하기 위해서는 <code class=\"language-text\">readObject</code> 메서드가 <code class=\"language-text\">defaultReadObject</code>를 호출하게 한 후 역직렬화된 객체가 유효한지 검사해야합니다. 여기서 유효성 검사에 실패한다면 <code class=\"language-text\">InvalidObjectException</code>을 던져 잘못된 역직렬화가 발생하는 것을 막아야합니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ObjectInputStream</span> s<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ClassNotFoundException</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 불변식을 만족하는지 검사한다.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>end<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InvalidObjectException</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> <span class=\"token string\">\"after\"</span> <span class=\"token operator\">+</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>그러나 이러한 코드에서도 바이트 스트림 끝에 <code class=\"language-text\">private Date</code> 필드로의 참조를 추가하면 가변적인 Period 인스턴스를 만들어 낼 수 있습니다. 공격자가 역직렬화를 통해서 바이트 스트림 끝의 참조 값을 읽으면 Period의 내부 정보를 얻을 수 있습니다. 이 참조를 이용해서 인스턴스를 수정할 수 있기 때문에 불변이 아닙니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MutablePeriod</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Period</span> period<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Date</span> start<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Date</span> end<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">MutablePeriod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token class-name\">ByteArrayOutputStream</span> bos <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ByteArrayOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token class-name\">ObjectOutputStream</span> out <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectOutputStream</span><span class=\"token punctuation\">(</span>bos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      out<span class=\"token punctuation\">.</span><span class=\"token function\">writeObject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Period</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">/*\n       * 악의적인 '이전 객체 참조', 즉 내부 Date 필드로의 참조를 추가한다.\n       * 상세 내용은 자바 객체 직렬화 명세의 6.4절 참조.\n       */</span>\n      <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> ref <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token number\">0x71</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x7e</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      bos<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 시작(start) 필드</span>\n      ref<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 참조 #4</span>\n      bos<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 종료(end) 필드</span>\n\n      <span class=\"token class-name\">ObjectInputStream</span> in <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectInputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ByteArrayInputStream</span><span class=\"token punctuation\">(</span>bos<span class=\"token punctuation\">.</span><span class=\"token function\">toByteArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      period <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Period</span><span class=\"token punctuation\">)</span> in<span class=\"token punctuation\">.</span><span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      start <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Date</span><span class=\"token punctuation\">)</span> in<span class=\"token punctuation\">.</span><span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      end <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Date</span><span class=\"token punctuation\">)</span> in<span class=\"token punctuation\">.</span><span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> <span class=\"token operator\">|</span> <span class=\"token class-name\">ClassNotFoundException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AssertionError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">MutablePeriod</span> mp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MutablePeriod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Period</span> p <span class=\"token operator\">=</span> mp<span class=\"token punctuation\">.</span>period<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Date</span> pEnd <span class=\"token operator\">=</span> mp<span class=\"token punctuation\">.</span>end<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 시간을 되돌린다.</span>\n    pEnd<span class=\"token punctuation\">.</span><span class=\"token function\">setYear</span><span class=\"token punctuation\">(</span><span class=\"token number\">78</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 60년대로 돌아간다.</span>\n    pEnd<span class=\"token punctuation\">.</span><span class=\"token function\">setYear</span><span class=\"token punctuation\">(</span><span class=\"token number\">69</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\"language-text\"><code class=\"language-text\">Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1978\nWed Nov 22 00:21:29 PST 2017 - Sat Nov 22 00:21:29 PST 1969</code></pre>\n<p>해당 원인은 <code class=\"language-text\">Period</code>의 <code class=\"language-text\">readObject</code> 메서드가 방어적 복사를 하지 않음에 있습니다. <strong>역직렬화를 할 때는 클라이언트가 접근해서는 안되는 객체 참조를 갖는 필드는 모두 방어적으로 복사를 해야합니다.</strong></p>\n<p><code class=\"language-text\">Period</code>를 공격으로부터 보호하기 위해 방어적 복사를 유효성 검사보다 먼저 수행해야합니다. 또한 Date의 <code class=\"language-text\">clone</code> 메서드는 사용되지 않습니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ObjectInputStream</span> s<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ClassNotFoundException</span> <span class=\"token punctuation\">{</span>\n  s<span class=\"token punctuation\">.</span><span class=\"token function\">defaultReadObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 가변 요소들을 방어적으로 복사한다.</span>\n  start <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  end <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>end<span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 불변식을 만족하는지 검사한다.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">.</span><span class=\"token function\">compareto</span><span class=\"token punctuation\">(</span>end<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InvalidObjectException</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> <span class=\"token string\">\" after \"</span> <span class=\"token operator\">+</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\"language-text\"><code class=\"language-text\">Fri May 31 01:01:06 KST 2019 - Fri May 31 01:01:06 KST 2019\nFri May 31 01:01:06 KST 2019 - Fri May 31 01:01:06 KST 2019</code></pre>\n<p>한편 <code class=\"language-text\">final</code> 필드는 방어적 복사가 불가능하니 주의해야합니다. 따라서 start와 end 필드에서 <code class=\"language-text\">final</code> 키워드를 제거해야합니다. 공격을 받는 것보다는 더 나은 방향입니다.</p>\n<p><code class=\"language-text\">transient</code> 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사를 없이도 필드에 대입하는 public 생성자를 추가해도 괜찮다고 판단되면 기본 <code class=\"language-text\">readObject</code>를 사용해도 됩니다. 아닌 경우에는 직접 <code class=\"language-text\">readObject</code> 메서드를 정의해서 생성자에서 수행했어야 할 모든 유효성 검사와 방어적 복사를 수행해야합니다. 이때 가장 추천되는 것은 <code class=\"language-text\">직렬화 프록시 패턴</code>을 사용하는 것입니다. 이는 역직렬화를 안전하게 만드는데 필요한 노력을 줄여줍니다,</p>\n<p><code class=\"language-text\">final</code>이 아닌 직렬화 가능 클래스라면 생성자처럼 <code class=\"language-text\">readObject</code> 메서드도 재정의(Overriding) 가능한 메서드를 호출해서는 안됩니다. 하위 클래스의 상태가 완전히 직렬화되기 전에 하위 클래스에서 재정의된 메서드가 실행되기 때문입니다.</p>\n<p>결론적으로 다음과 같이 요약할 수 있습니다.</p>\n<ul>\n<li><code class=\"language-text\">readObject</code> 메서드를 작성할 때는 언제나 public 생성자를 작성하는 자세로 임합니다.</li>\n<li>\n<p><code class=\"language-text\">readObject</code> 메서드는 어떤 바이트 스트림이 넘어오더라도 유효한 인스턴스를 만들어야합니다.</p>\n<ul>\n<li>이 바이트 스트림이 항상 직렬화된 인스턴스라고 믿으면 안됩니다.</li>\n</ul>\n</li>\n<li>\n<p>안전한 <code class=\"language-text\">readObject</code> 메서드를 작성하기 위해서는 아래를 준수합니다.</p>\n<ul>\n<li><code class=\"language-text\">private</code> 여야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사합니다.</li>\n<li>모든 불변식을 검사하고 어긋난다면, <code class=\"language-text\">InvalidObjectException</code>을 던집니다.</li>\n<li>역직렬화 이후에 객체 그래프 전체의 유효성을 검사해야 한다면 <code class=\"language-text\">ObjectInputValidation</code>을 던집니다.</li>\n<li>오버라이딩이 가능한 메서드는 호출하지 않는 것이 좋습니다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"item-89-인스턴스-수를-통제해야한다면-readresolve보다는-enum-타입을-사용합니다\"><a href=\"#item-89-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%88%98%EB%A5%BC-%ED%86%B5%EC%A0%9C%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4%EB%A9%B4-readresolve%EB%B3%B4%EB%8B%A4%EB%8A%94-enum-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Item 89. 인스턴스 수를 통제해야한다면 <code class=\"language-text\">readResolve</code>보다는 enum 타입을 사용합니다.</h2>\n<p>앞에서 싱글톤 패턴의 예저를 보았는데 이 방법은 <code class=\"language-text\">public static final</code> 필드를 사용하는 방식입니다. 생성자는 <code class=\"language-text\">private</code> 접근 지정자로 선언하여 외부로부터 감추고, <code class=\"language-text\">INSTANCE</code>를 초기화할 때 한 번만 호출됩니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Elvis</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Elvis</span> INSTANCE <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Elvis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">Elvis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>하지만, 이 클래스는 <code class=\"language-text\">Serializable</code>을 구현하게 되는 순간 싱글턴이 아닙니다. 기본 직렬화를 쓰지 않거나 명시적인 <code class=\"language-text\">readObject</code> 메서드를 제공해도 소용이 없습니다. 어떤 <code class=\"language-text\">readObject</code> 메서드를 사용해도 초기화될 때 만들어진 인스턴스와 다른 인스턴스를 반환하게 됩니다.</p>\n<p>이때 <code class=\"language-text\">readResolve</code> 메서드를 사용하면, <code class=\"language-text\">readObject</code> 메서드가 만든 인스턴스를 다른 것으로 대체할 수 있습니다. 이때 <code class=\"language-text\">readObject</code>가 만들어낸 인스턴스는 가비지 컬렉터의 대상이 됩니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">readResolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> INSTANCE<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>한편 여기서 나온 <code class=\"language-text\">Elvis</code> 인스턴스의 직렬화 형태는 아무런 실 데이터를 가질 필요가 없으니 모든 인스턴스 필드는 <code class=\"language-text\">transient</code>로 선언해야합니다. 그러므로 <code class=\"language-text\">readResolve</code> 메서드를 인스턴스의 통제 목적으로 이용한다면 모든 필드는 <code class=\"language-text\">transient</code>로 선언하는 것이 좋습니다. 그렇지 않으면 역직렬화 과정에서 역직렬화된 인스턴스를 가져와서 싱글턴이 깨지게 됩니다.</p>\n<p>이를 해결하는 방법은 <code class=\"language-text\">enum</code>입니다. 자바가 선언한 상수 외에 다른 객체가 없음을 보장해주기 때문입니다. 물론 <code class=\"language-text\">AccessibleObject.setAccessible</code> 메서드와 같은 리플렉션을 사용하는 경우는 예외입니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> <span class=\"token class-name\">Elvis</span> <span class=\"token punctuation\">{</span>\n  INSTANCE<span class=\"token punctuation\">;</span>\n\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>물론 인스턴스 통제를 위해 <code class=\"language-text\">readResolve</code> 메서드를 사용하는 것이 중요할 때도 있습니다. 직렬화 가능 인스턴스 통제 클래스를 작성해야 할 때, 컴파일 타임에는 어떤 인스턴스들이 있는지 모를 수 있습니다. 이때는 <code class=\"language-text\">Enum</code> 타입으로 표현하는 것이 불가능하기 때문에 <code class=\"language-text\">readResolve</code> 메서드를 사용할 수 밖에 없습니다.</p>\n<br/>\n<h2 id=\"item-90-직렬화된-인스턴스-대신-직렬화-프록시-사용을-검토합니다\"><a href=\"#item-90-%EC%A7%81%EB%A0%AC%ED%99%94%EB%90%9C-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%8C%80%EC%8B%A0-%EC%A7%81%EB%A0%AC%ED%99%94-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%82%AC%EC%9A%A9%EC%9D%84-%EA%B2%80%ED%86%A0%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Item 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토합니다.</h2>\n<p><code class=\"language-text\">Serializable</code>을 <code class=\"language-text\">implements</code> 하게 되면, 정상적인 인스턴스 생성 방법인 생성자 이외의 방법이 생기게 됩니다. 버그와 보안 문제가 생길 가능성이 커진다는 것입니다. 하지만 <strong>직렬화 프록시 패턴</strong>을 사용하면 이를 크게 줄일 수 있습니다.</p>\n<h3 id=\"직렬화-프록시-패턴\"><a href=\"#%EC%A7%81%EB%A0%AC%ED%99%94-%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>직렬화 프록시 패턴</h3>\n<p>바깥 클래스의 논리적 상태를 표현하는 중첩 클래스를 설계해서 <code class=\"language-text\">private static</code>으로 선언합니다. 여기서 중첩 클래스가 <strong>직렬화 프록시</strong> 입니다. 중첩 클래스의 생성자는 단 하나여야하며, 바깥 클래스를 매개변수로 받아야합니다. 단순히 인수로 넘어온 인스턴스의 데이터를 복사해야합니다. 일관성 검사 또는 방어적 복사도 필료가 없습니다. 아만, 바깥 클래스와 직렬화 프록시 모두 <code class=\"language-text\">Serializable</code>을 구현해야합니다.</p>\n<p>이러한 직렬화 프록시 패턴의 장점은 아래와 같습니다.</p>\n<ul>\n<li>멤버 필드를 <code class=\"language-text\">final</code>로 선언할 수 있기 때문에 진정한 불변으로 만들 수 있습니다.</li>\n<li>역직렬화한 인스턴스와 원래의 직렬화된 클래스가 달라도 정상적으로 동작합니다.</li>\n</ul>\n<p>다만 직렬화 프록시 패턴에도 한계가 있습니다.</p>\n<ul>\n<li>클라이언트가 마음대로 확장할 수 있는 클래스에는 적용할 수 없습니다.</li>\n<li>객체가 서로 참조하는 경우(순환이 있는 경우)에는 적용할 수 없습니다.</li>\n<li>방어적 복사보다 상대적으로 속도가 느립니다.</li>\n</ul>\n"}},{"node":{"title":"[Java] 자바 직렬화","path":"/java-serialize/","date":"12. May 2021","timeToRead":8,"description":"Java 직렬화와 역직렬화에 대해 정리합니다.","content":"<h1 id=\"java-serialize\"><a href=\"#java-serialize\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Java Serialize</h1>\n<p>이펙티브 자바를 공부하던 중, 마지막 단원을 공부하다보면 자바 직렬화(Serialize)에 대한 개념이 나옵니다. 다만, 이 부분에 대해 지식이 너무 부족해 이를 따로 정리합니다.</p>\n<h2 id=\"자바-직렬화란\"><a href=\"#%EC%9E%90%EB%B0%94-%EC%A7%81%EB%A0%AC%ED%99%94%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>자바 직렬화란</h2>\n<p>일반적으로 자바의 직렬화와, 역직렬화를 아울러서 직렬화라고 합니다.</p>\n<h3 id=\"직렬화serialize\"><a href=\"#%EC%A7%81%EB%A0%AC%ED%99%94serialize\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>직렬화(Serialize)</h3>\n<ul>\n<li>자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터를 변환하는 기술입니다.</li>\n<li>JVM의 메모리에서 상주되어 있는 객체 데이터를 바이트 형태로 변환하는 기술입니다.</li>\n<li>일반적으로 객체들을 통째로 저장하거나 전송하고 싶을 때 주로 사용합니다.</li>\n</ul>\n<h3 id=\"역직렬화deserialize\"><a href=\"#%EC%97%AD%EC%A7%81%EB%A0%AC%ED%99%94deserialize\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>역직렬화(Deserialize)</h3>\n<ul>\n<li>바이트로 변환된 데이터를 원래대로 객체나 데이터로 변환하는 기술을 역직렬화라고 합니다.</li>\n<li>직렬화된 바이트 형태의 데이터를 개체로 변환해서 JVM으로 상주시키는 형태입니다.</li>\n<li>저장된 파일을 읽거나 전송된 스트림 데이터를 읽어서 원래 객체의 형태로 복원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"자바-직렬화를-사용하기\"><a href=\"#%EC%9E%90%EB%B0%94-%EC%A7%81%EB%A0%AC%ED%99%94%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>자바 직렬화를 사용하기</h2>\n<h3 id=\"자바-직렬화-방법\"><a href=\"#%EC%9E%90%EB%B0%94-%EC%A7%81%EB%A0%AC%ED%99%94-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>자바 직렬화 방법</h3>\n<p>자바의 기본(primitive) 타입과 <code class=\"language-text\">java.io.Serializable</code> 인터페이스를 상송받은 객체는 직렬화 할 수 있는 <strong>기본 조건</strong>을 가집니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">myepark<span class=\"token punctuation\">.</span>study</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> id<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Person{id='%s', email='%s', age='%s'}\"</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>다음처럼, 코드 작성시 직렬화 조건을 만족한 상태입니다.</p>\n<p>이를 직렬화하는 방법은 <code class=\"language-text\">java.io.ObjectOutputStream</code> 객체를 이용하는 것입니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SerializableTest</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Person</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"박모씨\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"XXX-XXX\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">26</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> serializedPerson <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ByteArrayOutputStream</span> baos <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ByteArrayOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">try</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ObjectOutputStream</span> oos <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectOutputStream</span><span class=\"token punctuation\">(</span>baos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        oos<span class=\"token punctuation\">.</span><span class=\"token function\">writeObject</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 직렬화된 Person 객체</span>\n        serializedPerson <span class=\"token operator\">=</span> baos<span class=\"token punctuation\">.</span><span class=\"token function\">toByteArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Base64</span><span class=\"token punctuation\">.</span><span class=\"token function\">getEncoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">encodeToString</span><span class=\"token punctuation\">(</span>serializedPerson<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>해당 코드를 실행시키면, 이에 대한 결과를 확인할 수 있습니다.</p>\n<p><code class=\"language-text\">rO0ABXNyAAxzdHVkeS5QZXJzb25ntzRTK7/dGgIAA0kAA2FnZUwAAmlkdAASTGphdmEvbGFuZy9TdHJpbmc7TAAEbmFtZXEAfgABeHAAAAAadAAHWFhYLVhYWHQACeuwleuqqOyUqA==</code></p>\n<p>이는 바이트 배열 형태이기 때문에 사용자가 봤을때는 확인할 수 없습니다.</p>\n<h3 id=\"자바-역직렬화-방법\"><a href=\"#%EC%9E%90%EB%B0%94-%EC%97%AD%EC%A7%81%EB%A0%AC%ED%99%94-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>자바 역직렬화 방법</h3>\n<p>자바 역직렬화를 사용하기 위해서는 아래의 조건을 만족해야합니다.</p>\n<ul>\n<li>\n<p>직렬화 대상이 된 객체의 클래스가 클래스 패스에 존재해야하며 <code class=\"language-text\">import</code> 되어야 합니다.</p>\n<ul>\n<li>중요한 점 중 하나는 직력화와 역직렬화를 진행하는 시스템이 서로 다를 수 있기 때문에 이를 <strong>반드시 고려</strong>해야합니다.</li>\n</ul>\n</li>\n<li>자바 직렬화 대상 객체는 동일한 <code class=\"language-text\">serialVersionUID</code> 를 가지고 있어야합니다.</li>\n</ul>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> serialVersionUID <span class=\"token operator\">=</span> <span class=\"token number\">1L</span><span class=\"token punctuation\">;</span></code></pre>\n<p>이를 통해서 위의 바이트 코드를 다음과 같이 수정할 수 있습니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DeserializableTest</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">String</span> base64Memeber <span class=\"token operator\">=</span> <span class=\"token string\">\"rO0ABXNyAAxzdHVkeS5QZXJzb25ntzRTK7/dGgIAA0kAA2FnZUwAAmlkdAASTGphdmEvbGFuZy9TdHJpbmc7TAAEbmFtZXEAfgABeHAAAAAadAAHWFhYLVhYWHQACeuwleuqqOyUqA==\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> serializedPerson <span class=\"token operator\">=</span> <span class=\"token class-name\">Base64</span><span class=\"token punctuation\">.</span><span class=\"token function\">getDecoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>base64Memeber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ByteArrayInputStream</span> bais <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ByteArrayInputStream</span><span class=\"token punctuation\">(</span>serializedPerson<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ObjectInputStream</span> ois <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectInputStream</span><span class=\"token punctuation\">(</span>bais<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 역직렬화된 Person 객체를 읽어옵니다.</span>\n        <span class=\"token class-name\">Object</span> objectPerson <span class=\"token operator\">=</span> ois<span class=\"token punctuation\">.</span><span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Person</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span> objectPerson<span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassNotFoundException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>위 코드를 실행하면 아래처럼 결과가 나옵니다.</p>\n<p><code class=\"language-text\">Person{name=&#39;박모씨&#39;, id=&#39;XXX-XXX&#39;, age=&#39;26&#39;}</code></p>\n<p>이처럼 직렬화와 역직렬화를 사용할 수 있습니다.</p>\n<br/>\n<h2 id=\"직렬화-사용시-주의할-부분\"><a href=\"#%EC%A7%81%EB%A0%AC%ED%99%94-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EB%B6%80%EB%B6%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>직렬화 사용시 주의할 부분.</h2>\n<ul>\n<li>자바 직렬화 사용할 때는 최대하게 신중하게 사용합니다.</li>\n<li><code class=\"language-text\">Serializable</code>을 구현할때는 신중히 결정합니다,</li>\n<li>커스텀 직렬화 형태를 고려해서 개발합니다.</li>\n<li><code class=\"language-text\">readObject</code> 메서드는 방어적으로 작성합니다.</li>\n<li>인스턴스 수를 통제해야한다면 <code class=\"language-text\">readObject</code> 보다는 <code class=\"language-text\">Enum</code> 타입을 사용합니다.</li>\n<li>직렬화된 인스턴스보다는 <code class=\"language-text\">직렬화 프록시 사용</code>을 검토합니다.</li>\n</ul>\n<p><a href=\"https://github.com/Azderica/Book-Record/tree/master/Effective%20Java/ch12\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">좀 더 자세하게</a></p>\n<br/>\n<h2 id=\"직렬화의-사용-이유\"><a href=\"#%EC%A7%81%EB%A0%AC%ED%99%94%EC%9D%98-%EC%82%AC%EC%9A%A9-%EC%9D%B4%EC%9C%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>직렬화의 사용 이유.</h2>\n<p>자바 직렬화 외에 다른 데이터 직렬화 종류는 아래와 같습니다.</p>\n<h3 id=\"문자열-형태의-직렬화-방법\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%98%95%ED%83%9C%EC%9D%98-%EC%A7%81%EB%A0%AC%ED%99%94-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>문자열 형태의 직렬화 방법</h3>\n<p>일반적으로 직접 데이터를 문자열 형태로 확인 가능한 직렬화 방법입니다. 범용적인 API나 데이터를 변환하여 추출할 때 많이 사용합니다.</p>\n<ul>\n<li>CSV</li>\n<li>XML</li>\n<li>JSON</li>\n</ul>\n<h3 id=\"이진-직렬화-방법\"><a href=\"#%EC%9D%B4%EC%A7%84-%EC%A7%81%EB%A0%AC%ED%99%94-%EB%B0%A9%EB%B2%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>이진 직렬화 방법</h3>\n<p>데이터 변환 및 전송 속도에 최적화하여 별도의 직렬화 방법을 제시하는 구조입니다.</p>\n<ul>\n<li>Protocol Buffer</li>\n<li>Apache Avro</li>\n</ul>\n<h3 id=\"자바-직렬화의-필요성\"><a href=\"#%EC%9E%90%EB%B0%94-%EC%A7%81%EB%A0%AC%ED%99%94%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>자바 직렬화의 필요성</h3>\n<p>앞서 여러 직렬화 방법이 있지만 자바의 직렬화를 쓰는 이유는 자바 직렬화가 가지는 장점이 있기 때문입니다.</p>\n<ul>\n<li>자바 시스템에서 개발에 최적화가 되어 있습니다.</li>\n<li>복잡한 데이터 구조의 클래스의 객체라도 직렬화의 기본 조건만 지키게 되면, 큰 작업없이 바로 직렬화나 역직렬화가 됩니다.</li>\n<li>역직렬화하면 기존 객체처럼 바로 사용할 수 있습니다.</li>\n</ul>\n<p>다만 직렬화가 가지는 단점 또한 있습니다.</p>\n<ul>\n<li>보안에 신경을 써야합니다. (직렬화 공격)</li>\n<li>예외 처리에 신경을 써야합니다.</li>\n<li>용량이 큽니다.</li>\n<li>역직렬화 또한 일종의 생성자이기 때문에, 신경을 써야하는 부분이 많습니다.</li>\n</ul>\n<br/>\n<h2 id=\"직렬화를-사용하는-경우\"><a href=\"#%EC%A7%81%EB%A0%AC%ED%99%94%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>직렬화를 사용하는 경우</h2>\n<p>JVM의 메모리에서만 상주되어있는 객체 데이터를 그대로 영석화(Persistence)가 필요할 때 사용됩니다. 또한 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크 전송도 가능합니다. 그리고 필요할 때 직렬화된 객체 데이터를 가져와서 역직렬화 해서 객체를 바로 사용할 수 있게됩니다.</p>\n<p>주로 아래의 경우에서 쉽게 사용됩니다.</p>\n<ul>\n<li>\n<p>서블릿 세션(Servlet Session)</p>\n<ul>\n<li>서블릿 기반의 WAS(톰캣, 웹로직 등)는 대부분 세션의 자바 직렬화를 지원합니다.</li>\n<li>파일로 저장, 세션 클러스터링, DB 저장 등을 할 때 직렬화되어서 저장됩니다.</li>\n</ul>\n</li>\n<li>\n<p>캐시(Cache)</p>\n<ul>\n<li>시스템에서는 퍼포먼스를 위해서 캐시를 사용하는데, 이때 자바 직렬화된 데이터를 저장해서 사용합니다.</li>\n</ul>\n</li>\n<li>\n<p>자바 RMI(Remote Method Invocation)</p>\n<ul>\n<li>원격 시스템 간의 메시지 교환을 위해 사용하는 자바에서 지원하는 기술입니다.</li>\n<li>RMI는 시스템과의 통신에서 필요한 IP, 포트를 통해서 소켓통신을 하는데 이를 추상화하여 로컬 시스템 메서드인 것처럼 호출할 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serial-arch.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serial-arch.html</a></li>\n<li><a href=\"https://woowabros.github.io/experience/2017/10/17/java-serialize.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://woowabros.github.io/experience/2017/10/17/java-serialize.html</a></li>\n<li><a href=\"https://ryan-han.com/post/java/serialization/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ryan-han.com/post/java/serialization/</a></li>\n<li><a href=\"https://ryan-han.com/post/java/java-serialization/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ryan-han.com/post/java/java-serialization/</a></li>\n</ul>\n"}}]}}},"context":{}}