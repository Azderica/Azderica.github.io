{"hash":"4d08d5d9909bc52ba8ae53ab8b5e8ea790bc2d53","data":{"tag":{"title":"Cloud","belongsTo":{"edges":[{"node":{"title":"[Spring] Spring Cloud Zuul 공부","path":"/00-spring-zuul/","date":"6. February 2021","timeToRead":9,"description":"Spring cloud zuul을 적용하기 위해 공부하는 내용입니다.","content":"<h1 id=\"spring-cloud-zuul\"><a href=\"#spring-cloud-zuul\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Spring Cloud Zuul</h1>\n<p>기존 회사 프로젝트에서 사용하는 도메인에 대해 API Gateway 생성에 대한 필요성이 대두되었다. 그래서 그 프로젝트를 진행하기 전에 한번 공부해볼려고 한다.</p>\n<br/>\n<h2 id=\"먼저-api-gateway에-대해\"><a href=\"#%EB%A8%BC%EC%A0%80-api-gateway%EC%97%90-%EB%8C%80%ED%95%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>먼저 API Gateway에 대해</h2>\n<p>Microservice Architecture(MSA)에서 언급되는 컴포넌트 중 하나이며, 모든 클라이언트 요청에 대한 end point를 통합하는 서버입니다. 일종의 프록시 서버처럼 동작하며 인증 및 권한, 모니터링, 로깅 등의 추가적인 기능이 있습니다.</p>\n<p>MSA는 도메인별 데이터를 저장하고 도메인별로 하나 이상의 서버가 따로 존재합니다. 한 서비스에 한개 이상의 서버가 존재하기 때문에 해당 서버를 사용하는 클라이언트 입장에서는 다수의 end point가 생기므로, 이 end point를 변경했을 때 관리하기가 힘듭니다.그래서 MSA 환경에서 서비스에 대한 도메인인 하나로 통합할 수 있는 API Gateway가 필요합니다.</p>\n<p><strong>API Gateway를 사용하면 통합적으로 end point와 Rest api를 관리할 수 있으며, 모든 클라이언트는 각 서비스의 end point 대신 API Gateway로 요청을 전달</strong>합니다. 이후 API Gateway는 사용자가 설정한 라우팅 설정에 따라 각 end point로 클라이언트를 대리하여 요청하고 응답을 받으면 클라이언트에게 전달하는 프록시 역할을 수행합니다.</p>\n<br/>\n<h2 id=\"netflix-zuul을-선택한-이유\"><a href=\"#netflix-zuul%EC%9D%84-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Netflix Zuul을 선택한 이유.</h2>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107103975-2236cd80-6863-11eb-9494-07470230b9c0.png\" alt=\"Netflix-zuul-usage\"></p>\n<p>앞서 API Gateway에 대해 개념을 인지하고, 이를 사용하기 제일 좋은 오픈소스 프로젝트는 Netflix zuul로 볼 수 있습니다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">Zuul is the front door for all requests from devices and web sites to the backend of the Netflix streaming application. As an edge service application, Zuul is built to enable dynamic routing, monitoring, resiliency and security. It also has the ability to route requests to multiple Amazon Auto Scaling Groups as appropriate.</code></pre>\n<ul>\n<li><a href=\"https://github.com/Netflix/zuul/wiki\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">출처 : Netflix zuul wiki</a></li>\n</ul>\n<p>Zuul에 대한 공식 설명글입니다. 목적을 보면, 라우팅과 모니터링, 복원 및 보안을 지원하도록 설계되어 있습니다.</p>\n<br/>\n<h2 id=\"netflix-zuul에-대해-좀-더-자세하게\"><a href=\"#netflix-zuul%EC%97%90-%EB%8C%80%ED%95%B4-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Netflix Zuul에 대해 좀 더 자세하게.</h2>\n<p>클라이언트 요청은 많은 트래픽과 다양한 요청이 들어오기 때문에 운영에서 다양한 이슈와 문제가 발생합니다. zuul은 이러한 상황에 신속하게 대응합니다. groovy 언어로 작성된 다양한 형태의 Filter를 제공하고, Filter에 기능을 정의해이슈 발생시 적절한 Filter을 추가함으로서 이슈를 해결할 수 있습니다.</p>\n<h3 id=\"netflix-filter-기능\"><a href=\"#netflix-filter-%EA%B8%B0%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Netflix Filter 기능</h3>\n<ul>\n<li>\n<p>Authentication and Security</p>\n<ul>\n<li>클라이언트 요청 시, 각 리소스에 대한 인증 확인하고 만족시키지 않으면 거부합니다,</li>\n</ul>\n</li>\n<li>\n<p>Insights and Monitoring</p>\n<ul>\n<li>의미있는 데이터 및 통계를 제공합니다.</li>\n</ul>\n</li>\n<li>\n<p>Dynamic Routing</p>\n<ul>\n<li>필요에 따라 요청을 다른 클러스터로 동적 라우팅합니다.</li>\n</ul>\n</li>\n<li>\n<p>Stress Testing</p>\n<ul>\n<li>성능 측정을 위해 점차적으로 클러스터 트래픽을 증가시킵니다.</li>\n</ul>\n</li>\n<li>\n<p>Load Shedding</p>\n<ul>\n<li>각 유형의 요청에 대해 용량을 할당하고, 초과 요청을 제한합니다.</li>\n</ul>\n</li>\n<li>Static Response handling -클러스테엇 오는 응답을 대신하여 API Gateway에서 응답을 처리합니다.</li>\n</ul>\n<h3 id=\"netflix-core-architecture\"><a href=\"#netflix-core-architecture\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Netflix Core Architecture</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107103592-940e1780-6861-11eb-9a76-6f86651c1a47.png\" alt=\"Zuul-Core-Architecture\"></p>\n<p>요청은 크게 4가지의 필터로 구성됩니다.</p>\n<ul>\n<li>\n<p>Pre filter</p>\n<ul>\n<li>Origin으로 라우팅되기전에 실행됩니다.</li>\n<li>요청 인증, Origin 서버 선택, 디버그 정보 로깅 등이 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>Routing filter</p>\n<ul>\n<li>요청을 Origin으로 Routing하는 작업을 수행합니다.</li>\n<li>Apache HttpClient나 Netflix Ribbon을 사용해서 HTTP 요청을 작성하고 전송합니다.</li>\n</ul>\n</li>\n<li>\n<p>Post filter</p>\n<ul>\n<li>요청이 Origin으로 라우팅된 후 실행됩니다.</li>\n<li>응답에 표준 HTTP 헤더를 추가하고 통계 및 메트릭을 수집합니다.</li>\n</ul>\n</li>\n<li>\n<p>Error filter</p>\n<ul>\n<li>다른 단계에서 오류 발생시 실행됩니다.</li>\n</ul>\n</li>\n</ul>\n<p>이를 그림으로 나타내면 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107104961-61671d80-6867-11eb-8eb0-f1e2ae87cf14.png\" alt=\"zuul-filter\"></p>\n<h3 id=\"zuul-components\"><a href=\"#zuul-components\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Zuul Components</h3>\n<p>zuul은 다음과 같은 component로 구성됩니다.</p>\n<p>Zuul 1.x 컴포넌트는 크게 4가지의 components로 구성됩니다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">zuul-core</code></p>\n<ul>\n<li>필터를 컴파일하고 실행하는 핵심 기능을 가진 라이브러리</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">zuul-simple-webapp</code></p>\n<ul>\n<li><code class=\"language-text\">zuul-core</code>로 애플리케이션 구축한 예제.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">zuul-netflix</code></p>\n<ul>\n<li>다른 Netflix OSS 구성 요소를 Zuul에 추가합니다.</li>\n<li>Ex) Ribbon</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">zuul-netflix-webapp</code></p>\n<ul>\n<li><code class=\"language-text\">zuul-core</code>와 <code class=\"language-text\">zuul-netflix</code>를 함계 사용하기 쉬운 패키지로 만드는 웹</li>\n</ul>\n</li>\n</ul>\n<p>Zuul 2.x 컴포넌트는 zuul-core와 zuul-sample로만 구성됩니다.</p>\n<ul>\n<li><code class=\"language-text\">zuul-core</code> : zuul 2.0의 기능</li>\n<li><code class=\"language-text\">zuul-sample</code> : zuul 2.0용 샘플 driver application</li>\n</ul>\n<br/>\n<h2 id=\"spring-cloud-zuul-1\"><a href=\"#spring-cloud-zuul-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Spring Cloud Zuul</h2>\n<p>Spring boot에 Netflix OSS를 통합적으로 제공합니다. annotation과 yml 설정으로 쉽게 시작할 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/107106129-64fda300-686d-11eb-8afd-d3b618d314eb.png\" alt=\"spring-cloud-zuul\"></p>\n<ul>\n<li>\n<p><code class=\"language-text\">RouteLocator</code></p>\n<ul>\n<li>url path에 대한 라우팅을 지정</li>\n<li>요청이 들어오면 어떻게 라우팅할 것인지를 정의합니다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">ZuulHandlerMapping</code></p>\n<ul>\n<li>RouteLocator에 정의된 url path에 zuulController를 매핑합니다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">ZuulController</code></p>\n<ul>\n<li>ZuulServlet을 주입합니다.</li>\n<li>들어오는 모든 요청을 ZuulServlet으로 처리합니다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">ZuulFilterInitializer</code></p>\n<ul>\n<li>filter Map에 정의된 filter를 FilterRegistry에 등록하고 FilterLoader로 로딩합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"시작하기\"><a href=\"#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>시작하기.</h3>\n<p>먼저 아래와 같이 <code class=\"language-text\">build.gradle</code>에 의존성을 추가합니다.</p>\n<pre class=\"language-gradle\"><code class=\"language-gradle\">implementation(\"org.springframework.cloud:spring-cloud-starter-netflix-zuul:2.1.2.RELEASE\")</code></pre>\n<p>application.yml 파일에 zuul 설정을 추가합니다.</p>\n<pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">application</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> api<span class=\"token punctuation\">-</span>gateway<span class=\"token punctuation\">-</span>way\n\n<span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8080</span>\n\n<span class=\"token key atrule\">ribbon</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">eureka</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">enabled</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n\n<span class=\"token key atrule\">zuul</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">sensitive-headers</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">host</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">connect-timeout-millis</span><span class=\"token punctuation\">:</span> <span class=\"token number\">600000</span>\n    <span class=\"token key atrule\">socket-timeout-millis</span><span class=\"token punctuation\">:</span> <span class=\"token number\">600000</span>\n  <span class=\"token key atrule\">routes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">foo-api</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> /foos/<span class=\"token important\">**</span>\n      <span class=\"token key atrule\">url</span><span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">:</span>//localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8081</span>\n      <span class=\"token key atrule\">stripPrefix</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n    <span class=\"token key atrule\">bar-api</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> /bars/<span class=\"token important\">**</span>\n      <span class=\"token key atrule\">url</span><span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">:</span>//localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8082</span>\n      <span class=\"token key atrule\">stripPrefix</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span></code></pre>\n<p>그리고 Zuul을 사용하기 위해 다음과 같이 Annotation을 사용합니다.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@EnableZuulProxy</span>\n<span class=\"token annotation punctuation\">@SpringBootApplication</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ZuulApplication</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">SpringApplication</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ZuulApplication</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Spring Cloud Zuul은 <code class=\"language-text\">@EnableZuulProxy</code>와 <code class=\"language-text\">@EnableZuulServer</code> 두 종류의 annotation으로 zuul을 구동시킵니다. 다만<code class=\"language-text\">@EnableZuulProxy</code>은 <code class=\"language-text\">@EnableZuulServer</code>에서 <code class=\"language-text\">PreDecorationFilter, RibbonRoutingFilter, SimpleHostRoutingFilter</code>을 추가 시킨 개념입니다.</p>\n<h3 id=\"custom-filter-적용\"><a href=\"#custom-filter-%EC%A0%81%EC%9A%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Custom Filter 적용</h3>\n<p>다음은 ZuulFilter를 상속받아 Filter를 추가합니다..</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RouteFilter</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ZuulFilter</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">filterType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"route\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">filterOrder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">shouldFilter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Inside Route Filter\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li><code class=\"language-text\">filterType()</code> : filter의 type으로 \"pre\", \"route\", \"post\", \"error\", \"static\"을 용도에 따라 return합니다.</li>\n<li><code class=\"language-text\">filterOrder()</code> : type안에서 해당 필터가 실행되는 순서입니다.</li>\n<li><code class=\"language-text\">shouldFilter()</code> : run method를 실행시 true 실행하지 않아도 되면 false를 반환합니다.</li>\n<li><code class=\"language-text\">run()</code> : 실제 filter의 로직을 담당합니다.</li>\n</ul>\n<h3 id=\"예외-처리\"><a href=\"#%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>예외 처리</h3>\n<p><code class=\"language-text\">Netflix Zuul</code>의 프록시는 Filter 레벨에서 실행됩니다. 필터는 서블릿의 영역으로 Spring MVC의 영역의 여러 레벨에서 발생하는 예외를 처리할 수 있는 <code class=\"language-text\">@ControllerAdvice</code>를 사용할 수 없습니다.</p>\n<p>따라서 <code class=\"language-text\">Whitelabel Error Page</code> 페이지 생성 로직에서 처리할 수 있습니다</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RestController</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ErrorHandlerController</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ErrorController</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> ERROR_MAPPING <span class=\"token operator\">=</span> <span class=\"token string\">\"/error\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> ERROR_MAPPING<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ResponseEntity</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token class-name\">RequestContext</span> ctx <span class=\"token operator\">=</span> <span class=\"token class-name\">RequestContext</span><span class=\"token punctuation\">.</span><span class=\"token function\">getCurrentContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Object</span> error <span class=\"token operator\">=</span> <span class=\"token class-name\">ExceptionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">getRootCause</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span><span class=\"token punctuation\">)</span> ctx<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"throwable\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// zuul.routes.{proxy}.path 에 정의되지 않은 요청일 경우 응답 처리</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ResponseEntity</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"NOT_FOUND\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpStatus</span><span class=\"token punctuation\">.</span>NOT_FOUND<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ResponseEntity</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SERVICE_UNAVAILABLE\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpStatus</span><span class=\"token punctuation\">.</span>SERVICE_UNAVAILABLE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 예상되지 않은 오류일 경우 응답 처리</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ResponseEntity</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INTERNAL_SERVER_ERROR\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpStatus</span><span class=\"token punctuation\">.</span>INTERNAL_SERVER_ERROR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getErrorPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">return</span> ERROR_MAPPING<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>라우팅할 프록시가 존재하지 않는 경우 ErrorController로 요청을 처리합니다.</li>\n<li>라우팅할 프록시가 존재하고, 애플리케이션 오류(라우팅 타임아웃 등) 발생 시 <code class=\"language-text\">pre filter &gt; ErrorController &gt; post filter</code> 순서로 요청을 처리합니다.</li>\n<li>라우팅할 프록시가 존재하고, 라우팅이 성공할 시 <code class=\"language-text\">pre filter -&gt; post filter</code> 순으로 요청을 처리합니다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리</h2>\n<p>간단하게나마 spring cloud zuul에 대해 정리했습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://netflixtechblog.com/announcing-zuul-edge-service-in-the-cloud-ab3af5be08ee\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://netflixtechblog.com/announcing-zuul-edge-service-in-the-cloud-ab3af5be08ee</a></li>\n<li><a href=\"https://github.com/Netflix/zuul/wiki\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/Netflix/zuul/wiki</a></li>\n<li><a href=\"https://jsonobject.tistory.com/464\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://jsonobject.tistory.com/464</a></li>\n<li><a href=\"https://sabarada.tistory.com/56\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://sabarada.tistory.com/56</a></li>\n<li><a href=\"https://lion-king.tistory.com/entry/Spring-Boot-Spring-Cloud-MSA-4-Zuul%EC%9D%B4%EB%9E%80-%EC%A0%81%EC%9A%A9%EB%B0%A9%EB%B2%95\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://lion-king.tistory.com/entry/Spring-Boot-Spring-Cloud-MSA-4-Zuul%EC%9D%B4%EB%9E%80-%EC%A0%81%EC%9A%A9%EB%B0%A9%EB%B2%95</a></li>\n<li><a href=\"https://cloud.spring.io/spring-cloud-netflix/multi/multi__router_and_filter_zuul.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cloud.spring.io/spring-cloud-netflix/multi/multi__router_and_filter_zuul.html</a></li>\n<li><a href=\"https://blog.neonkid.xyz/208\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://blog.neonkid.xyz/208</a></li>\n</ul>\n"}},{"node":{"title":"[Architecture] MSA : Istio 개념 잡기","path":"/00-architecture-istio/","date":"2. February 2021","timeToRead":10,"description":"Istio 패턴에 대해 정리합니다.","content":"<h1 id=\"istio\"><a href=\"#istio\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio</h1>\n<h2 id=\"istio의-정의\"><a href=\"#istio%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio의 정의</h2>\n<p>Istio는 <strong>애플리케이션 네트워크 기능을 유연하고 쉽게 자동화할 수 있는 투명한 언어 독립적인 방법을 제공하는 현대화된 서비스 네트워킹 레이어인 서비스 메시</strong>입니다. 클라우드 기반 애플리케이션을 구성하는 다양한 마이크로 서비스르르 관리하는데 널리 사용되는 솔루션이며 마이크로 서비스가 서로 통신하고 데이터를 공유하는 방법을 지원합니다.</p>\n<p>Istio를 통해서 느슨하게 결합된 마이크로 서비스를 통해 앱을 어셈블하고, 새로운 클라우드 기반 앱을 관리할 수 있습니다. 또한 <strong>서비스 코드 변경 없이 로드배런싱, 서비스 간 인증, 모니터링 등을 적용해서 마이크로 서비스를 쉽게 관리</strong>할 수 있습니다.</p>\n<p>Istio는 애플리케이션 코드를 변경할 필요 없이 서비스 간 트래픽 흐름을 관리하고 액세스 정책을 적용하여 원격 분석 데이터를 집계합니다. 또한 기존의 분산형 애플리케이션에 투명하게 레이어하여 배포 복잡성을 완화시킵니다.</p>\n<h3 id=\"service-mesh-란\"><a href=\"#service-mesh-%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><code class=\"language-text\">Service Mesh</code> 란?</h3>\n<ul>\n<li>애플리케이션의 다양한 부분들이 서로의 데이터를 공유하는 방식을 제어하는 방법입니다.</li>\n<li>좀 더 자세하게 이야기 한다면, API 등을 사용해서 마이크로 서비스간 통신을 안전하고, 빠르고, 신뢰할 수 있게 만들기 위해 설계된 전용 인프라 계층입니다.</li>\n<li>Service Discovery, Load Balancing, Dynamic Request Routing, Circuit Breacking, Retry and Timeout, TLS, Distributed Tracing, Metric 수집, Access Control, A/B Testing 기능 등을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"istio-service-mesh의-장점\"><a href=\"#istio-service-mesh%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio Service Mesh의 장점</h2>\n<h3 id=\"일관된-서비스-네트워킹-달성\"><a href=\"#%EC%9D%BC%EA%B4%80%EB%90%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9-%EB%8B%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>일관된 서비스 네트워킹 달성</h3>\n<p>네트워킹 운영자는 개발자 오버헤드를 추가하지 않고도 모든 서비스의 네트워킹을 일관성 있게 관리할 수 있습니다.</p>\n<h3 id=\"istio-이점을-통해-서비스-보호\"><a href=\"#istio-%EC%9D%B4%EC%A0%90%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%B3%B4%ED%98%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio 이점을 통해 서비스 보호</h3>\n<p>보안 운영자는 인증, 승인, 암호화를 비롯한 서비스 간 보안을 쉽게 구현할 수 있습니다.</p>\n<h3 id=\"애플리케이션-성능-향상\"><a href=\"#%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>애플리케이션 성능 향상</h3>\n<p>Canary Rollout(새로운 버전 모델 배포시, 소규모 사용자에게 먼저 제공함으로서 위험을 빠르게 감지하는 배포 전략)과 같은 권장사항을 구현하고 애플리케이션을 심도 있게 파악하여 성능을 개선하기 위해 집중해야하는 부분을 파악할 수 있습니다.</p>\n<br/>\n<h2 id=\"istio의-구조\"><a href=\"#istio%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio의 구조</h2>\n<p>마이크로 서비스 간의 모든 네트워크 통신을 담당할 수 잇는 프록시인 Envoy를 사이드카 패턴으로 마이크로 서비스들에 배포한 다음, 프록시들의 설정 값 저장 및 관리/감독을 수행하고, 프록시들에 설정값을 전달하는 컨트롤러를 수행합니다.</p>\n<p>그후 각각의 마이크로 서비스에 사이드카 패턴으로 배포된 Envoy 프록시를 <code class=\"language-text\">데이터 플레인(Data Plane)</code> 이라고 하며, 이를 컨트롤 하는 부분이 <code class=\"language-text\">컨트롤 플레인(Control Plane)</code>이라고 합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/106528740-981dfa80-652c-11eb-95e7-fd408293b65e.png\" alt=\"Istio-Architecture\"></p>\n<p>구성요소를 좀 더 자세하게 설명하면 다음과 같습니다.</p>\n<h3 id=\"data-plane-데이터-플레인\"><a href=\"#data-plane-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%8C%EB%A0%88%EC%9D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Plane (데이터 플레인)</h3>\n<p>실제 데이터 트래픽이 돌아다니는 영역입니다. Envoy Proxy 세트로 구성되어 있습니다.</p>\n<h4 id=\"envoy\"><a href=\"#envoy\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Envoy</h4>\n<p>Envoy는 사이드카 방식으로 각각의 마이크로서비스에 배포되어 서비스로 들어오고 나가는 모든 트래픽을 통제합니다. Envoy를 통해서 서비스를 호출할 때 호출하는 서비스의 IP주소는 파일럿에 저당된 엔드포인트 정보를 활용합니다.</p>\n<p>Istio는 Envoy의 <strong>동적 서비스 디스커버리, 로드밸런싱, TLS 인증서 처리, HTTP/2, gRPC 프록시, 서킷브레이커, 헬스체크, 실패 삽입, 많은 메트릭 등의 기능을 사용</strong>할 수 있습니다.</p>\n<p>사이드카 방식을 사용하기 때문에 기존 컨테이너나 코드를 재사용할 필요없이 그대로 사용가능합니다.</p>\n<h3 id=\"control-plane-컨트롤-플레인\"><a href=\"#control-plane-%EC%BB%A8%ED%8A%B8%EB%A1%A4-%ED%94%8C%EB%A0%88%EC%9D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Control Plane (컨트롤 플레인)</h3>\n<p>트래픽 경로를 설정하고 관리하는 용도로 사용합니다.</p>\n<p>Istio1.4 버전까지는 <strong>파일럿(Pilot), 믹서(Mixer), 시타델(Citadel), 갤리(Galley)</strong> 로 구성되어 있었으나 Istio1.5버전부터 4개의 모듈이 <strong>Istiod</strong> 라는 하나의 모듈로 통합되었습니다.</p>\n<h4 id=\"mixer\"><a href=\"#mixer\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Mixer</h4>\n<ul>\n<li>서비스 매쉬 엑세스 컨트롤 및 정책 관리 수행합니다.</li>\n<li>Envoy와 다른 서비스에서 모니터링 지표 수집합니다.</li>\n</ul>\n<h4 id=\"pilot\"><a href=\"#pilot\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Pilot</h4>\n<ul>\n<li>Envoy 설정 관리를 수행하는 모듈입니다.</li>\n<li>Envoy가 호출하는 서비스의 주소를 얻을 수 잇는 Service Discovery 기능을 제공합니다.</li>\n<li>서비스 트래픽 라우팅 기능 제공합니다.</li>\n<li>서비스 안정성을 위해 서비스 간 호출시 Time out, Retry, Circuit Breaker(서킷 브레이커)같은 기능들을 제공합니다.</li>\n</ul>\n<h4 id=\"citadel\"><a href=\"#citadel\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Citadel</h4>\n<ul>\n<li>보안 관련 기능을 수행하는 모듈입니다.</li>\n<li>사용자 인증을 통해서 서비스/앤드 유저 간의 인증을 강화합니다.</li>\n<li>TLS(SSL)을 이용하여 통신 암호화와 인증서 관리를 할 수 있습니다.</li>\n</ul>\n<h4 id=\"galley\"><a href=\"#galley\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Galley</h4>\n<ul>\n<li>Istio 설정을 Validation, Ingestion, Processing, Distribution 하는 역할을 합니다.</li>\n<li>즉, Istio의 구성 및 설정을 검증하고 배포 관리를 진행합니다.</li>\n</ul>\n<h4 id=\"istiod\"><a href=\"#istiod\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istiod</h4>\n<p>Istio 1.5 이상 버전에서 제공되며 서비스 디스커버리, 설정관리, 인증관리 등을 수행합니다.</p>\n<ul>\n<li>트래픽 동작을 제어하는 라우팅 규칙을 Envoy 전용 설정으로 변환하고 마이크로 서비스에 사이드카 방식으로 Envoy를 배포합니다.</li>\n<li>Envoy 설정 변경을 통해 서비스 메시 트래픽을 제어합니다.</li>\n<li>내장된 Identity나 Credential Management(증명 관리)을 통해서 강력한 서비스 간 인증 및 사용자 인증 기능을 지원합니다.</li>\n<li>인증 기관의 역할을 수행하, 데이터 플레인에서 안전한 mTLS 통신을 허용하는 인증서를 생성합니다.</li>\n</ul>\n<br/>\n<h2 id=\"istio의-장점\"><a href=\"#istio%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio의 장점</h2>\n<p>Istio를 통해서 분산형 애플리케이션을 대규모로 제공할 수 있습니다. 아래와 같은 장점이 있습니다.</p>\n<h3 id=\"안전한-클라우드-기반-앱\"><a href=\"#%EC%95%88%EC%A0%84%ED%95%9C-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EA%B8%B0%EB%B0%98-%EC%95%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>안전한 클라우드 기반 앱</h3>\n<p>Istio는 기본적인 보안 통신 채널을 제공하며 대규모 서비스 통신의 인증(Authentication), 권한부여(Authorization), 암호화(Encryption) 등을 통해서 애플리케이션 수준에서 보안을 강화할 수 있습니다.</p>\n<h3 id=\"효율적인-트래픽-관리\"><a href=\"#%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%8A%B8%EB%9E%98%ED%94%BD-%EA%B4%80%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>효율적인 트래픽 관리</h3>\n<p>Istio는 간편한 규칙(Rule) 설정과 트래픽 라우팅(Traffic Routing) 기능을 통해서 서비스 간의 트래픽 흐름과 API 호출을 제어할 수 있습니다. 또한 서킷 브레이커(Circuit Breaker), 타임아웃(Timeout), Retry 등의 기능과 같은 서비스 레벨의 속성 구성을 단순화 할 수 있습니다.</p>\n<p>이를 바탕으로 트래픽을 분할하여 A/B Test, Canary Rollout, Staged Rollout과 같은 작업을 쉽게 설정할 수 있습니다.</p>\n<p>트래픽에 대한 더 나은 가시성과 독창적인 장애 복구 기능을 통해서 문제가 발생하기 전에 문제를 발견하고 서비스 호출을 안정화 시킬 수 있습니다.</p>\n<h3 id=\"서비스-메시-모니터링\"><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%A9%94%EC%8B%9C-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서비스 메시 모니터링</h3>\n<p>Istio의 Tracing(트레이싱), Monitoring(모니터링), Logging(로깅) 기능으로 서비스 성능이 업스트림에 미치는 영향을 자세히 파악할 수 있습니다. 또한 서비스 성능이 업스트림이나 다운 스트림에 어떤 영향을 끼치는 지 파악할 수 있습니다. 또한 맞춤형 대시보드를 통해서 모든 서비스 성능을 보기 좋고, 다른 프로세스에 미치는 영향을 확인할 수 있습니다.</p>\n<h3 id=\"kubenetes-및-가상-머신을-통한-간편한-배포\"><a href=\"#kubenetes-%EB%B0%8F-%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0%EC%9D%84-%ED%86%B5%ED%95%9C-%EA%B0%84%ED%8E%B8%ED%95%9C-%EB%B0%B0%ED%8F%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Kubenetes 및 가상 머신을 통한 간편한 배포</h3>\n<p>Istio는 컨테이너 및 가상 머신을 포함하여 기존과 최신 워크로드 모두에 대해 가시성과 네트워크 제어를 제공합니다.</p>\n<p>즉, Istio는 플랫폼에 독립적입니다.</p>\n<h3 id=\"고급-기능을-통해-부하-분산-최소화\"><a href=\"#%EA%B3%A0%EA%B8%89-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%B6%80%ED%95%98-%EB%B6%84%EC%82%B0-%EC%B5%9C%EC%86%8C%ED%99%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>고급 기능을 통해 부하 분산 최소화</h3>\n<p>클라이언트 기반 라우팅, Canary Rollout과 같은 고급 기능과 함께 모든 트래픽에 자동화된 부하 분산을 사용할 수 있습니다.</p>\n<h3 id=\"정책-시행\"><a href=\"#%EC%A0%95%EC%B1%85-%EC%8B%9C%ED%96%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>정책 시행</h3>\n<p>액세스 제어, 비율 제한, 할당량을 지원하는 플러그인 가능한 정책 레이어 및 구성 API를 사용하여 정책을 시행할 수 있습니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>Istio에 대해 내용을 정리했습니다. 감사합니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://twofootdog.tistory.com/78\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://twofootdog.tistory.com/78</a></li>\n<li><a href=\"https://www.redhat.com/ko/topics/microservices/what-is-istio\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/microservices/what-is-istio</a></li>\n<li><a href=\"https://cloud.google.com/learn/what-is-istio?hl=ko\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cloud.google.com/learn/what-is-istio?hl=ko</a></li>\n<li><a href=\"https://arisu1000.tistory.com/27865\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://arisu1000.tistory.com/27865</a></li>\n</ul>\n"}},{"node":{"title":"[Kubernetes] Kubernetes란?","path":"/00-kubernetes/","date":"10. November 2020","timeToRead":13,"description":" 쿠버네티스에 대한 기본 내용을 정리한 글입니다. ","content":"<h1 id=\"kubernetes란\"><a href=\"#kubernetes%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Kubernetes란.</h1>\n<p>쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 오픈소스 플랫폼이이며 <strong>이식성, 확장가능성</strong>의 특징을 가집니다. 이 플랫폼은 컨테이너화된 애플리케이션을 배포하고 확장하는데 수동 프로세스가 필요하지 않습니다.</p>\n<p>이를 통해서 컨테이너를 실행하는 host 그룹을 함께 클러스팅이 가능하며, 클러스토를 쉽고 효율적으로 관리할 수 있다.</p>\n<blockquote>\n<p>용어에 대한 간단한 정리.</p>\n<ul>\n<li>컨테이너 : 호스트 OS상에 논리적인 구획(컨테이너)를 만들고, 어플리케이션을 작동시키기 위해 필요한 라이브러리나 어플리케이션 등을 하나로 모아서 마치 별도의 서버인 것처럼 사용할 수 있게 만든 것.</li>\n<li>클러스터 : 여러 대의 컴퓨터를 네트워크를 통해 하나의 단일 컴퓨터처럼 동작하도록 제작한 컴퓨터</li>\n</ul>\n<p>나중에 docker에 대해서도 추가적으로 설명하면서 더 자세하게 설명하겠습니다.</p>\n</blockquote>\n<p>쿠버네티스는 클라우드 전체로 호스트를 확장할 수 있고, 이러한 기능이 Apache Kafka 스트리밍과 같이 신속한 확장을 요구하는 클라우드 환경에서 큰 장점을 가집니다.</p>\n<br/>\n<h2 id=\"쿠버네티스의-기본-용어\"><a href=\"#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9A%A9%EC%96%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>쿠버네티스의 기본 용어</h2>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147045-cffd6a80-26c0-11eb-846e-dee35301857c.png\" alt=\"image\"></p>\n<ul>\n<li>마스터(Master) : 노드를 제어하고 전체 클러스터를 관리해주는 컨트롤러, 전체적인 제어/관리를 하기 위한 관리 서버</li>\n<li>노드(Nod) : 컨테이너가 배포될 물리 서버 또는 가상 머신이며 워커 노드(Worker Node)라고 불린다.</li>\n<li>파드(Pod) : 단일 노드에 배포된 하나 이상의 컨테이너 그룹이며, Pod라는 단위로 여러개의 컨테이너를 묶어서 파드 단위로 관리가 가능하다.</li>\n</ul>\n<br/>\n<h2 id=\"쿠버네티스의-특징\"><a href=\"#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>쿠버네티스의 특징</h2>\n<h3 id=\"1-여러회사들의-참여로-인한-큰-스케일과-커뮤니티-생태계\"><a href=\"#1-%EC%97%AC%EB%9F%AC%ED%9A%8C%EC%82%AC%EB%93%A4%EC%9D%98-%EC%B0%B8%EC%97%AC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%ED%81%B0-%EC%8A%A4%EC%BC%80%EC%9D%BC%EA%B3%BC-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0-%EC%83%9D%ED%83%9C%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 여러회사들의 참여로 인한 큰 스케일과 커뮤니티, 생태계</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147075-1fdc3180-26c1-11eb-88af-4702b0d1236e.png\" alt=\"image\"></p>\n<blockquote>\n<p>우리가 아는 많은 회사가 보인다.</p>\n</blockquote>\n<p>여러 회사의 노하우와 경험이 녹아있어서 다양한 커뮤니티와 좋은 생태계가 구성되어 있습니다. 대부분의 문제점이나 원하는 서비스를 만들려고 찾아보면 있는 것을 확인할 수 있습니다. CI(Continuous Integration), 컨테이너 서버리스, 머신러닝 등이 쿠버네티스 환경에서 잘 돌아갑니다.</p>\n<blockquote>\n<p>Kubernetes Community : <a href=\"https://kubernetes.io/ko/community/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kubernetes.io/ko/community/</a></p>\n</blockquote>\n<h3 id=\"2-다양한-배포-방식-지원\"><a href=\"#2-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%B0%B0%ED%8F%AC-%EB%B0%A9%EC%8B%9D-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 다양한 배포 방식 지원</h3>\n<p>쿠버네티스는 다양한 배포 방식을 지원합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/98945299-ae23ac80-2535-11eb-9fb2-f48b09e63f2c.png\" alt=\"image\"></p>\n<p>다음과 같이 Daemon Set, Deployment, stateful sets, Job등이 있으며, 각기 다른 특징을 가집니다.</p>\n<ul>\n<li><code class=\"language-text\">Daemont Set</code> : 디플로이먼트와 유사하게 파드를 생성하고 관리합니다. 디플로이먼트는 롤링 업데이트나 배포 일시 중지, 재개 등 배포 작업을 좀 더 세분화하여 조작하였다면, 데몬셋은 특정 노드 또는 모든 노드에 항상 실행되어야 할 특정 파드를 관리합니다.</li>\n<li><code class=\"language-text\">ReplicaSet</code> : 실행되는 파드 개수에 대한 가용성을 보증 하며 지정한 파드 개수만큼 항상 실행될 수 있도록 관리합니다.</li>\n<li><code class=\"language-text\">Deployment</code> : 레플리카셋의 상위 개념으로 볼 수도 있습니다. 레플리카셋을 생성하는 디플로이먼트를 정의할 수 있고, 배포 작업을 좀 더 세분화(롤링 업데이트 등) 하여 조작할 수 있는 기능을 제공합니다.</li>\n<li><code class=\"language-text\">Stateful Set</code> : 디플로이먼트와 유사하며 동일한 컨테이너 스펙을 기반으로 둔 파드들을 관리한다. 다만, 스테이트풀셋은 각 파드의 독자성을 유지하는 지속적인 식별자를 가집니다. (교체 불가)</li>\n<li><code class=\"language-text\">CronJob</code> : 크론잡은 지정한 일정에 특정 파드를 실행하는 잡을 실행할 수 있습니다.</li>\n<li><code class=\"language-text\">Job</code> : 잡은 하나 이상의 파드를 지정하고 지정된 수의 파드를 성공적으로 실행하도록 하는 설정, 노드의 H/W 장애나 재부팅 등으로 인해 파드가 정상 실행이 되지 않았을 경우 job은 새로운 파드를 시작하도록 할 수 있습니다.</li>\n<li><code class=\"language-text\">Replication Controller</code> : 레플리케이션컨트롤러 는 언제든지 지정된 수의 파드 레플리카가 실행 중임을 보장합니다. 즉, 레플리케이션 컨트롤러는 파드 또는 동일 종류의 파드의 셋이 항상 기동되고 사용 가능한지 확인할 수 있습니다.</li>\n</ul>\n<blockquote>\n<p>상세 설명은 해당 <a href=\"https://kubernetes.io/ko/docs/concepts/workloads/controllers/statefulset/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">여기</a> 에서...</p>\n</blockquote>\n<h3 id=\"3-ingress-기능-제공\"><a href=\"#3-ingress-%EA%B8%B0%EB%8A%A5-%EC%A0%9C%EA%B3%B5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. Ingress 기능 제공</h3>\n<p><strong>인그레스</strong>는 클러스터 외부에서 클러스터 내부 서비스로 HTTP와 HTTPS 경로를 노출합니다. 트래픽 라우팅은 인그레스 리소스에 정의된 규칙에 의해 컨트롤이 가능합니다.</p>\n<p>다음은 인스레스가 모든 트래픽을 하나의 서비스로 보내는 간단한 예시입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99082398-738a4480-2607-11eb-9741-c038299efc71.png\" alt=\"image\"></p>\n<p>인그레스는 외부에서 서비스로 접속이 가능한 URL, 로드 밸런스 트래픽, SSL / TLS 종료 그리고 이름-기반의 가상 호스팅을 제공하도록 구성할 수 있습니다. <strong>인그레스 컨트롤러</strong>는 일반적으로 로드 밸런서를 사용해서 인그레스를 수행할 책임이 있으며, 트래픽을 처리하는데 도움이 되도록 에지 라우터 또는 추가 프런트 엔드를 구성할 수도 있습니다.</p>\n<h3 id=\"4-클라우드-지원-기능\"><a href=\"#4-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%A7%80%EC%9B%90-%EA%B8%B0%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>4. 클라우드 지원 기능</h3>\n<p>쿠버네티스는 부하에 따라 자동으로 서버를 늘리는 기능인 AutoScaling이 있고, IP를 할당받아 로드밸런서로 사용할 수 있습니다.</p>\n<p>쿠버네티스는 Cloud Controller를 이용하여 클라우드 연동을 손쉽게 확장할 수 있습니다. 그 덕분에 AWS, Google Cloud, MS Azure 등을 쉽게 사용할 수 있습니다.</p>\n<h3 id=\"5-namespcae--label을-통한-구분\"><a href=\"#5-namespcae--label%EC%9D%84-%ED%86%B5%ED%95%9C-%EA%B5%AC%EB%B6%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>5. Namespcae &#x26; Label을 통한 구분</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147381-ed800380-26c3-11eb-8353-23f58c65b722.png\" alt=\"image\"></p>\n<p>하나의 클러스터를 논리적으로 구분해서 사용할 수 있습니다. 하나의 클러스터에 다양한 프레임워크와 애플리케이션을 설치하기 때문에 기본 (system, default)외에 여러 개의 네임스페이스를 사용하는 것이 일반적입니다.</p>\n<h3 id=\"6-rbacrole-based-access-control\"><a href=\"#6-rbacrole-based-access-control\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>6. RBAC(Role-based access control)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147431-3fc12480-26c4-11eb-9e76-50b1b9d780c6.png\" alt=\"image\"></p>\n<p>RBAC는 접근 권한 시스텝입니다. 각각의 리소스에 대해 유저별로 CRUD스러운 권한을 손쉽게 지정할 수 있으며, 클러스터 전체에 적용하거나 특정 네임스페이스에 적용할 수 있습니다.</p>\n<h3 id=\"7-crdcustom-resource-definitation\"><a href=\"#7-crdcustom-resource-definitation\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>7. CRD(Custom Resource Definitation)</h3>\n<p>쿠버네티스가 제공하지 않는 기능을 기본 기능과 동일한 빙식으로 적용하고 사용할 수 있는 기능입니다.</p>\n<ul>\n<li>Ex) Knative 등등</li>\n</ul>\n<h3 id=\"8-auto-scaling\"><a href=\"#8-auto-scaling\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>8. Auto Scaling</h3>\n<p>CPU, memory 사용량, 접속자 수 등을 조절할 수 있습니다. 다음과 같은 종류가 있습니다.</p>\n<ul>\n<li>HPA(Horizontal Pod Autoscaler) : 컨테이너 개수 조정</li>\n<li>VPA(Vertical Pod Autoscaler) : 컨테이너 리소스 할당량 조절</li>\n<li>CA(Cluster Autoscaler) : 서버 개수 조정</li>\n</ul>\n<h3 id=\"9-federation-multi-cluster\"><a href=\"#9-federation-multi-cluster\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>9. Federation, Multi Cluster</h3>\n<p>클라우드에 설치된 쿠버네티스 클러스와 자체 서버에 설치한 쿠버네티스를 묶어서 하나로 사용할 수 있습니다. 구글에서 발표한 Anthos를 사용하면 한 곳에서 여러 클라우드의 클러스터를 관리할 수 있습니다.</p>\n<h3 id=\"10-it-보안\"><a href=\"#10-it-%EB%B3%B4%EC%95%88\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>10. IT 보안</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147877-a98efd80-26c7-11eb-973f-58fae551a5d6.png\" alt=\"image\"></p>\n<p>컨테이너 보안은 멀티레이어 구조이므로 이는 복잡합니다. 쿠버네티스는 워크로드를 위해 규모에 맞는 컨테이너를 배포하는데 필요한 자원 및 관리 기능을 제공합니다. 이를 통해서 애플리케이션 서비스를 구축하고, 일정을 계획하고, 컨테이너를 확장해서 컨테이너 상태를 지속적으로 관리할 수 있습니다.</p>\n <br/>\n<h2 id=\"쿠버네티스의-개념\"><a href=\"#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>쿠버네티스의 개념</h2>\n<h3 id=\"desired-state\"><a href=\"#desired-state\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Desired State</h3>\n<p>쿠버네티스 공식 홈페이지의 document에서 등장하는 용어는 <strong>desired state</strong>이다. 이는 쿠버네티스를 이해하는데 가장 핵심적인 개념이다. 이는 쉽게 <strong>원하는 상태</strong>(ex. 웹서버의 갯수, 포트)를 의미합니다.</p>\n<p>쿠버네티스는 <strong>현재 상태(current state)</strong>를 지속적으로 모니터링하며, current state와 desired state 사이에 다른 부분이 있으면 이를 동일하게 만듭니다.</p>\n<p>이러한 로직으로 인해, 관리자가 서버를 배포할 때는 직접적인 명령을 하지 않고, 상태를 선언하는 방식을 사용합니다. 이 상태(desired state)를 선언하므로서, 현재 상태(current state)에서 이동합니다.</p>\n<blockquote>\n<p>핵심은 명령(imprative)이 아닌 선언(declarative)입니다.</p>\n</blockquote>\n<h3 id=\"kubernetes-object\"><a href=\"#kubernetes-object\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Kubernetes Object</h3>\n<p>쿠버네티스는 상태를 관리하기 위한 대상을 오브젝트로 정의합니다. 쿠버네티스는 여러가지의 오브젝트를 제공하고, 새로운 오브젝트를 추가하기 쉽기 때문에 확장성이 좋습니다.</p>\n<ul>\n<li>\n<p>Pod</p>\n<ul>\n<li><img src=\"https://user-images.githubusercontent.com/42582516/99166472-4e055400-2749-11eb-9ef3-05891a4762ff.png\" alt=\"image\"></li>\n<li>쿠버네티스에서 배포할 수 있는 가장 작은 단위</li>\n<li>하나 이상의 컨테이너, 스토리지, 네트워크 속성을 가짐</li>\n<li>하나의 Pod 안에 있는 컨테이너는 스토리지, 네트워크를 공유합니다.</li>\n</ul>\n</li>\n<li>\n<p>ReplicaSet</p>\n<ul>\n<li>Pod을 여러개 복제하여 관리하는 오브젝트</li>\n<li>Pod을 생성하고 개수를 유지하기 위해서 반드시 사용합니다.</li>\n<li>YAML에서 replicas의 갯수를 지정하여 Pod의 개수를 몇개 유지할 지 결정할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>Service</p>\n<ul>\n<li>네트워크와 관련된 오브젝트</li>\n<li>Pod을 외부 네트워크에 연결해주며, 여러 개의 Pod을 바라보는 내부 로드 밸런서를 생성할 때 사용</li>\n<li>서비스 디스커버리 역활도 수행합니다. (내부 DNS에 서비스 이름을 도메인으로 등록합니다.)</li>\n</ul>\n</li>\n<li>\n<p>Volume</p>\n<ul>\n<li>저장소와 관련된 오브젝트</li>\n<li>대부분으 저장 방식을 지원합니다.</li>\n</ul>\n</li>\n<li>\n<p>Object Spec - YAML</p>\n<ul>\n<li>오브젝트외 종류와 원하는 상태로 입력합니다.</li>\n<li>해당 명세는 생성, 조회, 삭제로 관리할 수 있어서 REST API로 쉽게 노출이 가능합니다.</li>\n<li>접근 권한 설정도 같은 개념을 적용하여 어떤 오브젝트에 어떤 요청을 할 수 있는지 정의할 수 있습니다.</li>\n<li>아래는 예시 YAML파일입니다.</li>\n<li>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> apps/v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Deployment\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n<span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">-</span>deployment\n<span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> nginx\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n<span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span>\n<span class=\"token key atrule\">selector</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">matchLabels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> nginx\n<span class=\"token key atrule\">template</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> nginx\n    <span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nginx\n        <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">:</span>1.7.9\n        <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">containerPort</span><span class=\"token punctuation\">:</span> <span class=\"token number\">80</span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"쿠버네티스-배포-양식\"><a href=\"#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%B0%ED%8F%AC-%EC%96%91%EC%8B%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>쿠버네티스 배포 양식</h3>\n<p>이전에 이야기 했듯이 쿠버네티스는 애플리케이션을 배포하기 위해 원하는 상태(desired state)를 다양한 오브젝트(object)에 라벨(label)을 붙여서 정의하고 API 서버에 전달하는 방식을 사용합니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>쿠버네티스에 대한 개념을 찾기 위해서, 많은 글을 읽으면서 정리했습니다. 이후에 좀 더 공부해서 부족한 내용을 좀 더 추가하겠습니다. 그리고 설치 등을 해보면서 이후에 좀 더 글을 작성하겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/</a></li>\n<li><a href=\"https://subicura.com/2019/05/19/kubernetes-basic-1.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://subicura.com/2019/05/19/kubernetes-basic-1.html</a></li>\n<li><a href=\"https://www.redhat.com/ko/topics/containers/what-is-kubernetes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/containers/what-is-kubernetes</a></li>\n<li><a href=\"https://nirsa.tistory.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://nirsa.tistory.com/</a></li>\n<li><a href=\"https://nirsa.tistory.com/129?category=871751\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://nirsa.tistory.com/129?category=871751</a></li>\n<li><a href=\"https://arisu1000.tistory.com/27862\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://arisu1000.tistory.com/27862</a></li>\n<li><a href=\"https://suhwan.dev/2019/04/22/understanding-kubernetes-design/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://suhwan.dev/2019/04/22/understanding-kubernetes-design/</a></li>\n</ul>\n"}}]}}},"context":{}}