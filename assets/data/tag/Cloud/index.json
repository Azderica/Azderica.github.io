{"hash":"a43281d937e690ee41ca21913c539571e0d27905","data":{"tag":{"title":"Cloud","belongsTo":{"edges":[{"node":{"title":"[Architecture] MSA : Istio 개념 잡기","path":"/00-architecture-istio/","date":"2. February 2021","timeToRead":10,"description":"Istio 패턴에 대해 정리합니다.","content":"<h1 id=\"istio\"><a href=\"#istio\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio</h1>\n<h2 id=\"istio의-정의\"><a href=\"#istio%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio의 정의</h2>\n<p>Istio는 <strong>애플리케이션 네트워크 기능을 유연하고 쉽게 자동화할 수 있는 투명한 언어 독립적인 방법을 제공하는 현대화된 서비스 네트워킹 레이어인 서비스 메시</strong>입니다. 클라우드 기반 애플리케이션을 구성하는 다양한 마이크로 서비스르르 관리하는데 널리 사용되는 솔루션이며 마이크로 서비스가 서로 통신하고 데이터를 공유하는 방법을 지원합니다.</p>\n<p>Istio를 통해서 느슨하게 결합된 마이크로 서비스를 통해 앱을 어셈블하고, 새로운 클라우드 기반 앱을 관리할 수 있습니다. 또한 <strong>서비스 코드 변경 없이 로드배런싱, 서비스 간 인증, 모니터링 등을 적용해서 마이크로 서비스를 쉽게 관리</strong>할 수 있습니다.</p>\n<p>Istio는 애플리케이션 코드를 변경할 필요 없이 서비스 간 트래픽 흐름을 관리하고 액세스 정책을 적용하여 원격 분석 데이터를 집계합니다. 또한 기존의 분산형 애플리케이션에 투명하게 레이어하여 배포 복잡성을 완화시킵니다.</p>\n<h3 id=\"service-mesh-란\"><a href=\"#service-mesh-%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><code class=\"language-text\">Service Mesh</code> 란?</h3>\n<ul>\n<li>애플리케이션의 다양한 부분들이 서로의 데이터를 공유하는 방식을 제어하는 방법입니다.</li>\n<li>좀 더 자세하게 이야기 한다면, API 등을 사용해서 마이크로 서비스간 통신을 안전하고, 빠르고, 신뢰할 수 있게 만들기 위해 설계된 전용 인프라 계층입니다.</li>\n<li>Service Discovery, Load Balancing, Dynamic Request Routing, Circuit Breacking, Retry and Timeout, TLS, Distributed Tracing, Metric 수집, Access Control, A/B Testing 기능 등을 지원합니다.</li>\n</ul>\n<br/>\n<h2 id=\"istio-service-mesh의-장점\"><a href=\"#istio-service-mesh%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio Service Mesh의 장점</h2>\n<h3 id=\"일관된-서비스-네트워킹-달성\"><a href=\"#%EC%9D%BC%EA%B4%80%EB%90%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9-%EB%8B%AC%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>일관된 서비스 네트워킹 달성</h3>\n<p>네트워킹 운영자는 개발자 오버헤드를 추가하지 않고도 모든 서비스의 네트워킹을 일관성 있게 관리할 수 있습니다.</p>\n<h3 id=\"istio-이점을-통해-서비스-보호\"><a href=\"#istio-%EC%9D%B4%EC%A0%90%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%B3%B4%ED%98%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio 이점을 통해 서비스 보호</h3>\n<p>보안 운영자는 인증, 승인, 암호화를 비롯한 서비스 간 보안을 쉽게 구현할 수 있습니다.</p>\n<h3 id=\"애플리케이션-성능-향상\"><a href=\"#%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>애플리케이션 성능 향상</h3>\n<p>Canary Rollout(새로운 버전 모델 배포시, 소규모 사용자에게 먼저 제공함으로서 위험을 빠르게 감지하는 배포 전략)과 같은 권장사항을 구현하고 애플리케이션을 심도 있게 파악하여 성능을 개선하기 위해 집중해야하는 부분을 파악할 수 있습니다.</p>\n<br/>\n<h2 id=\"istio의-구조\"><a href=\"#istio%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio의 구조</h2>\n<p>마이크로 서비스 간의 모든 네트워크 통신을 담당할 수 잇는 프록시인 Envoy를 사이드카 패턴으로 마이크로 서비스들에 배포한 다음, 프록시들의 설정 값 저장 및 관리/감독을 수행하고, 프록시들에 설정값을 전달하는 컨트롤러를 수행합니다.</p>\n<p>그후 각각의 마이크로 서비스에 사이드카 패턴으로 배포된 Envoy 프록시를 <code class=\"language-text\">데이터 플레인(Data Plane)</code> 이라고 하며, 이를 컨트롤 하는 부분이 <code class=\"language-text\">컨트롤 플레인(Control Plane)</code>이라고 합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/106528740-981dfa80-652c-11eb-95e7-fd408293b65e.png\" alt=\"Istio-Architecture\"></p>\n<p>구성요소를 좀 더 자세하게 설명하면 다음과 같습니다.</p>\n<h3 id=\"data-plane-데이터-플레인\"><a href=\"#data-plane-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%8C%EB%A0%88%EC%9D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Plane (데이터 플레인)</h3>\n<p>실제 데이터 트래픽이 돌아다니는 영역입니다. Envoy Proxy 세트로 구성되어 있습니다.</p>\n<h4 id=\"envoy\"><a href=\"#envoy\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Envoy</h4>\n<p>Envoy는 사이드카 방식으로 각각의 마이크로서비스에 배포되어 서비스로 들어오고 나가는 모든 트래픽을 통제합니다. Envoy를 통해서 서비스를 호출할 때 호출하는 서비스의 IP주소는 파일럿에 저당된 엔드포인트 정보를 활용합니다.</p>\n<p>Istio는 Envoy의 <strong>동적 서비스 디스커버리, 로드밸런싱, TLS 인증서 처리, HTTP/2, gRPC 프록시, 서킷브레이커, 헬스체크, 실패 삽입, 많은 메트릭 등의 기능을 사용</strong>할 수 있습니다.</p>\n<p>사이드카 방식을 사용하기 때문에 기존 컨테이너나 코드를 재사용할 필요없이 그대로 사용가능합니다.</p>\n<h3 id=\"control-plane-컨트롤-플레인\"><a href=\"#control-plane-%EC%BB%A8%ED%8A%B8%EB%A1%A4-%ED%94%8C%EB%A0%88%EC%9D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Control Plane (컨트롤 플레인)</h3>\n<p>트래픽 경로를 설정하고 관리하는 용도로 사용합니다.</p>\n<p>Istio1.4 버전까지는 <strong>파일럿(Pilot), 믹서(Mixer), 시타델(Citadel), 갤리(Galley)</strong> 로 구성되어 있었으나 Istio1.5버전부터 4개의 모듈이 <strong>Istiod</strong> 라는 하나의 모듈로 통합되었습니다.</p>\n<h4 id=\"mixer\"><a href=\"#mixer\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Mixer</h4>\n<ul>\n<li>서비스 매쉬 엑세스 컨트롤 및 정책 관리 수행합니다.</li>\n<li>Envoy와 다른 서비스에서 모니터링 지표 수집합니다.</li>\n</ul>\n<h4 id=\"pilot\"><a href=\"#pilot\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Pilot</h4>\n<ul>\n<li>Envoy 설정 관리를 수행하는 모듈입니다.</li>\n<li>Envoy가 호출하는 서비스의 주소를 얻을 수 잇는 Service Discovery 기능을 제공합니다.</li>\n<li>서비스 트래픽 라우팅 기능 제공합니다.</li>\n<li>서비스 안정성을 위해 서비스 간 호출시 Time out, Retry, Circuit Breaker(서킷 브레이커)같은 기능들을 제공합니다.</li>\n</ul>\n<h4 id=\"citadel\"><a href=\"#citadel\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Citadel</h4>\n<ul>\n<li>보안 관련 기능을 수행하는 모듈입니다.</li>\n<li>사용자 인증을 통해서 서비스/앤드 유저 간의 인증을 강화합니다.</li>\n<li>TLS(SSL)을 이용하여 통신 암호화와 인증서 관리를 할 수 있습니다.</li>\n</ul>\n<h4 id=\"galley\"><a href=\"#galley\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Galley</h4>\n<ul>\n<li>Istio 설정을 Validation, Ingestion, Processing, Distribution 하는 역할을 합니다.</li>\n<li>즉, Istio의 구성 및 설정을 검증하고 배포 관리를 진행합니다.</li>\n</ul>\n<h4 id=\"istiod\"><a href=\"#istiod\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istiod</h4>\n<p>Istio 1.5 이상 버전에서 제공되며 서비스 디스커버리, 설정관리, 인증관리 등을 수행합니다.</p>\n<ul>\n<li>트래픽 동작을 제어하는 라우팅 규칙을 Envoy 전용 설정으로 변환하고 마이크로 서비스에 사이드카 방식으로 Envoy를 배포합니다.</li>\n<li>Envoy 설정 변경을 통해 서비스 메시 트래픽을 제어합니다.</li>\n<li>내장된 Identity나 Credential Management(증명 관리)을 통해서 강력한 서비스 간 인증 및 사용자 인증 기능을 지원합니다.</li>\n<li>인증 기관의 역할을 수행하, 데이터 플레인에서 안전한 mTLS 통신을 허용하는 인증서를 생성합니다.</li>\n</ul>\n<br/>\n<h2 id=\"istio의-장점\"><a href=\"#istio%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Istio의 장점</h2>\n<p>Istio를 통해서 분산형 애플리케이션을 대규모로 제공할 수 있습니다. 아래와 같은 장점이 있습니다.</p>\n<h3 id=\"안전한-클라우드-기반-앱\"><a href=\"#%EC%95%88%EC%A0%84%ED%95%9C-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EA%B8%B0%EB%B0%98-%EC%95%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>안전한 클라우드 기반 앱</h3>\n<p>Istio는 기본적인 보안 통신 채널을 제공하며 대규모 서비스 통신의 인증(Authentication), 권한부여(Authorization), 암호화(Encryption) 등을 통해서 애플리케이션 수준에서 보안을 강화할 수 있습니다.</p>\n<h3 id=\"효율적인-트래픽-관리\"><a href=\"#%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%8A%B8%EB%9E%98%ED%94%BD-%EA%B4%80%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>효율적인 트래픽 관리</h3>\n<p>Istio는 간편한 규칙(Rule) 설정과 트래픽 라우팅(Traffic Routing) 기능을 통해서 서비스 간의 트래픽 흐름과 API 호출을 제어할 수 있습니다. 또한 서킷 브레이커(Circuit Breaker), 타임아웃(Timeout), Retry 등의 기능과 같은 서비스 레벨의 속성 구성을 단순화 할 수 있습니다.</p>\n<p>이를 바탕으로 트래픽을 분할하여 A/B Test, Canary Rollout, Staged Rollout과 같은 작업을 쉽게 설정할 수 있습니다.</p>\n<p>트래픽에 대한 더 나은 가시성과 독창적인 장애 복구 기능을 통해서 문제가 발생하기 전에 문제를 발견하고 서비스 호출을 안정화 시킬 수 있습니다.</p>\n<h3 id=\"서비스-메시-모니터링\"><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%A9%94%EC%8B%9C-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서비스 메시 모니터링</h3>\n<p>Istio의 Tracing(트레이싱), Monitoring(모니터링), Logging(로깅) 기능으로 서비스 성능이 업스트림에 미치는 영향을 자세히 파악할 수 있습니다. 또한 서비스 성능이 업스트림이나 다운 스트림에 어떤 영향을 끼치는 지 파악할 수 있습니다. 또한 맞춤형 대시보드를 통해서 모든 서비스 성능을 보기 좋고, 다른 프로세스에 미치는 영향을 확인할 수 있습니다.</p>\n<h3 id=\"kubenetes-및-가상-머신을-통한-간편한-배포\"><a href=\"#kubenetes-%EB%B0%8F-%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0%EC%9D%84-%ED%86%B5%ED%95%9C-%EA%B0%84%ED%8E%B8%ED%95%9C-%EB%B0%B0%ED%8F%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Kubenetes 및 가상 머신을 통한 간편한 배포</h3>\n<p>Istio는 컨테이너 및 가상 머신을 포함하여 기존과 최신 워크로드 모두에 대해 가시성과 네트워크 제어를 제공합니다.</p>\n<p>즉, Istio는 플랫폼에 독립적입니다.</p>\n<h3 id=\"고급-기능을-통해-부하-분산-최소화\"><a href=\"#%EA%B3%A0%EA%B8%89-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%B6%80%ED%95%98-%EB%B6%84%EC%82%B0-%EC%B5%9C%EC%86%8C%ED%99%94\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>고급 기능을 통해 부하 분산 최소화</h3>\n<p>클라이언트 기반 라우팅, Canary Rollout과 같은 고급 기능과 함께 모든 트래픽에 자동화된 부하 분산을 사용할 수 있습니다.</p>\n<h3 id=\"정책-시행\"><a href=\"#%EC%A0%95%EC%B1%85-%EC%8B%9C%ED%96%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>정책 시행</h3>\n<p>액세스 제어, 비율 제한, 할당량을 지원하는 플러그인 가능한 정책 레이어 및 구성 API를 사용하여 정책을 시행할 수 있습니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>Istio에 대해 내용을 정리했습니다. 감사합니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://twofootdog.tistory.com/78\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://twofootdog.tistory.com/78</a></li>\n<li><a href=\"https://www.redhat.com/ko/topics/microservices/what-is-istio\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/microservices/what-is-istio</a></li>\n<li><a href=\"https://cloud.google.com/learn/what-is-istio?hl=ko\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://cloud.google.com/learn/what-is-istio?hl=ko</a></li>\n<li><a href=\"https://arisu1000.tistory.com/27865\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://arisu1000.tistory.com/27865</a></li>\n</ul>\n"}},{"node":{"title":"[Kubernetes] Kubernetes란?","path":"/00-kubernetes/","date":"10. November 2020","timeToRead":13,"description":" 쿠버네티스에 대한 기본 내용을 정리한 글입니다. ","content":"<h1 id=\"kubernetes란\"><a href=\"#kubernetes%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Kubernetes란.</h1>\n<p>쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 오픈소스 플랫폼이이며 <strong>이식성, 확장가능성</strong>의 특징을 가집니다. 이 플랫폼은 컨테이너화된 애플리케이션을 배포하고 확장하는데 수동 프로세스가 필요하지 않습니다.</p>\n<p>이를 통해서 컨테이너를 실행하는 host 그룹을 함께 클러스팅이 가능하며, 클러스토를 쉽고 효율적으로 관리할 수 있다.</p>\n<blockquote>\n<p>용어에 대한 간단한 정리.</p>\n<ul>\n<li>컨테이너 : 호스트  OS상에 논리적인 구획(컨테이너)를 만들고, 어플리케이션을 작동시키기 위해 필요한 라이브러리나 어플리케이션 등을 하나로 모아서 마치 별도의 서버인 것처럼 사용할 수 있게 만든 것.</li>\n<li>클러스터 : 여러 대의 컴퓨터를 네트워크를 통해 하나의 단일 컴퓨터처럼 동작하도록 제작한 컴퓨터</li>\n</ul>\n<p>나중에 docker에 대해서도 추가적으로 설명하면서 더 자세하게 설명하겠습니다.</p>\n</blockquote>\n<p>쿠버네티스는 클라우드 전체로 호스트를 확장할 수 있고, 이러한 기능이 Apache Kafka 스트리밍과 같이 신속한 확장을 요구하는 클라우드 환경에서 큰 장점을 가집니다.</p>\n<br/>\n<h2 id=\"쿠버네티스의-기본-용어\"><a href=\"#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9A%A9%EC%96%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>쿠버네티스의 기본 용어</h2>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147045-cffd6a80-26c0-11eb-846e-dee35301857c.png\" alt=\"image\"></p>\n<ul>\n<li>마스터(Master) : 노드를 제어하고 전체 클러스터를 관리해주는 컨트롤러, 전체적인 제어/관리를 하기 위한 관리 서버</li>\n<li>노드(Nod) : 컨테이너가 배포될 물리 서버 또는 가상 머신이며 워커 노드(Worker Node)라고 불린다.</li>\n<li>파드(Pod) : 단일 노드에 배포된 하나 이상의 컨테이너 그룹이며, Pod라는 단위로 여러개의 컨테이너를 묶어서 파드 단위로 관리가 가능하다.</li>\n</ul>\n<br/>\n<h2 id=\"쿠버네티스의-특징\"><a href=\"#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>쿠버네티스의 특징</h2>\n<h3 id=\"1-여러회사들의-참여로-인한-큰-스케일과-커뮤니티-생태계\"><a href=\"#1-%EC%97%AC%EB%9F%AC%ED%9A%8C%EC%82%AC%EB%93%A4%EC%9D%98-%EC%B0%B8%EC%97%AC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%ED%81%B0-%EC%8A%A4%EC%BC%80%EC%9D%BC%EA%B3%BC-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0-%EC%83%9D%ED%83%9C%EA%B3%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 여러회사들의 참여로 인한 큰 스케일과 커뮤니티, 생태계</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147075-1fdc3180-26c1-11eb-88af-4702b0d1236e.png\" alt=\"image\"></p>\n<blockquote>\n<p>우리가 아는 많은 회사가 보인다.</p>\n</blockquote>\n<p>여러 회사의 노하우와 경험이 녹아있어서 다양한 커뮤니티와 좋은 생태계가 구성되어 있습니다. 대부분의 문제점이나 원하는 서비스를 만들려고 찾아보면 있는 것을 확인할 수 있습니다. CI(Continuous Integration), 컨테이너 서버리스, 머신러닝 등이 쿠버네티스 환경에서 잘 돌아갑니다.</p>\n<blockquote>\n<p>Kubernetes Community : <a href=\"https://kubernetes.io/ko/community/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kubernetes.io/ko/community/</a></p>\n</blockquote>\n<h3 id=\"2-다양한-배포-방식-지원\"><a href=\"#2-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%B0%B0%ED%8F%AC-%EB%B0%A9%EC%8B%9D-%EC%A7%80%EC%9B%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 다양한 배포 방식 지원</h3>\n<p>쿠버네티스는 다양한 배포 방식을 지원합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/98945299-ae23ac80-2535-11eb-9fb2-f48b09e63f2c.png\" alt=\"image\"></p>\n<p>다음과 같이 Daemon Set, Deployment, stateful sets, Job등이 있으며, 각기 다른 특징을 가집니다.</p>\n<ul>\n<li><code class=\"language-text\">Daemont Set</code> : 디플로이먼트와 유사하게 파드를 생성하고 관리합니다. 디플로이먼트는 롤링 업데이트나 배포 일시 중지, 재개 등 배포 작업을 좀 더 세분화하여 조작하였다면, 데몬셋은 특정 노드 또는 모든 노드에 항상 실행되어야 할 특정 파드를 관리합니다.</li>\n<li><code class=\"language-text\">ReplicaSet</code> : 실행되는 파드 개수에 대한 가용성을 보증 하며 지정한 파드 개수만큼 항상 실행될 수 있도록 관리합니다.</li>\n<li><code class=\"language-text\">Deployment</code> : 레플리카셋의 상위 개념으로 볼 수도 있습니다. 레플리카셋을 생성하는 디플로이먼트를 정의할 수 있고, 배포 작업을 좀 더 세분화(롤링 업데이트 등) 하여 조작할 수 있는 기능을 제공합니다.</li>\n<li><code class=\"language-text\">Stateful Set</code> : 디플로이먼트와 유사하며 동일한 컨테이너 스펙을 기반으로 둔 파드들을 관리한다. 다만, 스테이트풀셋은 각 파드의 독자성을 유지하는 지속적인 식별자를 가집니다. (교체 불가)</li>\n<li><code class=\"language-text\">CronJob</code> : 크론잡은 지정한 일정에 특정 파드를 실행하는 잡을 실행할 수 있습니다.</li>\n<li><code class=\"language-text\">Job</code> : 잡은 하나 이상의 파드를 지정하고 지정된 수의 파드를 성공적으로 실행하도록 하는 설정, 노드의 H/W 장애나 재부팅 등으로 인해 파드가 정상 실행이 되지 않았을 경우 job은 새로운 파드를 시작하도록 할 수 있습니다.</li>\n<li><code class=\"language-text\">Replication Controller</code> : 레플리케이션컨트롤러 는 언제든지 지정된 수의 파드 레플리카가 실행 중임을 보장합니다. 즉, 레플리케이션 컨트롤러는 파드 또는 동일 종류의 파드의 셋이 항상 기동되고 사용 가능한지 확인할 수 있습니다.</li>\n</ul>\n<blockquote>\n<p>상세 설명은 해당 <a href=\"https://kubernetes.io/ko/docs/concepts/workloads/controllers/statefulset/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">여기</a> 에서...</p>\n</blockquote>\n<h3 id=\"3-ingress-기능-제공\"><a href=\"#3-ingress-%EA%B8%B0%EB%8A%A5-%EC%A0%9C%EA%B3%B5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. Ingress 기능 제공</h3>\n<p><strong>인그레스</strong>는 클러스터 외부에서 클러스터 내부 서비스로 HTTP와 HTTPS 경로를 노출합니다. 트래픽 라우팅은 인그레스 리소스에 정의된 규칙에 의해 컨트롤이 가능합니다.</p>\n<p>다음은 인스레스가 모든 트래픽을 하나의 서비스로 보내는 간단한 예시입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99082398-738a4480-2607-11eb-9741-c038299efc71.png\" alt=\"image\"></p>\n<p>인그레스는 외부에서 서비스로 접속이 가능한 URL, 로드 밸런스 트래픽, SSL / TLS 종료 그리고 이름-기반의 가상 호스팅을 제공하도록 구성할 수 있습니다. <strong>인그레스 컨트롤러</strong>는 일반적으로 로드 밸런서를 사용해서 인그레스를 수행할 책임이 있으며, 트래픽을 처리하는데 도움이 되도록 에지 라우터 또는 추가 프런트 엔드를 구성할 수도 있습니다.</p>\n<h3 id=\"4-클라우드-지원-기능\"><a href=\"#4-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EC%A7%80%EC%9B%90-%EA%B8%B0%EB%8A%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>4. 클라우드 지원 기능</h3>\n<p>쿠버네티스는 부하에 따라 자동으로 서버를 늘리는 기능인 AutoScaling이 있고, IP를 할당받아 로드밸런서로 사용할 수 있습니다.</p>\n<p>쿠버네티스는 Cloud Controller를 이용하여 클라우드 연동을 손쉽게 확장할 수 있습니다. 그 덕분에 AWS, Google Cloud, MS Azure 등을 쉽게 사용할 수 있습니다.</p>\n<h3 id=\"5-namespcae--label을-통한-구분\"><a href=\"#5-namespcae--label%EC%9D%84-%ED%86%B5%ED%95%9C-%EA%B5%AC%EB%B6%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>5. Namespcae &#x26; Label을 통한 구분</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147381-ed800380-26c3-11eb-8353-23f58c65b722.png\" alt=\"image\"></p>\n<p>하나의 클러스터를 논리적으로 구분해서 사용할 수 있습니다. 하나의 클러스터에 다양한 프레임워크와 애플리케이션을 설치하기 때문에 기본 (system, default)외에 여러 개의 네임스페이스를 사용하는 것이 일반적입니다.</p>\n<h3 id=\"6-rbacrole-based-access-control\"><a href=\"#6-rbacrole-based-access-control\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>6. RBAC(Role-based access control)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147431-3fc12480-26c4-11eb-9e76-50b1b9d780c6.png\" alt=\"image\"></p>\n<p>RBAC는 접근 권한 시스텝입니다. 각각의 리소스에 대해 유저별로 CRUD스러운 권한을 손쉽게 지정할 수 있으며, 클러스터 전체에 적용하거나 특정 네임스페이스에 적용할 수 있습니다.</p>\n<h3 id=\"7-crdcustom-resource-definitation\"><a href=\"#7-crdcustom-resource-definitation\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>7. CRD(Custom Resource Definitation)</h3>\n<p>쿠버네티스가 제공하지 않는 기능을 기본 기능과 동일한 빙식으로 적용하고 사용할 수 있는 기능입니다. </p>\n<ul>\n<li>Ex) Knative 등등</li>\n</ul>\n<h3 id=\"8-auto-scaling\"><a href=\"#8-auto-scaling\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>8. Auto Scaling</h3>\n<p>CPU, memory 사용량, 접속자 수 등을 조절할 수 있습니다. 다음과 같은 종류가 있습니다.</p>\n<ul>\n<li>HPA(Horizontal Pod Autoscaler) : 컨테이너 개수 조정</li>\n<li>VPA(Vertical Pod Autoscaler) : 컨테이너 리소스 할당량 조절</li>\n<li>CA(Cluster Autoscaler) : 서버 개수 조정</li>\n</ul>\n<h3 id=\"9-federation-multi-cluster\"><a href=\"#9-federation-multi-cluster\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>9. Federation, Multi Cluster</h3>\n<p>클라우드에 설치된 쿠버네티스 클러스와 자체 서버에 설치한 쿠버네티스를 묶어서 하나로 사용할 수 있습니다. 구글에서 발표한 Anthos를 사용하면 한 곳에서 여러 클라우드의 클러스터를 관리할 수 있습니다.</p>\n<h3 id=\"10-it-보안\"><a href=\"#10-it-%EB%B3%B4%EC%95%88\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>10. IT 보안</h3>\n<p><img src=\"https://user-images.githubusercontent.com/42582516/99147877-a98efd80-26c7-11eb-973f-58fae551a5d6.png\" alt=\"image\"></p>\n<p>컨테이너 보안은 멀티레이어 구조이므로 이는 복잡합니다. 쿠버네티스는 워크로드를 위해 규모에 맞는 컨테이너를 배포하는데 필요한 자원 및 관리 기능을 제공합니다. 이를 통해서 애플리케이션 서비스를 구축하고, 일정을 계획하고, 컨테이너를 확장해서 컨테이너 상태를 지속적으로 관리할 수 있습니다.</p>\n <br/>\n<h2 id=\"쿠버네티스의-개념\"><a href=\"#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>쿠버네티스의 개념</h2>\n<h3 id=\"desired-state\"><a href=\"#desired-state\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Desired State</h3>\n<p>쿠버네티스 공식 홈페이지의 document에서 등장하는 용어는 <strong>desired state</strong>이다. 이는 쿠버네티스를 이해하는데 가장 핵심적인 개념이다. 이는 쉽게 <strong>원하는 상태</strong>(ex. 웹서버의 갯수, 포트)를 의미합니다. </p>\n<p>쿠버네티스는 <strong>현재 상태(current state)</strong>를 지속적으로 모니터링하며, current state와 desired state 사이에 다른 부분이 있으면 이를 동일하게 만듭니다.</p>\n<p>이러한 로직으로 인해, 관리자가 서버를 배포할 때는 직접적인 명령을 하지 않고, 상태를 선언하는 방식을 사용합니다. 이 상태(desired state)를 선언하므로서, 현재 상태(current state)에서 이동합니다.</p>\n<blockquote>\n<p>핵심은 명령(imprative)이 아닌 선언(declarative)입니다.</p>\n</blockquote>\n<h3 id=\"kubernetes-object\"><a href=\"#kubernetes-object\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Kubernetes Object</h3>\n<p>쿠버네티스는 상태를 관리하기 위한 대상을 오브젝트로 정의합니다. 쿠버네티스는 여러가지의 오브젝트를 제공하고, 새로운 오브젝트를 추가하기 쉽기 때문에 확장성이 좋습니다.</p>\n<ul>\n<li>\n<p>Pod</p>\n<ul>\n<li><img src=\"https://user-images.githubusercontent.com/42582516/99166472-4e055400-2749-11eb-9ef3-05891a4762ff.png\" alt=\"image\"></li>\n<li>쿠버네티스에서 배포할 수 있는 가장 작은 단위</li>\n<li>하나 이상의 컨테이너, 스토리지, 네트워크 속성을 가짐</li>\n<li>하나의 Pod 안에 있는 컨테이너는 스토리지, 네트워크를 공유합니다.</li>\n</ul>\n</li>\n<li>\n<p>ReplicaSet</p>\n<ul>\n<li>Pod을 여러개 복제하여 관리하는 오브젝트</li>\n<li>Pod을 생성하고 개수를 유지하기 위해서 반드시 사용합니다.</li>\n<li>YAML에서 replicas의 갯수를 지정하여 Pod의 개수를 몇개 유지할 지 결정할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>Service</p>\n<ul>\n<li>네트워크와 관련된 오브젝트</li>\n<li>Pod을 외부 네트워크에 연결해주며, 여러 개의 Pod을 바라보는 내부 로드 밸런서를 생성할 때 사용</li>\n<li>서비스 디스커버리 역활도 수행합니다. (내부 DNS에 서비스 이름을 도메인으로 등록합니다.)</li>\n</ul>\n</li>\n<li>\n<p>Volume</p>\n<ul>\n<li>저장소와 관련된 오브젝트</li>\n<li>대부분으 저장 방식을 지원합니다.</li>\n</ul>\n</li>\n<li>\n<p>Object Spec - YAML</p>\n<ul>\n<li>오브젝트외 종류와 원하는 상태로 입력합니다.</li>\n<li>해당 명세는 생성, 조회, 삭제로 관리할 수 있어서 REST API로 쉽게 노출이 가능합니다.</li>\n<li>접근 권한 설정도 같은 개념을 적용하여 어떤 오브젝트에 어떤 요청을 할 수 있는지 정의할 수 있습니다.</li>\n<li>아래는 예시 YAML파일입니다. </li>\n<li>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> apps/v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Deployment\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n<span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">-</span>deployment\n<span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> nginx\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n<span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span>\n<span class=\"token key atrule\">selector</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">matchLabels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> nginx\n<span class=\"token key atrule\">template</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> nginx\n    <span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nginx\n        <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">:</span>1.7.9\n        <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">containerPort</span><span class=\"token punctuation\">:</span> <span class=\"token number\">80</span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"쿠버네티스-배포-양식\"><a href=\"#%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%B0%ED%8F%AC-%EC%96%91%EC%8B%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>쿠버네티스 배포 양식</h3>\n<p>이전에 이야기 했듯이 쿠버네티스는 애플리케이션을 배포하기 위해 원하는 상태(desired state)를 다양한 오브젝트(object)에 라벨(label)을 붙여서 정의하고 API 서버에 전달하는 방식을 사용합니다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>쿠버네티스에 대한 개념을 찾기 위해서, 많은 글을 읽으면서 정리했습니다. 이후에 좀 더 공부해서 부족한 내용을 좀 더 추가하겠습니다. 그리고 설치 등을 해보면서 이후에 좀 더 글을 작성하겠습니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/</a></li>\n<li><a href=\"https://subicura.com/2019/05/19/kubernetes-basic-1.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://subicura.com/2019/05/19/kubernetes-basic-1.html</a></li>\n<li><a href=\"https://www.redhat.com/ko/topics/containers/what-is-kubernetes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/containers/what-is-kubernetes</a></li>\n<li><a href=\"https://nirsa.tistory.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://nirsa.tistory.com/</a></li>\n<li><a href=\"https://nirsa.tistory.com/129?category=871751\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://nirsa.tistory.com/129?category=871751</a></li>\n<li><a href=\"https://arisu1000.tistory.com/27862\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://arisu1000.tistory.com/27862</a></li>\n<li><a href=\"https://suhwan.dev/2019/04/22/understanding-kubernetes-design/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://suhwan.dev/2019/04/22/understanding-kubernetes-design/</a></li>\n</ul>\n"}}]}}},"context":{}}