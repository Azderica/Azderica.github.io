{"hash":"ae819642c9f6ee0978dccc3fd45c022929c76add","data":{"tag":{"title":"Gradle","belongsTo":{"edges":[{"node":{"title":"[Springboot] Gradle을 좀 더 자세하게 알아보기","path":"/03-springboot-gradle/","date":"25. October 2020","timeToRead":7,"description":" Build.Gradle에 대한 차이에 대한 글입니다. ","content":"<h1 id=\"gradle을-좀-더-파헤쳐보자\"><a href=\"#gradle%EC%9D%84-%EC%A2%80-%EB%8D%94-%ED%8C%8C%ED%97%A4%EC%B3%90%EB%B3%B4%EC%9E%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Gradle을 좀 더 파헤쳐보자.</h1>\n<p>이전글</p>\n<ul>\n<li><a href=\"./springboot-maven-gradle-difference\">Maven과 Gradle의 차이</a></li>\n<li><a href=\"./springboot-maven-gradle-change\">Maven과 Gradle로 바꾸기</a></li>\n</ul>\n<p>이전글에서 maven과 gradle에 대해 설명하고, maven에서 gradle로 바꾸는 방법에 대해서 글을 작성하였다.</p>\n<p>그러나 <code class=\"language-text\">build.gradle</code>을 구성하면서 groovy 문법에 대해서, 더 나아가서 gradle에 대해서 좀 더 상세하게 알아봐야함을 느꼈다.</p>\n<br/>\n<h2 id=\"gradle-정의\"><a href=\"#gradle-%EC%A0%95%EC%9D%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Gradle 정의</h2>\n<p>자난번에 간략하게 설명했지만, 간략하게 설명하자면 다음과 같다.</p>\n<ul>\n<li>maven을 대체할 빌드 도구(build tool)이다.</li>\n<li>Groovy 기반의 DSL(Domain Specific Language)를 사용한다.</li>\n<li>스프링 오픈소스 프로젝트이며, 안드로이드 스튜디오에서도 사용하고 있다.</li>\n</ul>\n<p>참고 사이트 : <a href=\"https://gradle.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Gradle 공식 사이트</a></p>\n<br/>\n<h2 id=\"gradle-프로젝트에-대해\"><a href=\"#gradle-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Gradle 프로젝트에 대해</h2>\n<p>gradle의 구성은 다음과 같다. Spring gradle 에서 자주 볼수 있는 세팅이다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">.\n├── build.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradlew\n├── gradlew.bat\n├── settings.gradle\n└── src\n    ├── main\n    │   └── java\n    │       └── App.java\n    └── test\n        └── java\n            └── AppTest.java</code></pre>\n<p>하나씩 설명해보자면, 다음과 같다.</p>\n<ul>\n<li>\n<p>.gradle 폴더</p>\n<ul>\n<li>Gradle이 사용하는 폴더</li>\n<li>작업(task)로 생성된 파일이며 수정할일은 거의 없다.</li>\n</ul>\n</li>\n<li>\n<p>gralde 폴더</p>\n<ul>\n<li>Gradle이 필요한 경우 사용할 폴더</li>\n<li>Gradle 환경을 정리한 <strong>\"wrapper 파일\"</strong> 이라는 파일들이 저장되어 있다.</li>\n</ul>\n</li>\n<li>\n<p>src 폴더</p>\n<ul>\n<li>프로젝트에서 만든 프로그램 관련 폴더</li>\n<li>소스 코드 파일이나 각종 리소스 파일 등과 같이 프롲젝트에서 사용하는 파일이 있다.</li>\n<li>Maven의 구조와 비슷하다.</li>\n</ul>\n</li>\n<li>\n<p>build.gradle</p>\n<ul>\n<li>Gradle 기본 빌드 설정 파일</li>\n<li>프로젝트의 빌드 처리에 대해서 내용이 작성되어 있음</li>\n</ul>\n</li>\n<li>\n<p>gradlew, gradlew.bat</p>\n<ul>\n<li>Gradle의 명령어</li>\n<li>bat가 붙어있는 것이 window용이고, 안붙은게 macOS나 Linux용이다.</li>\n</ul>\n</li>\n<li>\n<p>settings.gradle</p>\n<ul>\n<li>프로젝트에 대한 설정 정보를 작성한 파일이다.</li>\n</ul>\n</li>\n</ul>\n<p>여기서 가장 중요한 파일은 <code class=\"language-text\">src파일</code>과 <code class=\"language-text\">build.gradle</code> 파일이다.</p>\n<br/>\n<h2 id=\"gradle의-init-명령과-type-종류\"><a href=\"#gradle%EC%9D%98-init-%EB%AA%85%EB%A0%B9%EA%B3%BC-type-%EC%A2%85%EB%A5%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Gradle의 init 명령과 type 종류</h2>\n<p>해당 게시글은 아래의 링크에서 참고하면 좋을 듯하다.</p>\n<p>: <a href=\"http://devkuma.com/books/pages/1069\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://devkuma.com/books/pages/1069</a></p>\n<br/>\n<h2 id=\"gradle-wrapper란\"><a href=\"#gradle-wrapper%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Gradle Wrapper란.</h2>\n<p>Ant로 구성된 프로젝트는 git으로 받아서 빌드를 할려면 Ant를 설치해야한다. 그러나 이 경우, 설치와 버전이 다른 부분때문에 어려운 부분이 많다. Gradle은 이 문제를 해결하기 위해 Gradle이 실행하는 스크립트를 소스 트리 안에 포함시킨 Gradle Wrapper을 제공한다.</p>\n<p>Gradle Wrapper은 이전에 말한 gradlew/gradlew.bat으로 실행하며, 처음 실행하면 지정된 버전의 Gradle과 플러그인을 다운받아 설치해버리기 때문에 편의성을 가진다.</p>\n<p><code class=\"language-text\">gradle init</code>을 하면 자동으로 gradle wrapper가 생성되지만 <code class=\"language-text\">gradle wrapper</code>로 따로 만들 수도 있다.</p>\n<br/>\n<h2 id=\"buildgradle을-좀-더-자세하게-보면\"><a href=\"#buildgradle%EC%9D%84-%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C-%EB%B3%B4%EB%A9%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>build.gradle을 좀 더 자세하게 보면.</h2>\n<p>다음과 같은 build.gradle이 있을 때.</p>\n<pre class=\"language-gradle\"><code class=\"language-gradle\">// Apply the java plugin to add support for Java\napply plugin: 'java'\n\n// Apply the application plugin to add support for building an application\napply plugin: 'application'\n\n// In this section you declare where to find the dependencies of your project\nrepositories {\n    // Use jcenter for resolving your dependencies.\n    // You can declare any Maven/Ivy/file repository here.\n    jcenter()\n}\n\ndependencies {\n    // This dependency is found on compile classpath of this component and consumers.\n    compile 'com.google.guava:guava:22.0'\n\n    // Use JUnit test framework\n    testCompile 'junit:junit:4.12'\n}\n\n// Define the main class for the application\nmainClassName = 'App'</code></pre>\n<p>하나씩 설명하면 다음과 같다.</p>\n<h3 id=\"플러그인-추가\"><a href=\"#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%B6%94%EA%B0%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>플러그인 추가</h3>\n<pre class=\"language-gradle\"><code class=\"language-gradle\">apply plugin: 'java'</code></pre>\n<ul>\n<li>\n<p><code class=\"language-text\">apply plugin:</code></p>\n<ul>\n<li>Gradle 플러그인을 사용하기 위한 것</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">apply plugin: &#39;java&#39;</code></p>\n<ul>\n<li>Java 프로그램을 위한 기능을 제공하는 플러그인</li>\n<li>compileJava이라는 테스크는 이 java 플러그인에서 제공한다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">apply plugin: &#39;application&#39;</code></p>\n<ul>\n<li>응용 프로그램에 대한 기능을 제공하는 플러그인</li>\n<li>application 플로그인을 통해 run 응용 프로그램을 실행할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"메인-클래스-이름\"><a href=\"#%EB%A9%94%EC%9D%B8-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%9D%B4%EB%A6%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>메인 클래스 이름</h3>\n<ul>\n<li>\n<p><code class=\"language-text\">mainClassName = &#39;App&#39;</code></p>\n<ul>\n<li>application 플러그인으로 사용되는 것, 메인 클래스를 지정</li>\n<li>ruin으로 응용프로그램을 실행할 수 있는 이유가 이 mainClassName 메인 클래스가 지정되어 있기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"저장소repositories\"><a href=\"#%EC%A0%80%EC%9E%A5%EC%86%8Crepositories\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>저장소(repositories)</h3>\n<p>저장소(repositories)는 각종 프로그램들이 저장되는 위치이다. 이 저장소는 \"어떤 저장소를 사용하는지\"를 빌드 파일에 작성하여 설정할 수 있다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">mavenCentral()</code></p>\n<ul>\n<li>Apache Maven 중앙 저장소를 이용하기 위한 것.</li>\n<li>Gradle은 중앙 저장소를 그대로 사용할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">jcenter()</code></p>\n<ul>\n<li>Maven과 Gradle 등 각종 빌드 도구에서 사용할 수 있는 공개 저장소</li>\n</ul>\n</li>\n</ul>\n<p>mavenCentral()와 jcenter()는 Gradle 메소드이며 이러한 repositories 안에서 호출하여 지정된 저장소를 사용할 수 있다.</p>\n<h3 id=\"의존-라이브러리dependencies\"><a href=\"#%EC%9D%98%EC%A1%B4-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%ACdependencies\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>의존 라이브러리(dependencies)</h3>\n<p>저장소에서 필요한 라이브러리를 사용하는데 사용할 수 있는 것이 dependencies이다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">compile &#39;com.google.guava:guava:22.0&#39;</code></p>\n<ul>\n<li><strong>컴파일시 의존 라이브러리</strong></li>\n<li>라이브러리가 컴파일 시에 참조된다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">testCompile &#39;junit:junit:4.12&#39;</code></p>\n<ul>\n<li><strong>테스트 컴파일시 의존 라이브러리</strong></li>\n</ul>\n</li>\n<li>\n<p>`calsspath '... 라이브러리 ...'</p>\n<ul>\n<li>지정된 라이브러리를 클래스 경로에 추가할 수 있다</li>\n<li>컴파일ㅅ에서 실행시까지 의존하는 라이브러리 지정에 사용한다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"implementation과-compile의-차이\"><a href=\"#implementation%EA%B3%BC-compile%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>implementation과 compile의 차이</h4>\n<p>가끔 다른 프로젝트를 보면 implementation과 compile로 되어 있는 것을 볼 수 있다. 이는 무슨 차이일까?</p>\n<p>간단하게 설명하면 다음과 같다.</p>\n<ul>\n<li>\n<p>Compile의 경우.</p>\n<ul>\n<li>A라는 모듈을 수정하게 되면 A를 간접 의존하는 B와 직접 의존하는 C가 있을 때, 둘다 재빌드한다.</li>\n</ul>\n</li>\n<li>\n<p>Implementation의 경우</p>\n<ul>\n<li>A라는 모듈의 경우, A를 직접 의존하는 C만 재빌드한다.</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"implementation의-장점\"><a href=\"#implementation%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Implementation의 장점</h5>\n<ol>\n<li>\n<p>compile보다 빠르다</p>\n<ul>\n<li>적은 recompile을 하므로</li>\n</ul>\n</li>\n<li>\n<p>API 노출이 적다.</p>\n<ul>\n<li>Design Pattern 중 Transparency(투명도)의 장점이 드러난다.</li>\n<li>compile을 사용하게되면 연결된 모든 모듈의 API가 노출된다.</li>\n<li>그러나 Implementation은 그렇지 않다.</li>\n</ul>\n</li>\n</ol>\n<p>Gradle 3.0부터는 compile을 비추천하고 있다.</p>\n<p>참고하면 좋은 글 : <a href=\"\">https://hack-jam.tistory.com/13</a></p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"http://devkuma.com/books/pages/1064\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://devkuma.com/books/pages/1064</a></li>\n<li><a href=\"http://devkuma.com/books/pages/1068\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://devkuma.com/books/pages/1068</a></li>\n<li><a href=\"https://ddmix.blogspot.com/2019/10/get-used-to-gradle.html?m=1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ddmix.blogspot.com/2019/10/get-used-to-gradle.html?m=1</a></li>\n<li><a href=\"\">https://hack-jam.tistory.com/13</a></li>\n</ul>\n"}},{"node":{"title":"[Springboot] Maven과 Gradle로 바꾸기","path":"/02-springboot-gradle/","date":"23. October 2020","timeToRead":2,"description":" 지난 글에 이어Maven을 Gradle로 바꾸는 내용을 설명합니다. ","content":"<h1 id=\"maven에서-gradle로-변경하기\"><a href=\"#maven%EC%97%90%EC%84%9C-gradle%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Maven에서 Gradle로 변경하기.</h1>\n<p>이전글 : <a href=\"https://Azderica.github.io/backend/2020/10/14/backend-spring-maven-gradle-diff/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Maven과 Gradle의 차이</a></p>\n<p>바꿔야하는 지에 대해서는 각자 다양한 이유(성능 문제, 업무 요청, 등등) 다양한 이유가 있을 것으로 판단된다.</p>\n<p>그렇다면 실질적으로 어떻게 Maven 프로젝트를 Gradle로 바꿀 수 있을까?</p>\n<br/>\n<h2 id=\"순서\"><a href=\"#%EC%88%9C%EC%84%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>순서</h2>\n<p>macOS를 대상으로 진행합니다. (windows는 다른 좋은글이 많아서...)</p>\n<h3 id=\"1-gradle-설치\"><a href=\"#1-gradle-%EC%84%A4%EC%B9%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. gradle 설치</h3>\n<p>gradle 자동 설치 (수동 설치는 <a href=\"https://gradle.org/gradle-download/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://gradle.org/gradle-download/</a>)</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> gradle</code></pre>\n<h3 id=\"2-pomxml을-buildgradle로-변환\"><a href=\"#2-pomxml%EC%9D%84-buildgradle%EB%A1%9C-%EB%B3%80%ED%99%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. pom.xml을 build.gradle로 변환</h3>\n<p>프로젝트 폴더에 있는 pom.xml을 build.gradle로 변환한다.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">gradle init --type pom</code></pre>\n<h3 id=\"3-buildgradle를-프로젝트에-맞춰-수정\"><a href=\"#3-buildgradle%EB%A5%BC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EB%A7%9E%EC%B6%B0-%EC%88%98%EC%A0%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>3. build.gradle를 프로젝트에 맞춰 수정</h3>\n<p>프로젝트 요구사항에 맞춰서 build.gradle 파일을 수정한다.</p>\n<p>mvnrepostiroy : <a href=\"https://mvnrepository.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://mvnrepository.com/</a></p>\n<p>위 링크에서 필요한 파일을 받아서 수정하면 좋을 듯하다.</p>\n<br/>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>마무리.</h2>\n<p>만약에 회사 업무가 아닌 오픈소스로 구성된 프로젝트라면 잘 진행될 것이다.</p>\n<p>회사 프로젝트의 경우에는 회사에서 사용하는 라이브러리나 플러그인이 다를 것이기 때문에 약간의 삽질이 필요한 듯하다.</p>\n<p>다음 글에서는 <code class=\"language-text\">build.gradle</code>에서 <code class=\"language-text\">compile</code>과 <code class=\"language-text\">implementation</code>의 차이에 대해서, 또한 다른 요소에 대한 분석 글을 작성해야겠다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://kimpaper.github.io/2016/07/14/gradle/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kimpaper.github.io/2016/07/14/gradle/</a></li>\n<li><a href=\"https://dynaticy.tistory.com/entry/Maven-Gradle-%EB%B3%80%ED%99%98-pomxml%EB%A1%9C-buildscript-%EB%A7%8C%EB%93%A4%EA%B8%B0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://dynaticy.tistory.com/entry/Maven-Gradle-%EB%B3%80%ED%99%98-pomxml%EB%A1%9C-buildscript-%EB%A7%8C%EB%93%A4%EA%B8%B0</a></li>\n<li><a href=\"https://thecodinglog.github.io/gradle/2019/09/11/install-gradle-in-windows.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://thecodinglog.github.io/gradle/2019/09/11/install-gradle-in-windows.html</a></li>\n</ul>\n"}},{"node":{"title":"[Springboot] Maven과 Gradle의 차이","path":"/01-springboot-gradle/","date":"14. October 2020","timeToRead":5,"description":" Maven과 Gradle에 대한 차이에 대한 글입니다. ","content":"<h1 id=\"maven과-gradle\"><a href=\"#maven%EA%B3%BC-gradle\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Maven과 Gradle.</h1>\n<p>최근 회사 업무를 진행하면서 Spring boot 프로젝트 중 하나를 maven에서 gradle로 수정해야하는 일이 발생했다.</p>\n<p>생각해보니, 둘이 다른 것은 알고 있었지만 어떻게 다른가에 대해서는 생각해본적이 없다.</p>\n<p>해당 프로젝트를 진행하면서 둘의 차이를 인지해볼려고 한다. 그리고 왜 바꿔야하는지를 알려고 한다.</p>\n<br/>\n<h2 id=\"maven과-gradle의-차이\"><a href=\"#maven%EA%B3%BC-gradle%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Maven과 Gradle의 차이</h2>\n<h3 id=\"maven\"><a href=\"#maven\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Maven</h3>\n<blockquote>\n<p>자바용 프로젝트 관리 도구, 아파치 Ant의 대안으로 만들어졌다.</p>\n</blockquote>\n<p>특징</p>\n<ul>\n<li>빌드를 쉽게할 수 있다.</li>\n<li><code class=\"language-text\">pom.xml</code>을 이용한 정형화된 빌드 시스템을 사용할 수 있다.</li>\n<li>뛰어난 프로젝트 정보를 제공한다</li>\n<li>개발 가이드 라인을 제공한다</li>\n<li>새로운 기능을 쉽게 설치할 수 있고 업데이트할 수 있다.</li>\n</ul>\n<h3 id=\"gradle\"><a href=\"#gradle\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Gradle</h3>\n<blockquote>\n<p>Groovy를 이용한 빌드 자동화 시스템이다. Maven 이후에 나왔다.</p>\n<p>Android의 OS 공식 빌드 도구로 사용됩니다.</p>\n</blockquote>\n<p>특징</p>\n<ul>\n<li>Ant처럼 유연한 범용 빌드 도구를 사용한다.</li>\n<li>Maven을 사용할 수 있는 변환 가능 컨벤션 프레임 워크입니다.</li>\n<li>멀티 프로젝트에 사용하기 좋습니다.</li>\n<li>Apache Ivy에 기반을 두어 강력한 의존성 관리를 제공합니다.</li>\n<li>Mavenrhk Ivy 레파지토리를 완전 지원합니다</li>\n<li>원격 저장소나 pom, ivy 파일 없이 연결되는 의존성을 관리하고 지원합니다,</li>\n<li>그루비 문법을 사용합니다.</li>\n<li>빌드를 설명하는 풍부한 도메인 모델을 사용합니다.</li>\n</ul>\n<h3 id=\"maven보다는-gradle을-선택하자\"><a href=\"#maven%EB%B3%B4%EB%8B%A4%EB%8A%94-gradle%EC%9D%84-%EC%84%A0%ED%83%9D%ED%95%98%EC%9E%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Maven보다는 Gradle을 선택하자.</h3>\n<p>Gradle이 시기적으로 늦게 나오게 되면서 사용성, 성능 등 뛰어난 스펙을 사용합니다.</p>\n<p>좋은 점을 나열한다면.</p>\n<ul>\n<li>\n<p>Maven처럼 Build라는 동적 요소를 XML을 사용하기에는 어려운 부분이 있습니다.</p>\n<ul>\n<li>설정 내용이 길어지고 가독성이 떨어집니다.</li>\n<li>의존관계가 복잡한 프로젝트 설정에는 부적절합니다.</li>\n<li>상속구조를 이용해 멀티 모듈을 구성해야합니다.</li>\n<li>특정 설정을 소수의 모듈에서 공유하기 위해서는 부모 프로젝트를 생성하여 상속해야합니다.</li>\n</ul>\n</li>\n<li>\n<p>Gradle은 Groovy를 사용하기 때문에, 동적인 빌드는 Groovy 스크립트로 플러그인을 호출하고 직점 코드를 구성할 수 있습니다.</p>\n<ul>\n<li>Configruation Injection(의존성 주입) 방식을 사용해서 공통 모듈을 상속해서 사용하는 단점을 해결합니다.</li>\n<li>설정 주입 시 프로젝트의 조건을 체크할 수 있어서 프로젝트별로 주입되는 설정을 다르게 할 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>가장 중요한 것은 규모가 커질수록 속도가 월등하게 빠릅니다.</strong></p>\n<ul>\n<li>\n<p>일반적인 경우</p>\n<ul>\n<li><img src=\"https://user-images.githubusercontent.com/42582516/95992954-7a3b6580-0e69-11eb-9ebe-4b057e33bd17.png\" alt=\"image\"></li>\n</ul>\n</li>\n<li>\n<p>큰 멀티 프로젝트</p>\n<ul>\n<li><img src=\"https://user-images.githubusercontent.com/42582516/95992968-7f001980-0e69-11eb-99cd-24a17dd14570.png\" alt=\"image\"></li>\n</ul>\n</li>\n<li>\n<p>어떤 방법으로 이러한 차이를 내나면.</p>\n<ul>\n<li>Gradle Daemon은 \"hot\"이라는 정보를 메모리에 저장하여 프로세스에 길게 유지시킵니다.</li>\n<li>다양한 tasks의 타입의 증가하는 input과 output에 새로 실행할 필요가 없습니다.</li>\n<li>incremental compilation을 통해 소스와 클래스의 종속성을 분석하여 변경되는 부분만 다시 컴파일 시킵니다.</li>\n<li>이미 생성된 캐시를 새로 생성하지 않고, 가져옵니다.</li>\n<li>Gradle의 smart class 경로 분석기는 라이브러리가 변경되지않은 경우, 불필요한 컴파일을 방지합니다.</li>\n<li>Java Library 플러그인을 사용해서 종속성을 더 잘 모델링하고 컴파일 클래스 경로를 줄여서 성능을 향상시킵니다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>이러한 부분에서 Gradle이 Maven보다 좋은 점을 알 수 있었습니다.</p>\n<p>원래 포스터의 내용은 Gradle에서 Maven으로 수정하는 부분을 작성하는 것이였는데 너무 길어져서 다음 포스팅에 작성할 예정입니다.</p>\n<hr>\n<p><strong>출처</strong></p>\n<ul>\n<li><a href=\"https://gradle.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://gradle.org/</a></li>\n<li><a href=\"https://maven.apache.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://maven.apache.org/</a></li>\n<li><a href=\"http://egloos.zum.com/kwon37xi/v/4747016\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://egloos.zum.com/kwon37xi/v/4747016</a></li>\n<li><a href=\"https://bkim.tistory.com/13\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://bkim.tistory.com/13</a></li>\n<li><a href=\"https://okky.tistory.com/179\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://okky.tistory.com/179</a></li>\n</ul>\n"}}]}}},"context":{}}