---
layout: post
title: "[Review] Clean Code 내용정리 - 6"
subtitle: "Clean Code 내용정리 - 6"
categories: review
tags: review clean-code clean code java
comments: true

---

# Clean Code 내용 정리 - 6

## 4장. 주석

부정확한 주석은 아예 없는 주석보다 나쁘다.

1.  주석은 나쁜 코드를 보완하지 못한다.
    -   코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문에, 주석보다는 코드를 정리를 해야 한다.
2.  코드로 의도를 표현하기.
    -   많은 경우에서 주석에서 할 수 있는 설명을 함수로 표현해도 충분하다

### 좋은 주석

1.  법적인 주석
    
    -   회사가 정립한 구현 표준을 지켜야 하는 경우
2.  정보를 제공하는 주석
    
    -   기본적인 정보를 주석으로 제공
        
    -   Ex)
        
        ```java
        // kk:mm:ss EEE, MMM dd, yyyy 형식이다.
        Pattern timeMatcher = Pattern.compile(
            "\\d*:\\d*:\\d* \\w*, \\w*, \\d*, \\d*");
        ```
        
3.  의도를 설명하는 주석
    
    -   의도를 표현
        
    -   Ex)
        
        ```java
        public void testConcurrentAddWidgets() throw Exception {
          ...
          // 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다.
          for(int i=0; i<25000; i++){
            WidgetBuilderThread widgetBuilderThread = new WidgetBuilderThread(widgetBuilder, text, parent, failFlag);
            Thread thread = new Thread(widgetBuilderThread);
            thread.start();
          }
          assertEquals(false, failFlag.get());
        }
        ```
        

4.  의미를 명료하게 밝히는 주석
    
    -   모호한 인수나 반환 값의 의미를 읽기 좋게 표현
        
    -   Ex)
        
        ```java
        ...
        
        assertThat(a.compareTo(a) == 0);    // a == a
        assertThat(a.compareTo(b) != 0);    // a != b
        ...
        ```
        

5.  결과를 경고하는 주석
    
    -   결과를 경고할 목적
        
    -   Ex)
        
        ```java
        public static SimpleDateFormat makeStandardHttpDataFormat(){
          // SimpleDateFormat은 스레드에 안전하지 못하다.
          // 따라서 각 인스턴스를 독립적으로 생성해야 한다.
          SimpleDateFormat df = new SimpleDateFormat("EEE, dd MMM. yyyy HH:mm:ss z");
          df.setTimeZone(TimeZone.getTimeZone("GMT"));
          return df;
        }
        ```
        
6.  TODO 주석
    
    -   앞으로 할 일을 설명할 때 괜찮다.
        
    -   Ex)
        
        ```java
        // TODO-MdM 현재 필요하지 않다
        // 체크아웃 모델을 도입하면 함수가 필요 없다.
        protected VersionInfo makeVersion() throws Exception{
          return null;
        }
        ```
        
7.  중요성을 강조하는 주석
    
    -   중요성을 강조하기 위해 주석을 사용한다.
        
    -   Ex)
        
        ```java
        String listItemContent = match.group(3).trim();
        // 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다.
        // 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다.
        new ListItemWidget(this, listItemContent, this.level + 1);
        return buildList(text.substring(match.end()));
        ```
        
8.  공개 API에서 Javadocs
    
    -   설명이 잘 된 공개 API를 사용하는 것도 방법.

### 나쁜 주석

1.  주절거리는 주석
2.  같은 이야기를 중복하는 주석
3.  오해할 여지가 있는 주식
4.  의무적으로 다는 주석
5.  이력을 기록하는 주석
6.  있으나 마나 한 주석
7.  무서운 잡음 : 의미 없는 주석
8.  함수나 변수로 표현할 수 있다면 주석을 달지 말기.
9.  위치를 표시하는 주석
    -   Ex) `// Action//////////////`
    -   반드시 필요할 때만, 아주 드물게 사용하기
10.  닫는 괄호에 다는 주석
11.  공로를 돌리거나 저자를 표시하는 주석
12.  주석으로 처리한 코드
13.  HTML 주석
    -   너무 지저분하다.
14.  전역 정보
15.  너무 많은 정보
16.  모호한 관계
    -   주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다.
17.  함수 헤더
    -   짧은 함수는 긴 설명이 필요 없다.
18.  비공개 코드에서 Javadocs
    -   공개하지 않을 코드라면 Javadocs는 쓸모가 없음.

## 5장. 형식 맞추기

프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야하고, 코드 형식을 맞추기 위한 간단한 규칙을 정하고 이를 수행해야 한다.

### 형식을 맞추는 목적

-   코드 형식은 중요하다.
-   오늘 구현한 코드는 다음 버전에서 바뀔 확률이 높으며, 구현한 코드의 가독성은 이후 바뀔 코드의 품질에 지대한 영향을 미친다.

### 적절한 행 길이를 유지하기 (세로 형식)

사실 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다.

1.  신문 기사처럼 작성하기
    
    -   좋은 신문 기사는 최상단에서 기사를 몇 마디로 요약하는 표제가 있다.
    -   소스파일도 이름은 간단하면서 설명이 가능하게 짓는다.
    -   신문이 다양한 기사로 이뤄지는 것처럼, 소스 코드도 그렇게 구성한다.
2.  개념은 빈 행으로 분리하기
    
    -   ```java
        // 좋은 케이스
        private String function1(){
          ...
        };
        
        private String function2(){
          ...
        };
        
        // 나쁜 케이스
        private String function1(){
          ...
        };
        private String function2(){
          ...
        };
        ```
        
3.  세로 밀집도
    
    -   줄 바꿈이 개념을 분리한다면, 세로 밀집도는 연관성을 의미
4.  수직거리
    
    -   서로 밀집한 개념은 세로로 가까이 둔다. 단, 다른 파일에 속한다면 규칙은 통하지 않는다.
        
    -   타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 한다.
        
    -   **변수 선언**
        
        -   변수는 사용하는 위치에 최대한 가까이 선언
    -   **인스턴스 변수**
        
        -   인스턴스 변수는 클래스 맨 처음에 선언
    -   **종속 함수**
        
        -   한 함수가 다른 함수를 호출한다면, 두 함수는 세로로 가까이 배치한다.
    -   **개념적 유사성**
        
        -   개념적인 친화도가 높을수록 코드를 가까이 배치한다.
5.  세로 순서
    
    -   일반적으로 함수 호출 종속성은 아래 방향으로 유지

### 가로 형식 맞추기

일반적으로는 가로길이는 45자 근처이다. (가급적으로는 120자 정도를 제한)

1.  가로 공백과 밀집도
    
    -   가로 공백을 사용해 밀집한 개념과 느슨한 개념을 표현
        
    -   Ex)
        
        ```java
        private void measureLine(String line){
          lineCount++;
          int lineSize = line.length();    // 느슨한 개념
          totalhars += lineSize;
          lineWidthHistogram.addLine(lineSize, lineCount);
          recordWidestLine(lineSize);        // 밀집한 개념
        }
        ```
        
2.  가로 정렬
    
    -   코드처럼 선언부가 길다면 클래스를 쪼개야 한다는 의미
3.  들여 쓰기
    
    -   scope로 이뤄진 계층을 보여준다.
    -   **"들여 쓰기 무시하기"를** 피하기
4.  가짜 범위
    
    -   세미콜론은 새 행에다 제대로 들여 써서 넣어준다.

### 팀 규칙

좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이뤄 저 야한다.

## 6장. 객체와 자료 구조

### 자료 추상화

-   자료를 세세하게 공개하기보다는 추성적인 개념으로 표현하는 편이 좋다.
-   아무 생각 없이 GET/SET을 추가하는 방법은 좋지 않다.

### 자료/객체 비대칭

-   모든 것이 객체가 좋은 것은 아니고, 단순한 자료 구조와 절차적인 코드가 좋을 때도 있음
-   객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉽고, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉬움.

### 디미터 법칙

> 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙  
> 즉, 객체의 내부를 몰라야 한다는 법칙

1.  기차 충돌
    
    -   ```java
        // 기차 충돌 코드
        final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
        
        // 이를 방지하는 코드
        Options opts = ctxt.getOptions();
        File scratchDir = opts.getScratchDir();
        final String outputDir = scratchDir.getAbsolutePath();
        
        // 단, 아래의 코드는 디미터 법칙과 상관 없음.
        final String outputDir = ctxt.options.scratchDir.absolutePath;
        ```
        
    -   자료 구조는 무조건 함수 없이 공개 변수만 포함한다면, 문제는 간단하겠지만  
        그럴 수 없기 때문에 요구하는 프레임워크와 표준(ex. 빈)이 존재한다.
        
2.  잡종 구조
    
    -   잡종 구조는 절차적과 객체적의 단점만 모아놓은 구조이기 때문에, 피하는 편이 좋다.
3.  구조체 감추기
    

### 자료 전달 객체

DTO나 빈 구조 등을 사용한다

-   활성 레코드
    -   DTO의 특수한 형태, 자료 구조로 취급하기
    -   비즈니스 규칙은 넣는 것이 아니고, 비즈니스 규칙을 넣고 싶으면 내부 자료를 숨기는 객체를 따로 생성한다.

### 결론

-   객체는 동작을 공개하고 자료를 숨긴다. 그러나, 자료 구조는 별다른 도작 없이 자료를 노출한다.
-   어떤 시스템을 구현할 때
    -   새로운 자료 타입을 추가하는 유연성이 필요하면 객체를 선택.
    -   새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다.# Clean Code 내용 정리 - 6

## 부록 A. 동시성

###   
클라이언트/서버 예제

#### 서버

애플리케이션에서 많은 시간을 보내는 가능성은 크게 2개이다.

-   I/O : 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 emd
-   프로세서 : 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등

일반적으로 프로그램이 **프로세서 연산에 많은 시간을 보낸다면, 하드웨어를 추가하여 성능을 높여야 한다.**  
  
즉, 스레드를 늘린다고 해결할 수 있는 문제가 아니다.

하지만 프로그램이 주로 **I/O 연산에 시간을 보낸다면 동시성이 성능을 높여 줄 수 있다.**

#### 결론

단일스레드 시스템에서 다중 스레드 시스템으로 변환하고, 성능을 높이기 위해서는 다음과 같은 방법을 사용해야한다.

-   I/O에 많은 시간을 보내야 한다.
-   관련된 코드를 분리시켜 여러개의 클래스로 분리해 **단일 책임 원칙**을 지켜야 한다.

### 가능한 실행 경로

10000개의 스레드로 현재 값인 변수에 1을 더한다고 했을 때 가정했을때,  
  
최악의 경우는 1부터 10000까지 나올 수 있다.

이를 해결하기 위해서는 ...

#### 심층 분석

3가지 정의를 이야기할 수 있다.

-   **프레임** : 모든 메서드 호출에는 프레임이 필요하다
-   **지역 변수** : 메서드 범위 내에 정의되는 모든 변수를 가리킴
-   **피연산자 스택** : JVM이 지원하는 명령 대다수는 매개변수를 받으며, 이 매개변수를 저장하는 장소

이 3개를 atomic으로 잘 처리한다면, 결과는 일정하다.

##### 결론

스레드가 서로의 작업을 덮어쓰는 과정을 이해하기 위해서는 어떤 연산이 안전한지 못한지에 파악할 수 있도록 메모리 모델을 이해하고 있어야한다.

즉, 아래의 3가지를 이해해야 한다.

-   공유 객체/값이 있는 곳
-   동시 읽기/수정 문제를 일으킬 소지가 있는 코드
-   동시성 문제를 방지하는 법

### 라이브러리를 이해하기

#### Executor 프레임워크

-   스레드 풀링으로 정교한 실행을 지원한다.
-   코드가 깔끔해지고 이해하기 쉬워지며, 크기가 작아진다.
-   스레드 풀 크기를 자동으로 조정하며, 재사용할 수 있다.

#### 스레드를 차단하지 않는 방법(non blocking)

-   최신 프로세서는 blocking 하지 않고 안정적으로 값을 갱신한다.
    -   Ex) AtomicInteger, incrementAndGet() 등등
-   현대 프로세서는 CAS(Compare and Swap)을 지원한다.

#### 다중 스레드 환경에서 안전하지 않은 클래스

다중 스레드 환경에서 안정하지 않는 환경은 다음과 같다.

-   SimpleDateFormat
-   데이터베이스 연결
-   java.util 컨테이너 클래스
-   서블릿

### 메서드 사이에 존재하는 의존성 조심

추적하기 어렵지만 이를 해결하는 방안은 크게 3가지로 구성된다.

#### 1\. 실패를 용인하기

#### 2\. 클라이언트-기반 잠금

굉장히 위험한 전략이다.

#### 3\. 서버-기반 잠금

일반적으로 가장 바람직한 방법이다.

-   코드 중복이 줄어든다.
-   성능이 좋아진다.
-   오류가 발생할 가능성이 줄어든다.
-   스레드 정책이 하나이다.
-   공유 변수 범위가 절어든다.

### 작업 처리량 높이기

동기화 영역은 언제나 작아야한다.

### 데드락

데드락의 4가지 조건

-   상호 배제 (Mutual Exclusion)
-   잠금 & 대기 (Lock & Wait)
-   선점 불가 (No Preemption)
-   순환 대기 (Circular Wait)

#### 상호 배제

-   정의 : 여러 스레드가 동시에 사용하지 못하고, 개수가 제한적인 경우
-   해결책
    -   동시에 사용해도 괜찮은 자원을 사용, Ex) Atomic
    -   스레드 수 이상으로 자원 수를 높임
    -   자원을 점유하기 전에 필요한 자원이 모두 있는지 확인

#### 잠금 & 대기

-   정의 : 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않는다.
-   해결책
    -   대기하지 않기
-   문제점
    -   기아(Starvation) : 한 스레드가 계속해서 필요한 자원을 점유하지 못하는 것
    -   라이브락(Livelock) : 여러 스레드가 한번에 잠금으로 들어가 계속 자원을 점유했다 내놨다를 반복하는 것

#### 선점 불가

-   정의 : 한 스레드가 다른 스레드로부터 자원을 빼앗지 못함
-   해결책
    -   다른 자원을 뺏어오기

#### 순환 대기

-   정의 : 스레드 A는 B가 끝나기를 기다리고, 스레드 B는 A가 끝나기를 기다리는 상황
-   해결책 : 간단한 규약을 설정해서 순환이 없도록 한다
-   문제점
    -   자원을 할당하는 순서와 자원을 사용하는 순서를 다르게 한다
    -   때로는 순서에 따라 자원을 할당하기 어려움

### 다중 스레드 코드 테스트

-   몬테 카를로 테스트 : 조율이 가능하게 유연하게 테스트를 만든다
-   시스템을 배치할 플랫폼 전부에서 테스트를 돌린다
-   부하가 변하는 장비에서 테스트를 돌린다.

### 스레드 코드 테스트를 도와주는 도구

대표적인 예시로 IBM의 ConTest가 있다.

사용방법은 다음과 같다.

-   실제 코드와 테스트 코드 작성
-   ConTest로 실제 코드와 테스트 코드에 보조 코드 추가
-   테스트를 실행

---

드디어 정리 완료.

**부록 B. org.jfree.date.SerialDate** 와 **부록 C. 휴리스틱의 교차 참조 목록** 은 코드 위주라서, 해당 부분을 따로 추가하지 않았다.

점차 이전의 게시글을 틈틈이 수정하면서 가독성을 높이는 작업을 할 예정.

책의 내용을 대부분 정리하기는 했지만, 코드나 원글의 내용을 다 담지 못한 듯 하여 한번 책을 읽어보는 것이 좋을 듯합니다.